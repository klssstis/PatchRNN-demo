From 6e61d75f5258dc395c131ad5edd712852e29939e Mon Sep 17 00:00:00 2001
From: Andres Freund <andres@anarazel.de>
Date: Fri, 4 Oct 2019 21:11:23 -0700
Subject: [PATCH] Disable one set of tests from c8841199509.

One of the upsert related tests is unstable (sometimes even hanging
until isolationtester's step timeout is reached). Based on preliminary
analysis that might be a problem outside of just that test, but not
really related to EPQ and triggers.  Disable for now, to get the
buildfarm greener again.

Discussion: https://postgr.es/m/20191004222437.45qmglpto43pd3jb@alap3.anarazel.de
Backpatch: 9.6-, just like c8841199509.
---
 .../expected/eval-plan-qual-trigger.out       | 219 +-----------------
 .../specs/eval-plan-qual-trigger.spec         |  21 +-
 2 files changed, 13 insertions(+), 227 deletions(-)

diff --git a/src/test/isolation/expected/eval-plan-qual-trigger.out b/src/test/isolation/expected/eval-plan-qual-trigger.out
index ad1faa6cc6f6..517fb3ea3ad5 100644
--- a/src/test/isolation/expected/eval-plan-qual-trigger.out
+++ b/src/test/isolation/expected/eval-plan-qual-trigger.out
@@ -2054,223 +2054,6 @@ key            data
 key-a          val-a-s1-ups1-ups3
 key-b          val-b-s1       
 
-starting permutation: s1_trig_rep_b_i s1_trig_rep_b_d s1_trig_rep_b_u s1_trig_rep_a_i s1_trig_rep_a_d s1_trig_rep_a_u s1_ins_a s1_b_rc s2_b_rc s3_b_rc s1_upd_a_data s3_upd_a_data s2_upsert_a_data s1_upd_a_data s1_c s3_del_a s3_c s2_c s0_rep
-step s1_trig_rep_b_i: CREATE TRIGGER rep_b_i BEFORE INSERT ON trigtest FOR EACH ROW EXECUTE PROCEDURE trig_report();
-step s1_trig_rep_b_d: CREATE TRIGGER rep_b_d BEFORE DELETE ON trigtest FOR EACH ROW EXECUTE PROCEDURE trig_report();
-step s1_trig_rep_b_u: CREATE TRIGGER rep_b_u BEFORE UPDATE ON trigtest FOR EACH ROW EXECUTE PROCEDURE trig_report();
-step s1_trig_rep_a_i: CREATE TRIGGER rep_a_i AFTER INSERT ON trigtest FOR EACH ROW EXECUTE PROCEDURE trig_report();
-step s1_trig_rep_a_d: CREATE TRIGGER rep_a_d AFTER DELETE ON trigtest FOR EACH ROW EXECUTE PROCEDURE trig_report();
-step s1_trig_rep_a_u: CREATE TRIGGER rep_a_u AFTER UPDATE ON trigtest FOR EACH ROW EXECUTE PROCEDURE trig_report();
-s1: NOTICE:  trigger: name rep_b_i; when: BEFORE; lev: ROWs; op: INSERT; old: <NULL> new: (key-a,val-a-s1)
-s1: NOTICE:  trigger: name rep_a_i; when: AFTER; lev: ROWs; op: INSERT; old: <NULL> new: (key-a,val-a-s1)
-step s1_ins_a: INSERT INTO trigtest VALUES ('key-a', 'val-a-s1') RETURNING *;
-key            data           
-
-key-a          val-a-s1       
-step s1_b_rc: BEGIN ISOLATION LEVEL READ COMMITTED; SELECT 1;
-?column?       
-
-1              
-step s2_b_rc: BEGIN ISOLATION LEVEL READ COMMITTED; SELECT 1;
-?column?       
-
-1              
-step s3_b_rc: BEGIN ISOLATION LEVEL READ COMMITTED; SELECT 1;
-?column?       
-
-1              
-s1: NOTICE:  upd: text key-a = text key-a: t
-s1: NOTICE:  upk: text val-a-s1 <> text mismatch: t
-s1: NOTICE:  trigger: name rep_b_u; when: BEFORE; lev: ROWs; op: UPDATE; old: (key-a,val-a-s1) new: (key-a,val-a-s1-ups1)
-s1: NOTICE:  trigger: name rep_a_u; when: AFTER; lev: ROWs; op: UPDATE; old: (key-a,val-a-s1) new: (key-a,val-a-s1-ups1)
-step s1_upd_a_data: 
-    UPDATE trigtest SET data = data || '-ups1'
-    WHERE
-        noisy_oper('upd', key, '=', 'key-a') AND
-        noisy_oper('upk', data, '<>', 'mismatch')
-    RETURNING *;
-
-key            data           
-
-key-a          val-a-s1-ups1  
-s3: NOTICE:  upd: text key-a = text key-a: t
-s3: NOTICE:  upk: text val-a-s1 <> text mismatch: t
-step s3_upd_a_data: 
-    UPDATE trigtest SET data = data || '-ups3'
-    WHERE
-        noisy_oper('upd', key, '=', 'key-a') AND
-        noisy_oper('upk', data, '<>', 'mismatch')
-    RETURNING *;
- <waiting ...>
-s2: NOTICE:  trigger: name rep_b_i; when: BEFORE; lev: ROWs; op: INSERT; old: <NULL> new: (key-a,val-a-upss2)
-step s2_upsert_a_data: 
-    INSERT INTO trigtest VALUES ('key-a', 'val-a-upss2')
-    ON CONFLICT (key)
-        DO UPDATE SET data = trigtest.data || '-upserts2'
-        WHERE
-            noisy_oper('upd', trigtest.key, '=', 'key-a') AND
-            noisy_oper('upk', trigtest.data, '<>', 'mismatch')
-    RETURNING *;
- <waiting ...>
-s1: NOTICE:  upd: text key-a = text key-a: t
-s1: NOTICE:  upk: text val-a-s1-ups1 <> text mismatch: t
-s1: NOTICE:  trigger: name rep_b_u; when: BEFORE; lev: ROWs; op: UPDATE; old: (key-a,val-a-s1-ups1) new: (key-a,val-a-s1-ups1-ups1)
-s1: NOTICE:  trigger: name rep_a_u; when: AFTER; lev: ROWs; op: UPDATE; old: (key-a,val-a-s1-ups1) new: (key-a,val-a-s1-ups1-ups1)
-step s1_upd_a_data: 
-    UPDATE trigtest SET data = data || '-ups1'
-    WHERE
-        noisy_oper('upd', key, '=', 'key-a') AND
-        noisy_oper('upk', data, '<>', 'mismatch')
-    RETURNING *;
-
-key            data           
-
-key-a          val-a-s1-ups1-ups1
-step s1_c: COMMIT;
-s3: NOTICE:  upd: text key-a = text key-a: t
-s3: NOTICE:  upk: text val-a-s1-ups1-ups1 <> text mismatch: t
-s3: NOTICE:  trigger: name rep_b_u; when: BEFORE; lev: ROWs; op: UPDATE; old: (key-a,val-a-s1-ups1-ups1) new: (key-a,val-a-s1-ups1-ups1-ups3)
-s3: NOTICE:  trigger: name rep_a_u; when: AFTER; lev: ROWs; op: UPDATE; old: (key-a,val-a-s1-ups1-ups1) new: (key-a,val-a-s1-ups1-ups1-ups3)
-step s3_upd_a_data: <... completed>
-key            data           
-
-key-a          val-a-s1-ups1-ups1-ups3
-s3: NOTICE:  upd: text key-a = text key-a: t
-s3: NOTICE:  upk: text val-a-s1-ups1-ups1-ups3 <> text mismatch: t
-s3: NOTICE:  trigger: name rep_b_d; when: BEFORE; lev: ROWs; op: DELETE; old: (key-a,val-a-s1-ups1-ups1-ups3) new: <NULL>
-s3: NOTICE:  trigger: name rep_a_d; when: AFTER; lev: ROWs; op: DELETE; old: (key-a,val-a-s1-ups1-ups1-ups3) new: <NULL>
-step s3_del_a: 
-    DELETE FROM trigtest
-    WHERE
-        noisy_oper('upd', key, '=', 'key-a') AND
-        noisy_oper('upk', data, '<>', 'mismatch')
-    RETURNING *
-
-key            data           
-
-key-a          val-a-s1-ups1-ups1-ups3
-step s3_c: COMMIT;
-s2: NOTICE:  trigger: name rep_a_i; when: AFTER; lev: ROWs; op: INSERT; old: <NULL> new: (key-a,val-a-upss2)
-step s2_upsert_a_data: <... completed>
-key            data           
-
-key-a          val-a-upss2    
-step s2_c: COMMIT;
-step s0_rep: SELECT * FROM trigtest ORDER BY key, data
-key            data           
-
-key-a          val-a-upss2    
-
-starting permutation: s1_trig_rep_b_i s1_trig_rep_b_d s1_trig_rep_b_u s1_trig_rep_a_i s1_trig_rep_a_d s1_trig_rep_a_u s1_ins_a s1_b_rc s2_b_rc s3_b_rc s1_upd_a_data s3_upd_a_data s2_upsert_a_data s1_upd_a_data s1_c s3_del_a s3_r s2_c s0_rep
-step s1_trig_rep_b_i: CREATE TRIGGER rep_b_i BEFORE INSERT ON trigtest FOR EACH ROW EXECUTE PROCEDURE trig_report();
-step s1_trig_rep_b_d: CREATE TRIGGER rep_b_d BEFORE DELETE ON trigtest FOR EACH ROW EXECUTE PROCEDURE trig_report();
-step s1_trig_rep_b_u: CREATE TRIGGER rep_b_u BEFORE UPDATE ON trigtest FOR EACH ROW EXECUTE PROCEDURE trig_report();
-step s1_trig_rep_a_i: CREATE TRIGGER rep_a_i AFTER INSERT ON trigtest FOR EACH ROW EXECUTE PROCEDURE trig_report();
-step s1_trig_rep_a_d: CREATE TRIGGER rep_a_d AFTER DELETE ON trigtest FOR EACH ROW EXECUTE PROCEDURE trig_report();
-step s1_trig_rep_a_u: CREATE TRIGGER rep_a_u AFTER UPDATE ON trigtest FOR EACH ROW EXECUTE PROCEDURE trig_report();
-s1: NOTICE:  trigger: name rep_b_i; when: BEFORE; lev: ROWs; op: INSERT; old: <NULL> new: (key-a,val-a-s1)
-s1: NOTICE:  trigger: name rep_a_i; when: AFTER; lev: ROWs; op: INSERT; old: <NULL> new: (key-a,val-a-s1)
-step s1_ins_a: INSERT INTO trigtest VALUES ('key-a', 'val-a-s1') RETURNING *;
-key            data           
-
-key-a          val-a-s1       
-step s1_b_rc: BEGIN ISOLATION LEVEL READ COMMITTED; SELECT 1;
-?column?       
-
-1              
-step s2_b_rc: BEGIN ISOLATION LEVEL READ COMMITTED; SELECT 1;
-?column?       
-
-1              
-step s3_b_rc: BEGIN ISOLATION LEVEL READ COMMITTED; SELECT 1;
-?column?       
-
-1              
-s1: NOTICE:  upd: text key-a = text key-a: t
-s1: NOTICE:  upk: text val-a-s1 <> text mismatch: t
-s1: NOTICE:  trigger: name rep_b_u; when: BEFORE; lev: ROWs; op: UPDATE; old: (key-a,val-a-s1) new: (key-a,val-a-s1-ups1)
-s1: NOTICE:  trigger: name rep_a_u; when: AFTER; lev: ROWs; op: UPDATE; old: (key-a,val-a-s1) new: (key-a,val-a-s1-ups1)
-step s1_upd_a_data: 
-    UPDATE trigtest SET data = data || '-ups1'
-    WHERE
-        noisy_oper('upd', key, '=', 'key-a') AND
-        noisy_oper('upk', data, '<>', 'mismatch')
-    RETURNING *;
-
-key            data           
-
-key-a          val-a-s1-ups1  
-s3: NOTICE:  upd: text key-a = text key-a: t
-s3: NOTICE:  upk: text val-a-s1 <> text mismatch: t
-step s3_upd_a_data: 
-    UPDATE trigtest SET data = data || '-ups3'
-    WHERE
-        noisy_oper('upd', key, '=', 'key-a') AND
-        noisy_oper('upk', data, '<>', 'mismatch')
-    RETURNING *;
- <waiting ...>
-s2: NOTICE:  trigger: name rep_b_i; when: BEFORE; lev: ROWs; op: INSERT; old: <NULL> new: (key-a,val-a-upss2)
-step s2_upsert_a_data: 
-    INSERT INTO trigtest VALUES ('key-a', 'val-a-upss2')
-    ON CONFLICT (key)
-        DO UPDATE SET data = trigtest.data || '-upserts2'
-        WHERE
-            noisy_oper('upd', trigtest.key, '=', 'key-a') AND
-            noisy_oper('upk', trigtest.data, '<>', 'mismatch')
-    RETURNING *;
- <waiting ...>
-s1: NOTICE:  upd: text key-a = text key-a: t
-s1: NOTICE:  upk: text val-a-s1-ups1 <> text mismatch: t
-s1: NOTICE:  trigger: name rep_b_u; when: BEFORE; lev: ROWs; op: UPDATE; old: (key-a,val-a-s1-ups1) new: (key-a,val-a-s1-ups1-ups1)
-s1: NOTICE:  trigger: name rep_a_u; when: AFTER; lev: ROWs; op: UPDATE; old: (key-a,val-a-s1-ups1) new: (key-a,val-a-s1-ups1-ups1)
-step s1_upd_a_data: 
-    UPDATE trigtest SET data = data || '-ups1'
-    WHERE
-        noisy_oper('upd', key, '=', 'key-a') AND
-        noisy_oper('upk', data, '<>', 'mismatch')
-    RETURNING *;
-
-key            data           
-
-key-a          val-a-s1-ups1-ups1
-step s1_c: COMMIT;
-s3: NOTICE:  upd: text key-a = text key-a: t
-s3: NOTICE:  upk: text val-a-s1-ups1-ups1 <> text mismatch: t
-s3: NOTICE:  trigger: name rep_b_u; when: BEFORE; lev: ROWs; op: UPDATE; old: (key-a,val-a-s1-ups1-ups1) new: (key-a,val-a-s1-ups1-ups1-ups3)
-s3: NOTICE:  trigger: name rep_a_u; when: AFTER; lev: ROWs; op: UPDATE; old: (key-a,val-a-s1-ups1-ups1) new: (key-a,val-a-s1-ups1-ups1-ups3)
-step s3_upd_a_data: <... completed>
-key            data           
-
-key-a          val-a-s1-ups1-ups1-ups3
-s3: NOTICE:  upd: text key-a = text key-a: t
-s3: NOTICE:  upk: text val-a-s1-ups1-ups1-ups3 <> text mismatch: t
-s3: NOTICE:  trigger: name rep_b_d; when: BEFORE; lev: ROWs; op: DELETE; old: (key-a,val-a-s1-ups1-ups1-ups3) new: <NULL>
-s3: NOTICE:  trigger: name rep_a_d; when: AFTER; lev: ROWs; op: DELETE; old: (key-a,val-a-s1-ups1-ups1-ups3) new: <NULL>
-step s3_del_a: 
-    DELETE FROM trigtest
-    WHERE
-        noisy_oper('upd', key, '=', 'key-a') AND
-        noisy_oper('upk', data, '<>', 'mismatch')
-    RETURNING *
-
-key            data           
-
-key-a          val-a-s1-ups1-ups1-ups3
-step s3_r: ROLLBACK;
-s2: NOTICE:  upd: text key-a = text key-a: t
-s2: NOTICE:  upk: text val-a-s1-ups1-ups1 <> text mismatch: t
-s2: NOTICE:  trigger: name rep_b_u; when: BEFORE; lev: ROWs; op: UPDATE; old: (key-a,val-a-s1-ups1-ups1) new: (key-a,val-a-s1-ups1-ups1-upserts2)
-s2: NOTICE:  trigger: name rep_a_u; when: AFTER; lev: ROWs; op: UPDATE; old: (key-a,val-a-s1-ups1-ups1) new: (key-a,val-a-s1-ups1-ups1-upserts2)
-step s2_upsert_a_data: <... completed>
-key            data           
-
-key-a          val-a-s1-ups1-ups1-upserts2
-step s2_c: COMMIT;
-step s0_rep: SELECT * FROM trigtest ORDER BY key, data
-key            data           
-
-key-a          val-a-s1-ups1-ups1-upserts2
-
 starting permutation: s1_trig_rep_b_i s1_trig_rep_b_d s1_trig_rep_b_u s1_trig_rep_a_i s1_trig_rep_a_d s1_trig_rep_a_u s1_ins_b s1_b_rc s2_b_rc s1_ins_a s1_upd_b_data s2_upd_b_data s1_del_b s1_upd_a_tob s1_c s2_c s0_rep
 step s1_trig_rep_b_i: CREATE TRIGGER rep_b_i BEFORE INSERT ON trigtest FOR EACH ROW EXECUTE PROCEDURE trig_report();
 step s1_trig_rep_b_d: CREATE TRIGGER rep_b_d BEFORE DELETE ON trigtest FOR EACH ROW EXECUTE PROCEDURE trig_report();
@@ -2585,3 +2368,5 @@ key            data
 
 key-a          val-a-s1-ups2  
 key-b          val-b-s1       
+unused step name: s3_del_a
+unused step name: s3_r
diff --git a/src/test/isolation/specs/eval-plan-qual-trigger.spec b/src/test/isolation/specs/eval-plan-qual-trigger.spec
index 400acafac64e..142a22a4be72 100644
--- a/src/test/isolation/specs/eval-plan-qual-trigger.spec
+++ b/src/test/isolation/specs/eval-plan-qual-trigger.spec
@@ -368,16 +368,17 @@ permutation "s1_trig_rep_b_u" "s1_trig_rep_a_u"
     "s1_ins_a" "s1_ins_b" "s1_b_rc" "s2_b_rc" "s3_b_rc"
     "s1_upd_a_data" "s2_upd_a_data" "s3_upd_a_data" "s1_c" "s2_r" "s3_c"
     "s0_rep"
-# s1 updates, s3 updates, s2 upserts, s1 updates, s1 commits, s3 EPQ, s3 deletes, s3 commits, s2 inserts without EPQ recheck
-permutation "s1_trig_rep_b_i" "s1_trig_rep_b_d" "s1_trig_rep_b_u" "s1_trig_rep_a_i" "s1_trig_rep_a_d" "s1_trig_rep_a_u"
-    "s1_ins_a" "s1_b_rc" "s2_b_rc" "s3_b_rc"
-    "s1_upd_a_data" "s3_upd_a_data" "s2_upsert_a_data" "s1_upd_a_data" "s1_c" "s3_del_a" "s3_c" "s2_c"
-    "s0_rep"
-# s1 updates, s3 updates, s2 upserts, s1 updates, s1 commits, s3 EPQ, s3 deletes, s3 rolls back, s2 EPQ
-permutation "s1_trig_rep_b_i" "s1_trig_rep_b_d" "s1_trig_rep_b_u" "s1_trig_rep_a_i" "s1_trig_rep_a_d" "s1_trig_rep_a_u"
-    "s1_ins_a" "s1_b_rc" "s2_b_rc" "s3_b_rc"
-    "s1_upd_a_data" "s3_upd_a_data" "s2_upsert_a_data" "s1_upd_a_data" "s1_c" "s3_del_a" "s3_r" "s2_c"
-    "s0_rep"
+## XXX: Disable test, there is some potential for instability here that's not yet fully understood
+## s1 updates, s3 updates, s2 upserts, s1 updates, s1 commits, s3 EPQ, s3 deletes, s3 commits, s2 inserts without EPQ recheck
+#permutation "s1_trig_rep_b_i" "s1_trig_rep_b_d" "s1_trig_rep_b_u" "s1_trig_rep_a_i" "s1_trig_rep_a_d" "s1_trig_rep_a_u"
+#    "s1_ins_a" "s1_b_rc" "s2_b_rc" "s3_b_rc"
+#    "s1_upd_a_data" "s3_upd_a_data" "s2_upsert_a_data" "s1_upd_a_data" "s1_c" "s3_del_a" "s3_c" "s2_c"
+#    "s0_rep"
+## s1 updates, s3 updates, s2 upserts, s1 updates, s1 commits, s3 EPQ, s3 deletes, s3 rolls back, s2 EPQ
+#permutation "s1_trig_rep_b_i" "s1_trig_rep_b_d" "s1_trig_rep_b_u" "s1_trig_rep_a_i" "s1_trig_rep_a_d" "s1_trig_rep_a_u"
+#    "s1_ins_a" "s1_b_rc" "s2_b_rc" "s3_b_rc"
+#    "s1_upd_a_data" "s3_upd_a_data" "s2_upsert_a_data" "s1_upd_a_data" "s1_c" "s3_del_a" "s3_r" "s2_c"
+#    "s0_rep"
 
 ### Document that EPQ doesn't "leap" onto a tuple that would match after blocking
 # s1 inserts a, s1 updates b, s2 updates b, s1 deletes b, s1 updates a to b, s1 commits, s2 EPQ finds tuple deleted
