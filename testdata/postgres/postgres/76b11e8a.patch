From 76b11e8a43eca4612dfccfe7f3ebd293fb8a46ec Mon Sep 17 00:00:00 2001
From: Heikki Linnakangas <heikki.linnakangas@iki.fi>
Date: Fri, 9 Jun 2017 13:05:41 +0300
Subject: [PATCH] Give a better error message on invalid hostaddr option.

If you accidentally pass a host name in the hostaddr option, e.g.
hostaddr=localhost, you get an error like:

psql: could not translate host name "localhost" to address: Name or service not known

That's a bit confusing, because it implies that we tried to look up
"localhost" in DNS, but it failed. To make it more clear that we tried to
parse "localhost" as a numeric network address, change the message to:

psql: could not parse network address "localhost": Name or service not known

Discussion: https://www.postgresql.org/message-id/10badbc6-4d5a-a769-623a-f7ada43e14dd@iki.fi
---
 src/interfaces/libpq/fe-connect.c | 41 ++++++++++++++++++++-----------
 1 file changed, 26 insertions(+), 15 deletions(-)

diff --git a/src/interfaces/libpq/fe-connect.c b/src/interfaces/libpq/fe-connect.c
index 77b170af94df..c1dfa5eb9798 100644
--- a/src/interfaces/libpq/fe-connect.c
+++ b/src/interfaces/libpq/fe-connect.c
@@ -1642,7 +1642,6 @@ connectDBStart(PGconn *conn)
 	for (i = 0; i < conn->nconnhost; ++i)
 	{
 		pg_conn_host *ch = &conn->connhost[i];
-		char	   *node = ch->host;
 		struct addrinfo hint;
 		int			thisport;
 
@@ -1668,17 +1667,28 @@ connectDBStart(PGconn *conn)
 		}
 		snprintf(portstr, sizeof(portstr), "%d", thisport);
 
-		/* Set up for name resolution. */
+		/* Use pg_getaddrinfo_all() to resolve the address */
 		switch (ch->type)
 		{
 			case CHT_HOST_NAME:
+				ret = pg_getaddrinfo_all(ch->host, portstr, &hint, &ch->addrlist);
+				if (ret || !ch->addrlist)
+					appendPQExpBuffer(&conn->errorMessage,
+									  libpq_gettext("could not translate host name \"%s\" to address: %s\n"),
+									  ch->host, gai_strerror(ret));
 				break;
+
 			case CHT_HOST_ADDRESS:
 				hint.ai_flags = AI_NUMERICHOST;
+				ret = pg_getaddrinfo_all(ch->host, portstr, &hint, &ch->addrlist);
+				if (ret || !ch->addrlist)
+					appendPQExpBuffer(&conn->errorMessage,
+									  libpq_gettext("could not parse network address \"%s\": %s\n"),
+									  ch->host, gai_strerror(ret));
 				break;
+
 			case CHT_UNIX_SOCKET:
 #ifdef HAVE_UNIX_SOCKETS
-				node = NULL;
 				hint.ai_family = AF_UNIX;
 				UNIXSOCK_PATH(portstr, thisport, ch->host);
 				if (strlen(portstr) >= UNIXSOCK_PATH_BUFLEN)
@@ -1690,24 +1700,25 @@ connectDBStart(PGconn *conn)
 					conn->options_valid = false;
 					goto connect_errReturn;
 				}
+
+				/*
+				 * NULL hostname tells pg_getaddrinfo_all to parse the service
+				 * name as a Unix-domain socket path.
+				 */
+				ret = pg_getaddrinfo_all(NULL, portstr, &hint, &ch->addrlist);
+				if (ret || !ch->addrlist)
+					appendPQExpBuffer(&conn->errorMessage,
+									  libpq_gettext("could not translate Unix-domain socket path \"%s\" to address: %s\n"),
+									  portstr, gai_strerror(ret));
+				break;
 #else
 				Assert(false);
+				conn->options_valid = false;
+				goto connect_errReturn;
 #endif
-				break;
 		}
-
-		/* Use pg_getaddrinfo_all() to resolve the address */
-		ret = pg_getaddrinfo_all(node, portstr, &hint, &ch->addrlist);
 		if (ret || !ch->addrlist)
 		{
-			if (node)
-				appendPQExpBuffer(&conn->errorMessage,
-								  libpq_gettext("could not translate host name \"%s\" to address: %s\n"),
-								  node, gai_strerror(ret));
-			else
-				appendPQExpBuffer(&conn->errorMessage,
-								  libpq_gettext("could not translate Unix-domain socket path \"%s\" to address: %s\n"),
-								  portstr, gai_strerror(ret));
 			if (ch->addrlist)
 			{
 				pg_freeaddrinfo_all(hint.ai_family, ch->addrlist);
