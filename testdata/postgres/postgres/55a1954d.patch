From 55a1954da16e041f895e5c3a6abff13c5e3a4a2f Mon Sep 17 00:00:00 2001
From: Tom Lane <tgl@sss.pgh.pa.us>
Date: Mon, 2 Dec 2019 19:08:10 -0500
Subject: [PATCH] Fix EXPLAIN's column alias output for mismatched child
 tables.

If an inheritance/partitioning parent table is assigned some column
alias names in the query, EXPLAIN mapped those aliases onto the
child tables' columns by physical position, resulting in bogus output
if a child table's columns aren't one-for-one with the parent's.

To fix, make expand_single_inheritance_child() generate a correctly
re-mapped column alias list, rather than just copying the parent
RTE's alias node.  (We have to fill the alias field, not just
adjust the eref field, because ruleutils.c will ignore eref in
favor of looking at the real column names.)

This means that child tables will now always have alias fields in
plan rtables, where before they might not have.  That results in
a rather substantial set of regression test output changes:
EXPLAIN will now always show child tables with aliases that match
the parent table (usually with "_N" appended for uniqueness).
But that seems like a net positive for understandability, since
the parent alias corresponds to something that actually appeared
in the original query, while the child table names didn't.
(Note that this does not change anything for cases where an explicit
table alias was written in the query for the parent table; it
just makes cases without such aliases behave similarly to that.)
Hence, while we could avoid these subsidiary changes if we made
inherit.c more complicated, we choose not to.

Discussion: https://postgr.es/m/12424.1575168015@sss.pgh.pa.us
---
 .../postgres_fdw/expected/postgres_fdw.out    |  296 +--
 src/backend/optimizer/util/inherit.c          |   74 +-
 src/test/regress/expected/aggregates.out      |   52 +-
 src/test/regress/expected/alter_table.out     |   18 +-
 src/test/regress/expected/inherit.out         |  486 ++---
 .../regress/expected/partition_aggregate.out  |  762 +++----
 src/test/regress/expected/partition_join.out  |  228 +--
 src/test/regress/expected/partition_prune.out | 1765 +++++++++--------
 src/test/regress/expected/rowsecurity.out     |  128 +-
 src/test/regress/expected/select_parallel.out |   56 +-
 src/test/regress/expected/tablesample.out     |   14 +-
 src/test/regress/expected/union.out           |   12 +-
 src/test/regress/expected/updatable_views.out |   96 +-
 src/test/regress/expected/update.out          |   32 +-
 src/test/regress/expected/with.out            |   30 +-
 src/test/regress/sql/partition_prune.sql      |    5 +
 16 files changed, 2072 insertions(+), 1982 deletions(-)

diff --git a/contrib/postgres_fdw/expected/postgres_fdw.out b/contrib/postgres_fdw/expected/postgres_fdw.out
index d2765456384b..97b24f3e38e5 100644
--- a/contrib/postgres_fdw/expected/postgres_fdw.out
+++ b/contrib/postgres_fdw/expected/postgres_fdw.out
@@ -6260,10 +6260,10 @@ UPDATE rw_view SET b = b + 5;
                                        QUERY PLAN                                       
 ----------------------------------------------------------------------------------------
  Update on public.parent_tbl
-   Foreign Update on public.foreign_tbl
+   Foreign Update on public.foreign_tbl parent_tbl_1
      Remote SQL: UPDATE public.child_tbl SET b = $2 WHERE ctid = $1 RETURNING a, b
-   ->  Foreign Scan on public.foreign_tbl
-         Output: foreign_tbl.a, (foreign_tbl.b + 5), foreign_tbl.ctid
+   ->  Foreign Scan on public.foreign_tbl parent_tbl_1
+         Output: parent_tbl_1.a, (parent_tbl_1.b + 5), parent_tbl_1.ctid
          Remote SQL: SELECT a, b, ctid FROM public.child_tbl WHERE ((a < b)) FOR UPDATE
 (6 rows)
 
@@ -6275,10 +6275,10 @@ UPDATE rw_view SET b = b + 15;
                                        QUERY PLAN                                       
 ----------------------------------------------------------------------------------------
  Update on public.parent_tbl
-   Foreign Update on public.foreign_tbl
+   Foreign Update on public.foreign_tbl parent_tbl_1
      Remote SQL: UPDATE public.child_tbl SET b = $2 WHERE ctid = $1 RETURNING a, b
-   ->  Foreign Scan on public.foreign_tbl
-         Output: foreign_tbl.a, (foreign_tbl.b + 15), foreign_tbl.ctid
+   ->  Foreign Scan on public.foreign_tbl parent_tbl_1
+         Output: parent_tbl_1.a, (parent_tbl_1.b + 15), parent_tbl_1.ctid
          Remote SQL: SELECT a, b, ctid FROM public.child_tbl WHERE ((a < b)) FOR UPDATE
 (6 rows)
 
@@ -7066,8 +7066,8 @@ select * from bar where f1 in (select f1 from foo) for update;
          ->  Append
                ->  Seq Scan on public.bar
                      Output: bar.f1, bar.f2, bar.ctid, bar.*, bar.tableoid
-               ->  Foreign Scan on public.bar2
-                     Output: bar2.f1, bar2.f2, bar2.ctid, bar2.*, bar2.tableoid
+               ->  Foreign Scan on public.bar2 bar_1
+                     Output: bar_1.f1, bar_1.f2, bar_1.ctid, bar_1.*, bar_1.tableoid
                      Remote SQL: SELECT f1, f2, f3, ctid FROM public.loct2 FOR UPDATE
          ->  Hash
                Output: foo.ctid, foo.f1, foo.*, foo.tableoid
@@ -7077,8 +7077,8 @@ select * from bar where f1 in (select f1 from foo) for update;
                      ->  Append
                            ->  Seq Scan on public.foo
                                  Output: foo.ctid, foo.f1, foo.*, foo.tableoid
-                           ->  Foreign Scan on public.foo2
-                                 Output: foo2.ctid, foo2.f1, foo2.*, foo2.tableoid
+                           ->  Foreign Scan on public.foo2 foo_1
+                                 Output: foo_1.ctid, foo_1.f1, foo_1.*, foo_1.tableoid
                                  Remote SQL: SELECT f1, f2, f3, ctid FROM public.loct1
 (23 rows)
 
@@ -7104,8 +7104,8 @@ select * from bar where f1 in (select f1 from foo) for share;
          ->  Append
                ->  Seq Scan on public.bar
                      Output: bar.f1, bar.f2, bar.ctid, bar.*, bar.tableoid
-               ->  Foreign Scan on public.bar2
-                     Output: bar2.f1, bar2.f2, bar2.ctid, bar2.*, bar2.tableoid
+               ->  Foreign Scan on public.bar2 bar_1
+                     Output: bar_1.f1, bar_1.f2, bar_1.ctid, bar_1.*, bar_1.tableoid
                      Remote SQL: SELECT f1, f2, f3, ctid FROM public.loct2 FOR SHARE
          ->  Hash
                Output: foo.ctid, foo.f1, foo.*, foo.tableoid
@@ -7115,8 +7115,8 @@ select * from bar where f1 in (select f1 from foo) for share;
                      ->  Append
                            ->  Seq Scan on public.foo
                                  Output: foo.ctid, foo.f1, foo.*, foo.tableoid
-                           ->  Foreign Scan on public.foo2
-                                 Output: foo2.ctid, foo2.f1, foo2.*, foo2.tableoid
+                           ->  Foreign Scan on public.foo2 foo_1
+                                 Output: foo_1.ctid, foo_1.f1, foo_1.*, foo_1.tableoid
                                  Remote SQL: SELECT f1, f2, f3, ctid FROM public.loct1
 (23 rows)
 
@@ -7132,11 +7132,11 @@ select * from bar where f1 in (select f1 from foo) for share;
 -- Check UPDATE with inherited target and an inherited source table
 explain (verbose, costs off)
 update bar set f2 = f2 + 100 where f1 in (select f1 from foo);
-                                         QUERY PLAN                                          
----------------------------------------------------------------------------------------------
+                                           QUERY PLAN                                            
+-------------------------------------------------------------------------------------------------
  Update on public.bar
    Update on public.bar
-   Foreign Update on public.bar2
+   Foreign Update on public.bar2 bar_1
      Remote SQL: UPDATE public.loct2 SET f2 = $2 WHERE ctid = $1
    ->  Hash Join
          Output: bar.f1, (bar.f2 + 100), bar.ctid, foo.ctid, foo.*, foo.tableoid
@@ -7152,15 +7152,15 @@ update bar set f2 = f2 + 100 where f1 in (select f1 from foo);
                      ->  Append
                            ->  Seq Scan on public.foo
                                  Output: foo.ctid, foo.f1, foo.*, foo.tableoid
-                           ->  Foreign Scan on public.foo2
-                                 Output: foo2.ctid, foo2.f1, foo2.*, foo2.tableoid
+                           ->  Foreign Scan on public.foo2 foo_1
+                                 Output: foo_1.ctid, foo_1.f1, foo_1.*, foo_1.tableoid
                                  Remote SQL: SELECT f1, f2, f3, ctid FROM public.loct1
    ->  Hash Join
-         Output: bar2.f1, (bar2.f2 + 100), bar2.f3, bar2.ctid, foo.ctid, foo.*, foo.tableoid
+         Output: bar_1.f1, (bar_1.f2 + 100), bar_1.f3, bar_1.ctid, foo.ctid, foo.*, foo.tableoid
          Inner Unique: true
-         Hash Cond: (bar2.f1 = foo.f1)
-         ->  Foreign Scan on public.bar2
-               Output: bar2.f1, bar2.f2, bar2.f3, bar2.ctid
+         Hash Cond: (bar_1.f1 = foo.f1)
+         ->  Foreign Scan on public.bar2 bar_1
+               Output: bar_1.f1, bar_1.f2, bar_1.f3, bar_1.ctid
                Remote SQL: SELECT f1, f2, f3, ctid FROM public.loct2 FOR UPDATE
          ->  Hash
                Output: foo.ctid, foo.f1, foo.*, foo.tableoid
@@ -7170,8 +7170,8 @@ update bar set f2 = f2 + 100 where f1 in (select f1 from foo);
                      ->  Append
                            ->  Seq Scan on public.foo
                                  Output: foo.ctid, foo.f1, foo.*, foo.tableoid
-                           ->  Foreign Scan on public.foo2
-                                 Output: foo2.ctid, foo2.f1, foo2.*, foo2.tableoid
+                           ->  Foreign Scan on public.foo2 foo_1
+                                 Output: foo_1.ctid, foo_1.f1, foo_1.*, foo_1.tableoid
                                  Remote SQL: SELECT f1, f2, f3, ctid FROM public.loct1
 (39 rows)
 
@@ -7197,7 +7197,7 @@ where bar.f1 = ss.f1;
 --------------------------------------------------------------------------------------
  Update on public.bar
    Update on public.bar
-   Foreign Update on public.bar2
+   Foreign Update on public.bar2 bar_1
      Remote SQL: UPDATE public.loct2 SET f2 = $2 WHERE ctid = $1
    ->  Hash Join
          Output: bar.f1, (bar.f2 + 100), bar.ctid, (ROW(foo.f1))
@@ -7205,26 +7205,26 @@ where bar.f1 = ss.f1;
          ->  Append
                ->  Seq Scan on public.foo
                      Output: ROW(foo.f1), foo.f1
-               ->  Foreign Scan on public.foo2
-                     Output: ROW(foo2.f1), foo2.f1
+               ->  Foreign Scan on public.foo2 foo_1
+                     Output: ROW(foo_1.f1), foo_1.f1
                      Remote SQL: SELECT f1 FROM public.loct1
-               ->  Seq Scan on public.foo foo_1
-                     Output: ROW((foo_1.f1 + 3)), (foo_1.f1 + 3)
-               ->  Foreign Scan on public.foo2 foo2_1
-                     Output: ROW((foo2_1.f1 + 3)), (foo2_1.f1 + 3)
+               ->  Seq Scan on public.foo foo_2
+                     Output: ROW((foo_2.f1 + 3)), (foo_2.f1 + 3)
+               ->  Foreign Scan on public.foo2 foo_3
+                     Output: ROW((foo_3.f1 + 3)), (foo_3.f1 + 3)
                      Remote SQL: SELECT f1 FROM public.loct1
          ->  Hash
                Output: bar.f1, bar.f2, bar.ctid
                ->  Seq Scan on public.bar
                      Output: bar.f1, bar.f2, bar.ctid
    ->  Merge Join
-         Output: bar2.f1, (bar2.f2 + 100), bar2.f3, bar2.ctid, (ROW(foo.f1))
-         Merge Cond: (bar2.f1 = foo.f1)
+         Output: bar_1.f1, (bar_1.f2 + 100), bar_1.f3, bar_1.ctid, (ROW(foo.f1))
+         Merge Cond: (bar_1.f1 = foo.f1)
          ->  Sort
-               Output: bar2.f1, bar2.f2, bar2.f3, bar2.ctid
-               Sort Key: bar2.f1
-               ->  Foreign Scan on public.bar2
-                     Output: bar2.f1, bar2.f2, bar2.f3, bar2.ctid
+               Output: bar_1.f1, bar_1.f2, bar_1.f3, bar_1.ctid
+               Sort Key: bar_1.f1
+               ->  Foreign Scan on public.bar2 bar_1
+                     Output: bar_1.f1, bar_1.f2, bar_1.f3, bar_1.ctid
                      Remote SQL: SELECT f1, f2, f3, ctid FROM public.loct2 FOR UPDATE
          ->  Sort
                Output: (ROW(foo.f1)), foo.f1
@@ -7232,13 +7232,13 @@ where bar.f1 = ss.f1;
                ->  Append
                      ->  Seq Scan on public.foo
                            Output: ROW(foo.f1), foo.f1
-                     ->  Foreign Scan on public.foo2
-                           Output: ROW(foo2.f1), foo2.f1
+                     ->  Foreign Scan on public.foo2 foo_1
+                           Output: ROW(foo_1.f1), foo_1.f1
                            Remote SQL: SELECT f1 FROM public.loct1
-                     ->  Seq Scan on public.foo foo_1
-                           Output: ROW((foo_1.f1 + 3)), (foo_1.f1 + 3)
-                     ->  Foreign Scan on public.foo2 foo2_1
-                           Output: ROW((foo2_1.f1 + 3)), (foo2_1.f1 + 3)
+                     ->  Seq Scan on public.foo foo_2
+                           Output: ROW((foo_2.f1 + 3)), (foo_2.f1 + 3)
+                     ->  Foreign Scan on public.foo2 foo_3
+                           Output: ROW((foo_3.f1 + 3)), (foo_3.f1 + 3)
                            Remote SQL: SELECT f1 FROM public.loct1
 (45 rows)
 
@@ -7288,8 +7288,8 @@ explain (verbose, costs off)
                      Sort Key: foo.f1
                      ->  Index Scan using i_foo_f1 on public.foo
                            Output: foo.f1, foo.f2
-                     ->  Foreign Scan on public.foo2
-                           Output: foo2.f1, foo2.f2
+                     ->  Foreign Scan on public.foo2 foo_1
+                           Output: foo_1.f1, foo_1.f2
                            Remote SQL: SELECT f1, f2 FROM public.loct1 ORDER BY f1 ASC NULLS LAST
                ->  Index Only Scan using i_loct1_f1 on public.loct1
                      Output: loct1.f1
@@ -7328,8 +7328,8 @@ explain (verbose, costs off)
                      Sort Key: foo.f1
                      ->  Index Scan using i_foo_f1 on public.foo
                            Output: foo.f1, foo.f2
-                     ->  Foreign Scan on public.foo2
-                           Output: foo2.f1, foo2.f2
+                     ->  Foreign Scan on public.foo2 foo_1
+                           Output: foo_1.f1, foo_1.f2
                            Remote SQL: SELECT f1, f2 FROM public.loct1 ORDER BY f1 ASC NULLS LAST
                ->  Index Only Scan using i_loct1_f1 on public.loct1
                      Output: loct1.f1
@@ -7371,11 +7371,11 @@ delete from foo where f1 < 5 returning *;
  Delete on public.foo
    Output: foo.f1, foo.f2
    Delete on public.foo
-   Foreign Delete on public.foo2
+   Foreign Delete on public.foo2 foo_1
    ->  Index Scan using i_foo_f1 on public.foo
          Output: foo.ctid
          Index Cond: (foo.f1 < 5)
-   ->  Foreign Delete on public.foo2
+   ->  Foreign Delete on public.foo2 foo_1
          Remote SQL: DELETE FROM public.loct1 WHERE ((f1 < 5)) RETURNING f1, f2
 (9 rows)
 
@@ -7396,10 +7396,10 @@ update bar set f2 = f2 + 100 returning *;
  Update on public.bar
    Output: bar.f1, bar.f2
    Update on public.bar
-   Foreign Update on public.bar2
+   Foreign Update on public.bar2 bar_1
    ->  Seq Scan on public.bar
          Output: bar.f1, (bar.f2 + 100), bar.ctid
-   ->  Foreign Update on public.bar2
+   ->  Foreign Update on public.bar2 bar_1
          Remote SQL: UPDATE public.loct2 SET f2 = (f2 + 100) RETURNING f1, f2
 (8 rows)
 
@@ -7427,12 +7427,12 @@ update bar set f2 = f2 + 100;
 --------------------------------------------------------------------------------------------------------
  Update on public.bar
    Update on public.bar
-   Foreign Update on public.bar2
+   Foreign Update on public.bar2 bar_1
      Remote SQL: UPDATE public.loct2 SET f1 = $2, f2 = $3, f3 = $4 WHERE ctid = $1 RETURNING f1, f2, f3
    ->  Seq Scan on public.bar
          Output: bar.f1, (bar.f2 + 100), bar.ctid
-   ->  Foreign Scan on public.bar2
-         Output: bar2.f1, (bar2.f2 + 100), bar2.f3, bar2.ctid, bar2.*
+   ->  Foreign Scan on public.bar2 bar_1
+         Output: bar_1.f1, (bar_1.f2 + 100), bar_1.f3, bar_1.ctid, bar_1.*
          Remote SQL: SELECT f1, f2, f3, ctid FROM public.loct2 FOR UPDATE
 (9 rows)
 
@@ -7455,13 +7455,13 @@ delete from bar where f2 < 400;
 ---------------------------------------------------------------------------------------------
  Delete on public.bar
    Delete on public.bar
-   Foreign Delete on public.bar2
+   Foreign Delete on public.bar2 bar_1
      Remote SQL: DELETE FROM public.loct2 WHERE ctid = $1 RETURNING f1, f2, f3
    ->  Seq Scan on public.bar
          Output: bar.ctid
          Filter: (bar.f2 < 400)
-   ->  Foreign Scan on public.bar2
-         Output: bar2.ctid, bar2.*
+   ->  Foreign Scan on public.bar2 bar_1
+         Output: bar_1.ctid, bar_1.*
          Remote SQL: SELECT f1, f2, f3, ctid FROM public.loct2 WHERE ((f2 < 400)) FOR UPDATE
 (10 rows)
 
@@ -7499,7 +7499,7 @@ update parent set b = parent.b || remt2.b from remt2 where parent.a = remt2.a re
  Update on public.parent
    Output: parent.a, parent.b, remt2.a, remt2.b
    Update on public.parent
-   Foreign Update on public.remt1
+   Foreign Update on public.remt1 parent_1
    ->  Nested Loop
          Output: parent.a, (parent.b || remt2.b), parent.ctid, remt2.*, remt2.a, remt2.b
          Join Filter: (parent.a = remt2.a)
@@ -7526,7 +7526,7 @@ delete from parent using remt2 where parent.a = remt2.a returning parent;
  Delete on public.parent
    Output: parent.*
    Delete on public.parent
-   Foreign Delete on public.remt1
+   Foreign Delete on public.remt1 parent_1
    ->  Nested Loop
          Output: parent.ctid, remt2.*
          Join Filter: (parent.a = remt2.a)
@@ -7753,14 +7753,14 @@ update utrtest set a = 1 where a = 1 or a = 2 returning *;
                                           QUERY PLAN                                          
 ----------------------------------------------------------------------------------------------
  Update on public.utrtest
-   Output: remp.a, remp.b
-   Foreign Update on public.remp
-   Update on public.locp
-   ->  Foreign Update on public.remp
+   Output: utrtest_1.a, utrtest_1.b
+   Foreign Update on public.remp utrtest_1
+   Update on public.locp utrtest_2
+   ->  Foreign Update on public.remp utrtest_1
          Remote SQL: UPDATE public.loct SET a = 1 WHERE (((a = 1) OR (a = 2))) RETURNING a, b
-   ->  Seq Scan on public.locp
-         Output: 1, locp.b, locp.ctid
-         Filter: ((locp.a = 1) OR (locp.a = 2))
+   ->  Seq Scan on public.locp utrtest_2
+         Output: 1, utrtest_2.b, utrtest_2.ctid
+         Filter: ((utrtest_2.a = 1) OR (utrtest_2.a = 2))
 (9 rows)
 
 -- The new values are concatenated with ' triggered !'
@@ -7775,14 +7775,14 @@ insert into utrtest values (2, 'qux');
 -- Check case where the foreign partition isn't a subplan target rel
 explain (verbose, costs off)
 update utrtest set a = 1 where a = 2 returning *;
-              QUERY PLAN              
---------------------------------------
+                   QUERY PLAN                   
+------------------------------------------------
  Update on public.utrtest
-   Output: locp.a, locp.b
-   Update on public.locp
-   ->  Seq Scan on public.locp
-         Output: 1, locp.b, locp.ctid
-         Filter: (locp.a = 2)
+   Output: utrtest_1.a, utrtest_1.b
+   Update on public.locp utrtest_1
+   ->  Seq Scan on public.locp utrtest_1
+         Output: 1, utrtest_1.b, utrtest_1.ctid
+         Filter: (utrtest_1.a = 2)
 (6 rows)
 
 -- The new values are concatenated with ' triggered !'
@@ -7805,13 +7805,13 @@ update utrtest set a = 1 returning *;
                            QUERY PLAN                            
 -----------------------------------------------------------------
  Update on public.utrtest
-   Output: remp.a, remp.b
-   Foreign Update on public.remp
-   Update on public.locp
-   ->  Foreign Update on public.remp
+   Output: utrtest_1.a, utrtest_1.b
+   Foreign Update on public.remp utrtest_1
+   Update on public.locp utrtest_2
+   ->  Foreign Update on public.remp utrtest_1
          Remote SQL: UPDATE public.loct SET a = 1 RETURNING a, b
-   ->  Seq Scan on public.locp
-         Output: 1, locp.b, locp.ctid
+   ->  Seq Scan on public.locp utrtest_2
+         Output: 1, utrtest_2.b, utrtest_2.ctid
 (8 rows)
 
 update utrtest set a = 1 returning *;
@@ -7827,28 +7827,28 @@ insert into utrtest values (2, 'qux');
 -- with a non-direct modification plan
 explain (verbose, costs off)
 update utrtest set a = 1 from (values (1), (2)) s(x) where a = s.x returning *;
-                                  QUERY PLAN                                  
-------------------------------------------------------------------------------
+                                    QUERY PLAN                                    
+----------------------------------------------------------------------------------
  Update on public.utrtest
-   Output: remp.a, remp.b, "*VALUES*".column1
-   Foreign Update on public.remp
+   Output: utrtest_1.a, utrtest_1.b, "*VALUES*".column1
+   Foreign Update on public.remp utrtest_1
      Remote SQL: UPDATE public.loct SET a = $2 WHERE ctid = $1 RETURNING a, b
-   Update on public.locp
+   Update on public.locp utrtest_2
    ->  Hash Join
-         Output: 1, remp.b, remp.ctid, "*VALUES*".*, "*VALUES*".column1
-         Hash Cond: (remp.a = "*VALUES*".column1)
-         ->  Foreign Scan on public.remp
-               Output: remp.b, remp.ctid, remp.a
+         Output: 1, utrtest_1.b, utrtest_1.ctid, "*VALUES*".*, "*VALUES*".column1
+         Hash Cond: (utrtest_1.a = "*VALUES*".column1)
+         ->  Foreign Scan on public.remp utrtest_1
+               Output: utrtest_1.b, utrtest_1.ctid, utrtest_1.a
                Remote SQL: SELECT a, b, ctid FROM public.loct FOR UPDATE
          ->  Hash
                Output: "*VALUES*".*, "*VALUES*".column1
                ->  Values Scan on "*VALUES*"
                      Output: "*VALUES*".*, "*VALUES*".column1
    ->  Hash Join
-         Output: 1, locp.b, locp.ctid, "*VALUES*".*, "*VALUES*".column1
-         Hash Cond: (locp.a = "*VALUES*".column1)
-         ->  Seq Scan on public.locp
-               Output: locp.b, locp.ctid, locp.a
+         Output: 1, utrtest_2.b, utrtest_2.ctid, "*VALUES*".*, "*VALUES*".column1
+         Hash Cond: (utrtest_2.a = "*VALUES*".column1)
+         ->  Seq Scan on public.locp utrtest_2
+               Output: utrtest_2.b, utrtest_2.ctid, utrtest_2.a
          ->  Hash
                Output: "*VALUES*".*, "*VALUES*".column1
                ->  Values Scan on "*VALUES*"
@@ -7880,12 +7880,12 @@ update utrtest set a = 3 returning *;
                            QUERY PLAN                            
 -----------------------------------------------------------------
  Update on public.utrtest
-   Output: locp.a, locp.b
-   Update on public.locp
-   Foreign Update on public.remp
-   ->  Seq Scan on public.locp
-         Output: 3, locp.b, locp.ctid
-   ->  Foreign Update on public.remp
+   Output: utrtest_1.a, utrtest_1.b
+   Update on public.locp utrtest_1
+   Foreign Update on public.remp utrtest_2
+   ->  Seq Scan on public.locp utrtest_1
+         Output: 3, utrtest_1.b, utrtest_1.ctid
+   ->  Foreign Update on public.remp utrtest_2
          Remote SQL: UPDATE public.loct SET a = 3 RETURNING a, b
 (8 rows)
 
@@ -7894,27 +7894,27 @@ ERROR:  cannot route tuples into foreign table to be updated "remp"
 -- with a non-direct modification plan
 explain (verbose, costs off)
 update utrtest set a = 3 from (values (2), (3)) s(x) where a = s.x returning *;
-                                  QUERY PLAN                                  
-------------------------------------------------------------------------------
+                                    QUERY PLAN                                    
+----------------------------------------------------------------------------------
  Update on public.utrtest
-   Output: locp.a, locp.b, "*VALUES*".column1
-   Update on public.locp
-   Foreign Update on public.remp
+   Output: utrtest_1.a, utrtest_1.b, "*VALUES*".column1
+   Update on public.locp utrtest_1
+   Foreign Update on public.remp utrtest_2
      Remote SQL: UPDATE public.loct SET a = $2 WHERE ctid = $1 RETURNING a, b
    ->  Hash Join
-         Output: 3, locp.b, locp.ctid, "*VALUES*".*, "*VALUES*".column1
-         Hash Cond: (locp.a = "*VALUES*".column1)
-         ->  Seq Scan on public.locp
-               Output: locp.b, locp.ctid, locp.a
+         Output: 3, utrtest_1.b, utrtest_1.ctid, "*VALUES*".*, "*VALUES*".column1
+         Hash Cond: (utrtest_1.a = "*VALUES*".column1)
+         ->  Seq Scan on public.locp utrtest_1
+               Output: utrtest_1.b, utrtest_1.ctid, utrtest_1.a
          ->  Hash
                Output: "*VALUES*".*, "*VALUES*".column1
                ->  Values Scan on "*VALUES*"
                      Output: "*VALUES*".*, "*VALUES*".column1
    ->  Hash Join
-         Output: 3, remp.b, remp.ctid, "*VALUES*".*, "*VALUES*".column1
-         Hash Cond: (remp.a = "*VALUES*".column1)
-         ->  Foreign Scan on public.remp
-               Output: remp.b, remp.ctid, remp.a
+         Output: 3, utrtest_2.b, utrtest_2.ctid, "*VALUES*".*, "*VALUES*".column1
+         Hash Cond: (utrtest_2.a = "*VALUES*".column1)
+         ->  Foreign Scan on public.remp utrtest_2
+               Output: utrtest_2.b, utrtest_2.ctid, utrtest_2.a
                Remote SQL: SELECT a, b, ctid FROM public.loct FOR UPDATE
          ->  Hash
                Output: "*VALUES*".*, "*VALUES*".column1
@@ -8506,8 +8506,8 @@ SELECT t1.a,t2.b,t2.c FROM fprt1 t1 LEFT JOIN (SELECT * FROM fprt2 WHERE a < 10)
                                                                                                                      QUERY PLAN                                                                                                                     
 ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  Foreign Scan
-   Output: t1.a, ftprt2_p1.b, ftprt2_p1.c
-   Relations: (public.ftprt1_p1 t1) LEFT JOIN (public.ftprt2_p1)
+   Output: t1.a, fprt2.b, fprt2.c
+   Relations: (public.ftprt1_p1 t1) LEFT JOIN (public.ftprt2_p1 fprt2)
    Remote SQL: SELECT r5.a, r6.b, r6.c FROM (public.fprt1_p1 r5 LEFT JOIN public.fprt2_p1 r6 ON (((r5.a = r6.b)) AND ((r5.b = r6.a)) AND ((r6.a < 10)))) WHERE ((r5.a < 10)) ORDER BY r5.a ASC NULLS LAST, r6.b ASC NULLS LAST, r6.c ASC NULLS LAST
 (4 rows)
 
@@ -8584,21 +8584,21 @@ SELECT t1.a,t1.b FROM fprt1 t1, LATERAL (SELECT t2.a, t2.b FROM fprt2 t2 WHERE t
 -- with PHVs, partitionwise join selected but no join pushdown
 EXPLAIN (COSTS OFF)
 SELECT t1.a, t1.phv, t2.b, t2.phv FROM (SELECT 't1_phv' phv, * FROM fprt1 WHERE a % 25 = 0) t1 FULL JOIN (SELECT 't2_phv' phv, * FROM fprt2 WHERE b % 25 = 0) t2 ON (t1.a = t2.b) ORDER BY t1.a, t2.b;
-                      QUERY PLAN                      
-------------------------------------------------------
+                        QUERY PLAN                         
+-----------------------------------------------------------
  Sort
-   Sort Key: ftprt1_p1.a, ftprt2_p1.b
+   Sort Key: fprt1.a, fprt2.b
    ->  Append
          ->  Hash Full Join
-               Hash Cond: (ftprt1_p1.a = ftprt2_p1.b)
-               ->  Foreign Scan on ftprt1_p1
+               Hash Cond: (fprt1.a = fprt2.b)
+               ->  Foreign Scan on ftprt1_p1 fprt1
                ->  Hash
-                     ->  Foreign Scan on ftprt2_p1
+                     ->  Foreign Scan on ftprt2_p1 fprt2
          ->  Hash Full Join
-               Hash Cond: (ftprt1_p2.a = ftprt2_p2.b)
-               ->  Foreign Scan on ftprt1_p2
+               Hash Cond: (fprt1_1.a = fprt2_1.b)
+               ->  Foreign Scan on ftprt1_p2 fprt1_1
                ->  Hash
-                     ->  Foreign Scan on ftprt2_p2
+                     ->  Foreign Scan on ftprt2_p2 fprt2_1
 (13 rows)
 
 SELECT t1.a, t1.phv, t2.b, t2.phv FROM (SELECT 't1_phv' phv, * FROM fprt1 WHERE a % 25 = 0) t1 FULL JOIN (SELECT 't2_phv' phv, * FROM fprt2 WHERE b % 25 = 0) t2 ON (t1.a = t2.b) ORDER BY t1.a, t2.b;
@@ -8672,34 +8672,34 @@ ANALYZE fpagg_tab_p3;
 SET enable_partitionwise_aggregate TO false;
 EXPLAIN (COSTS OFF)
 SELECT a, sum(b), min(b), count(*) FROM pagg_tab GROUP BY a HAVING avg(b) < 22 ORDER BY 1;
-                      QUERY PLAN                       
--------------------------------------------------------
+                        QUERY PLAN                         
+-----------------------------------------------------------
  Sort
-   Sort Key: fpagg_tab_p1.a
+   Sort Key: pagg_tab.a
    ->  HashAggregate
-         Group Key: fpagg_tab_p1.a
-         Filter: (avg(fpagg_tab_p1.b) < '22'::numeric)
+         Group Key: pagg_tab.a
+         Filter: (avg(pagg_tab.b) < '22'::numeric)
          ->  Append
-               ->  Foreign Scan on fpagg_tab_p1
-               ->  Foreign Scan on fpagg_tab_p2
-               ->  Foreign Scan on fpagg_tab_p3
+               ->  Foreign Scan on fpagg_tab_p1 pagg_tab
+               ->  Foreign Scan on fpagg_tab_p2 pagg_tab_1
+               ->  Foreign Scan on fpagg_tab_p3 pagg_tab_2
 (9 rows)
 
 -- Plan with partitionwise aggregates is enabled
 SET enable_partitionwise_aggregate TO true;
 EXPLAIN (COSTS OFF)
 SELECT a, sum(b), min(b), count(*) FROM pagg_tab GROUP BY a HAVING avg(b) < 22 ORDER BY 1;
-                         QUERY PLAN                          
--------------------------------------------------------------
+                               QUERY PLAN                               
+------------------------------------------------------------------------
  Sort
-   Sort Key: fpagg_tab_p1.a
+   Sort Key: pagg_tab.a
    ->  Append
          ->  Foreign Scan
-               Relations: Aggregate on (public.fpagg_tab_p1)
+               Relations: Aggregate on (public.fpagg_tab_p1 pagg_tab)
          ->  Foreign Scan
-               Relations: Aggregate on (public.fpagg_tab_p2)
+               Relations: Aggregate on (public.fpagg_tab_p2 pagg_tab_1)
          ->  Foreign Scan
-               Relations: Aggregate on (public.fpagg_tab_p3)
+               Relations: Aggregate on (public.fpagg_tab_p3 pagg_tab_2)
 (9 rows)
 
 SELECT a, sum(b), min(b), count(*) FROM pagg_tab GROUP BY a HAVING avg(b) < 22 ORDER BY 1;
@@ -8760,23 +8760,23 @@ SELECT a, count(t1) FROM pagg_tab t1 GROUP BY a HAVING avg(b) < 22 ORDER BY 1;
 -- When GROUP BY clause does not match with PARTITION KEY.
 EXPLAIN (COSTS OFF)
 SELECT b, avg(a), max(a), count(*) FROM pagg_tab GROUP BY b HAVING sum(a) < 700 ORDER BY 1;
-                      QUERY PLAN                      
-------------------------------------------------------
+                           QUERY PLAN                            
+-----------------------------------------------------------------
  Sort
-   Sort Key: fpagg_tab_p1.b
+   Sort Key: pagg_tab.b
    ->  Finalize HashAggregate
-         Group Key: fpagg_tab_p1.b
-         Filter: (sum(fpagg_tab_p1.a) < 700)
+         Group Key: pagg_tab.b
+         Filter: (sum(pagg_tab.a) < 700)
          ->  Append
                ->  Partial HashAggregate
-                     Group Key: fpagg_tab_p1.b
-                     ->  Foreign Scan on fpagg_tab_p1
+                     Group Key: pagg_tab.b
+                     ->  Foreign Scan on fpagg_tab_p1 pagg_tab
                ->  Partial HashAggregate
-                     Group Key: fpagg_tab_p2.b
-                     ->  Foreign Scan on fpagg_tab_p2
+                     Group Key: pagg_tab_1.b
+                     ->  Foreign Scan on fpagg_tab_p2 pagg_tab_1
                ->  Partial HashAggregate
-                     Group Key: fpagg_tab_p3.b
-                     ->  Foreign Scan on fpagg_tab_p3
+                     Group Key: pagg_tab_2.b
+                     ->  Foreign Scan on fpagg_tab_p3 pagg_tab_2
 (15 rows)
 
 -- Clean-up
diff --git a/src/backend/optimizer/util/inherit.c b/src/backend/optimizer/util/inherit.c
index 38bc61e68784..a38df47e47e7 100644
--- a/src/backend/optimizer/util/inherit.c
+++ b/src/backend/optimizer/util/inherit.c
@@ -421,10 +421,13 @@ expand_single_inheritance_child(PlannerInfo *root, RangeTblEntry *parentrte,
 	RangeTblEntry *childrte;
 	Index		childRTindex;
 	AppendRelInfo *appinfo;
+	TupleDesc	child_tupdesc;
+	List	   *parent_colnames;
+	List	   *child_colnames;
 
 	/*
 	 * Build an RTE for the child, and attach to query's rangetable list. We
-	 * copy most fields of the parent's RTE, but replace relation OID,
+	 * copy most scalar fields of the parent's RTE, but replace relation OID,
 	 * relkind, and inh for the child.  Also, set requiredPerms to zero since
 	 * all required permissions checks are done on the original RTE. Likewise,
 	 * set the child's securityQuals to empty, because we only want to apply
@@ -432,10 +435,14 @@ expand_single_inheritance_child(PlannerInfo *root, RangeTblEntry *parentrte,
 	 * individual children may have.  (This is an intentional choice to make
 	 * inherited RLS work like regular permissions checks.) The parent
 	 * securityQuals will be propagated to children along with other base
-	 * restriction clauses, so we don't need to do it here.
+	 * restriction clauses, so we don't need to do it here.  Other
+	 * infrastructure of the parent RTE has to be translated to match the
+	 * child table's column ordering, which we do below, so a "flat" copy is
+	 * sufficient to start with.
 	 */
-	childrte = copyObject(parentrte);
-	*childrte_p = childrte;
+	childrte = makeNode(RangeTblEntry);
+	memcpy(childrte, parentrte, sizeof(RangeTblEntry));
+	Assert(parentrte->rtekind == RTE_RELATION); /* else this is dubious */
 	childrte->relid = childOID;
 	childrte->relkind = childrel->rd_rel->relkind;
 	/* A partitioned child will need to be expanded further. */
@@ -448,8 +455,11 @@ expand_single_inheritance_child(PlannerInfo *root, RangeTblEntry *parentrte,
 		childrte->inh = false;
 	childrte->requiredPerms = 0;
 	childrte->securityQuals = NIL;
+
+	/* Link not-yet-fully-filled child RTE into data structures */
 	parse->rtable = lappend(parse->rtable, childrte);
 	childRTindex = list_length(parse->rtable);
+	*childrte_p = childrte;
 	*childRTindex_p = childRTindex;
 
 	/*
@@ -459,10 +469,57 @@ expand_single_inheritance_child(PlannerInfo *root, RangeTblEntry *parentrte,
 								   parentRTindex, childRTindex);
 	root->append_rel_list = lappend(root->append_rel_list, appinfo);
 
+	/* tablesample is probably null, but copy it */
+	childrte->tablesample = copyObject(parentrte->tablesample);
+
+	/*
+	 * Construct an alias clause for the child, which we can also use as eref.
+	 * This is important so that EXPLAIN will print the right column aliases
+	 * for child-table columns.  (Since ruleutils.c doesn't have any easy way
+	 * to reassociate parent and child columns, we must get the child column
+	 * aliases right to start with.  Note that setting childrte->alias forces
+	 * ruleutils.c to use these column names, which it otherwise would not.)
+	 */
+	child_tupdesc = RelationGetDescr(childrel);
+	parent_colnames = parentrte->eref->colnames;
+	child_colnames = NIL;
+	for (int cattno = 0; cattno < child_tupdesc->natts; cattno++)
+	{
+		Form_pg_attribute att = TupleDescAttr(child_tupdesc, cattno);
+		const char *attname;
+
+		if (att->attisdropped)
+		{
+			/* Always insert an empty string for a dropped column */
+			attname = "";
+		}
+		else if (appinfo->parent_colnos[cattno] > 0 &&
+				 appinfo->parent_colnos[cattno] <= list_length(parent_colnames))
+		{
+			/* Duplicate the query-assigned name for the parent column */
+			attname = strVal(list_nth(parent_colnames,
+									  appinfo->parent_colnos[cattno] - 1));
+		}
+		else
+		{
+			/* New column, just use its real name */
+			attname = NameStr(att->attname);
+		}
+		child_colnames = lappend(child_colnames, makeString(pstrdup(attname)));
+	}
+
+	/*
+	 * We just duplicate the parent's table alias name for each child.  If the
+	 * plan gets printed, ruleutils.c has to sort out unique table aliases to
+	 * use, which it can handle.
+	 */
+	childrte->alias = childrte->eref = makeAlias(parentrte->eref->aliasname,
+												 child_colnames);
+
 	/*
 	 * Translate the column permissions bitmaps to the child's attnums (we
 	 * have to build the translated_vars list before we can do this).  But if
-	 * this is the parent table, we can leave copyObject's result alone.
+	 * this is the parent table, we can just duplicate the parent's bitmaps.
 	 *
 	 * Note: we need to do this even though the executor won't run any
 	 * permissions checks on the child RTE.  The insertedCols/updatedCols
@@ -479,6 +536,13 @@ expand_single_inheritance_child(PlannerInfo *root, RangeTblEntry *parentrte,
 		childrte->extraUpdatedCols = translate_col_privs(parentrte->extraUpdatedCols,
 														 appinfo->translated_vars);
 	}
+	else
+	{
+		childrte->selectedCols = bms_copy(parentrte->selectedCols);
+		childrte->insertedCols = bms_copy(parentrte->insertedCols);
+		childrte->updatedCols = bms_copy(parentrte->updatedCols);
+		childrte->extraUpdatedCols = bms_copy(parentrte->extraUpdatedCols);
+	}
 
 	/*
 	 * Store the RTE and appinfo in the respective PlannerInfo arrays, which
diff --git a/src/test/regress/expected/aggregates.out b/src/test/regress/expected/aggregates.out
index be4ddf86a437..0b097f965207 100644
--- a/src/test/regress/expected/aggregates.out
+++ b/src/test/regress/expected/aggregates.out
@@ -998,8 +998,8 @@ insert into minmaxtest2 values(15), (16);
 insert into minmaxtest3 values(17), (18);
 explain (costs off)
   select min(f1), max(f1) from minmaxtest;
-                                          QUERY PLAN                                          
-----------------------------------------------------------------------------------------------
+                                         QUERY PLAN                                          
+---------------------------------------------------------------------------------------------
  Result
    InitPlan 1 (returns $0)
      ->  Limit
@@ -1007,22 +1007,22 @@ explain (costs off)
                  Sort Key: minmaxtest.f1
                  ->  Index Only Scan using minmaxtesti on minmaxtest
                        Index Cond: (f1 IS NOT NULL)
-                 ->  Index Only Scan using minmaxtest1i on minmaxtest1
+                 ->  Index Only Scan using minmaxtest1i on minmaxtest1 minmaxtest_1
                        Index Cond: (f1 IS NOT NULL)
-                 ->  Index Only Scan Backward using minmaxtest2i on minmaxtest2
+                 ->  Index Only Scan Backward using minmaxtest2i on minmaxtest2 minmaxtest_2
                        Index Cond: (f1 IS NOT NULL)
-                 ->  Index Only Scan using minmaxtest3i on minmaxtest3
+                 ->  Index Only Scan using minmaxtest3i on minmaxtest3 minmaxtest_3
    InitPlan 2 (returns $1)
      ->  Limit
            ->  Merge Append
-                 Sort Key: minmaxtest_1.f1 DESC
-                 ->  Index Only Scan Backward using minmaxtesti on minmaxtest minmaxtest_1
+                 Sort Key: minmaxtest_4.f1 DESC
+                 ->  Index Only Scan Backward using minmaxtesti on minmaxtest minmaxtest_4
                        Index Cond: (f1 IS NOT NULL)
-                 ->  Index Only Scan Backward using minmaxtest1i on minmaxtest1 minmaxtest1_1
+                 ->  Index Only Scan Backward using minmaxtest1i on minmaxtest1 minmaxtest_5
                        Index Cond: (f1 IS NOT NULL)
-                 ->  Index Only Scan using minmaxtest2i on minmaxtest2 minmaxtest2_1
+                 ->  Index Only Scan using minmaxtest2i on minmaxtest2 minmaxtest_6
                        Index Cond: (f1 IS NOT NULL)
-                 ->  Index Only Scan Backward using minmaxtest3i on minmaxtest3 minmaxtest3_1
+                 ->  Index Only Scan Backward using minmaxtest3i on minmaxtest3 minmaxtest_7
 (23 rows)
 
 select min(f1), max(f1) from minmaxtest;
@@ -1034,8 +1034,8 @@ select min(f1), max(f1) from minmaxtest;
 -- DISTINCT doesn't do anything useful here, but it shouldn't fail
 explain (costs off)
   select distinct min(f1), max(f1) from minmaxtest;
-                                          QUERY PLAN                                          
-----------------------------------------------------------------------------------------------
+                                         QUERY PLAN                                          
+---------------------------------------------------------------------------------------------
  Unique
    InitPlan 1 (returns $0)
      ->  Limit
@@ -1043,22 +1043,22 @@ explain (costs off)
                  Sort Key: minmaxtest.f1
                  ->  Index Only Scan using minmaxtesti on minmaxtest
                        Index Cond: (f1 IS NOT NULL)
-                 ->  Index Only Scan using minmaxtest1i on minmaxtest1
+                 ->  Index Only Scan using minmaxtest1i on minmaxtest1 minmaxtest_1
                        Index Cond: (f1 IS NOT NULL)
-                 ->  Index Only Scan Backward using minmaxtest2i on minmaxtest2
+                 ->  Index Only Scan Backward using minmaxtest2i on minmaxtest2 minmaxtest_2
                        Index Cond: (f1 IS NOT NULL)
-                 ->  Index Only Scan using minmaxtest3i on minmaxtest3
+                 ->  Index Only Scan using minmaxtest3i on minmaxtest3 minmaxtest_3
    InitPlan 2 (returns $1)
      ->  Limit
            ->  Merge Append
-                 Sort Key: minmaxtest_1.f1 DESC
-                 ->  Index Only Scan Backward using minmaxtesti on minmaxtest minmaxtest_1
+                 Sort Key: minmaxtest_4.f1 DESC
+                 ->  Index Only Scan Backward using minmaxtesti on minmaxtest minmaxtest_4
                        Index Cond: (f1 IS NOT NULL)
-                 ->  Index Only Scan Backward using minmaxtest1i on minmaxtest1 minmaxtest1_1
+                 ->  Index Only Scan Backward using minmaxtest1i on minmaxtest1 minmaxtest_5
                        Index Cond: (f1 IS NOT NULL)
-                 ->  Index Only Scan using minmaxtest2i on minmaxtest2 minmaxtest2_1
+                 ->  Index Only Scan using minmaxtest2i on minmaxtest2 minmaxtest_6
                        Index Cond: (f1 IS NOT NULL)
-                 ->  Index Only Scan Backward using minmaxtest3i on minmaxtest3 minmaxtest3_1
+                 ->  Index Only Scan Backward using minmaxtest3i on minmaxtest3 minmaxtest_7
    ->  Sort
          Sort Key: ($0), ($1)
          ->  Result
@@ -1156,7 +1156,7 @@ explain (costs off) select * from t1 group by a,b,c,d;
    Group Key: t1.a, t1.b, t1.c, t1.d
    ->  Append
          ->  Seq Scan on t1
-         ->  Seq Scan on t1c
+         ->  Seq Scan on t1c t1_1
 (5 rows)
 
 -- Okay to remove columns if we're only querying the parent.
@@ -1179,13 +1179,13 @@ create temp table p_t1_1 partition of p_t1 for values in(1);
 create temp table p_t1_2 partition of p_t1 for values in(2);
 -- Ensure we can remove non-PK columns for partitioned tables.
 explain (costs off) select * from p_t1 group by a,b,c,d;
-           QUERY PLAN            
----------------------------------
+              QUERY PLAN               
+---------------------------------------
  HashAggregate
-   Group Key: p_t1_1.a, p_t1_1.b
+   Group Key: p_t1.a, p_t1.b
    ->  Append
-         ->  Seq Scan on p_t1_1
-         ->  Seq Scan on p_t1_2
+         ->  Seq Scan on p_t1_1 p_t1
+         ->  Seq Scan on p_t1_2 p_t1_1
 (5 rows)
 
 drop table t1 cascade;
diff --git a/src/test/regress/expected/alter_table.out b/src/test/regress/expected/alter_table.out
index f65611a62c4f..e71d2f24dd0f 100644
--- a/src/test/regress/expected/alter_table.out
+++ b/src/test/regress/expected/alter_table.out
@@ -542,9 +542,9 @@ explain (costs off) select * from nv_parent where d between '2011-08-01' and '20
  Append
    ->  Seq Scan on nv_parent
          Filter: ((d >= '08-01-2011'::date) AND (d <= '08-31-2011'::date))
-   ->  Seq Scan on nv_child_2010
+   ->  Seq Scan on nv_child_2010 nv_parent_1
          Filter: ((d >= '08-01-2011'::date) AND (d <= '08-31-2011'::date))
-   ->  Seq Scan on nv_child_2011
+   ->  Seq Scan on nv_child_2011 nv_parent_2
          Filter: ((d >= '08-01-2011'::date) AND (d <= '08-31-2011'::date))
 (7 rows)
 
@@ -555,9 +555,9 @@ explain (costs off) select * from nv_parent where d between '2011-08-01'::date a
  Append
    ->  Seq Scan on nv_parent
          Filter: ((d >= '08-01-2011'::date) AND (d <= '08-31-2011'::date))
-   ->  Seq Scan on nv_child_2010
+   ->  Seq Scan on nv_child_2010 nv_parent_1
          Filter: ((d >= '08-01-2011'::date) AND (d <= '08-31-2011'::date))
-   ->  Seq Scan on nv_child_2011
+   ->  Seq Scan on nv_child_2011 nv_parent_2
          Filter: ((d >= '08-01-2011'::date) AND (d <= '08-31-2011'::date))
 (7 rows)
 
@@ -567,11 +567,11 @@ explain (costs off) select * from nv_parent where d between '2009-08-01'::date a
  Append
    ->  Seq Scan on nv_parent
          Filter: ((d >= '08-01-2009'::date) AND (d <= '08-31-2009'::date))
-   ->  Seq Scan on nv_child_2010
+   ->  Seq Scan on nv_child_2010 nv_parent_1
          Filter: ((d >= '08-01-2009'::date) AND (d <= '08-31-2009'::date))
-   ->  Seq Scan on nv_child_2011
+   ->  Seq Scan on nv_child_2011 nv_parent_2
          Filter: ((d >= '08-01-2009'::date) AND (d <= '08-31-2009'::date))
-   ->  Seq Scan on nv_child_2009
+   ->  Seq Scan on nv_child_2009 nv_parent_3
          Filter: ((d >= '08-01-2009'::date) AND (d <= '08-31-2009'::date))
 (9 rows)
 
@@ -583,9 +583,9 @@ explain (costs off) select * from nv_parent where d between '2009-08-01'::date a
  Append
    ->  Seq Scan on nv_parent
          Filter: ((d >= '08-01-2009'::date) AND (d <= '08-31-2009'::date))
-   ->  Seq Scan on nv_child_2010
+   ->  Seq Scan on nv_child_2010 nv_parent_1
          Filter: ((d >= '08-01-2009'::date) AND (d <= '08-31-2009'::date))
-   ->  Seq Scan on nv_child_2009
+   ->  Seq Scan on nv_child_2009 nv_parent_2
          Filter: ((d >= '08-01-2009'::date) AND (d <= '08-31-2009'::date))
 (7 rows)
 
diff --git a/src/test/regress/expected/inherit.out b/src/test/regress/expected/inherit.out
index e4dbbad75c13..680d47f5ac71 100644
--- a/src/test/regress/expected/inherit.out
+++ b/src/test/regress/expected/inherit.out
@@ -1332,17 +1332,17 @@ analyze patest1;
 analyze patest2;
 explain (costs off)
 select * from patest0 join (select f1 from int4_tbl limit 1) ss on id = f1;
-                    QUERY PLAN                    
---------------------------------------------------
+                         QUERY PLAN                         
+------------------------------------------------------------
  Nested Loop
    ->  Limit
          ->  Seq Scan on int4_tbl
    ->  Append
          ->  Index Scan using patest0i on patest0
                Index Cond: (id = int4_tbl.f1)
-         ->  Index Scan using patest1i on patest1
+         ->  Index Scan using patest1i on patest1 patest0_1
                Index Cond: (id = int4_tbl.f1)
-         ->  Index Scan using patest2i on patest2
+         ->  Index Scan using patest2i on patest2 patest0_2
                Index Cond: (id = int4_tbl.f1)
 (10 rows)
 
@@ -1357,17 +1357,17 @@ select * from patest0 join (select f1 from int4_tbl limit 1) ss on id = f1;
 drop index patest2i;
 explain (costs off)
 select * from patest0 join (select f1 from int4_tbl limit 1) ss on id = f1;
-                    QUERY PLAN                    
---------------------------------------------------
+                         QUERY PLAN                         
+------------------------------------------------------------
  Nested Loop
    ->  Limit
          ->  Seq Scan on int4_tbl
    ->  Append
          ->  Index Scan using patest0i on patest0
                Index Cond: (id = int4_tbl.f1)
-         ->  Index Scan using patest1i on patest1
+         ->  Index Scan using patest1i on patest1 patest0_1
                Index Cond: (id = int4_tbl.f1)
-         ->  Seq Scan on patest2
+         ->  Seq Scan on patest2 patest0_2
                Filter: (int4_tbl.f1 = id)
 (10 rows)
 
@@ -1415,12 +1415,12 @@ explain (verbose, costs off) select * from matest0 order by 1-id;
          ->  Append
                ->  Seq Scan on public.matest0
                      Output: matest0.id, matest0.name
-               ->  Seq Scan on public.matest1
-                     Output: matest1.id, matest1.name
-               ->  Seq Scan on public.matest2
-                     Output: matest2.id, matest2.name
-               ->  Seq Scan on public.matest3
-                     Output: matest3.id, matest3.name
+               ->  Seq Scan on public.matest1 matest0_1
+                     Output: matest0_1.id, matest0_1.name
+               ->  Seq Scan on public.matest2 matest0_2
+                     Output: matest0_2.id, matest0_2.name
+               ->  Seq Scan on public.matest3 matest0_3
+                     Output: matest0_3.id, matest0_3.name
 (14 rows)
 
 select * from matest0 order by 1-id;
@@ -1435,19 +1435,19 @@ select * from matest0 order by 1-id;
 (6 rows)
 
 explain (verbose, costs off) select min(1-id) from matest0;
-               QUERY PLAN               
-----------------------------------------
+                    QUERY PLAN                    
+--------------------------------------------------
  Aggregate
    Output: min((1 - matest0.id))
    ->  Append
          ->  Seq Scan on public.matest0
                Output: matest0.id
-         ->  Seq Scan on public.matest1
-               Output: matest1.id
-         ->  Seq Scan on public.matest2
-               Output: matest2.id
-         ->  Seq Scan on public.matest3
-               Output: matest3.id
+         ->  Seq Scan on public.matest1 matest0_1
+               Output: matest0_1.id
+         ->  Seq Scan on public.matest2 matest0_2
+               Output: matest0_2.id
+         ->  Seq Scan on public.matest3 matest0_3
+               Output: matest0_3.id
 (11 rows)
 
 select min(1-id) from matest0;
@@ -1460,21 +1460,21 @@ reset enable_indexscan;
 set enable_seqscan = off;  -- plan with fewest seqscans should be merge
 set enable_parallel_append = off; -- Don't let parallel-append interfere
 explain (verbose, costs off) select * from matest0 order by 1-id;
-                            QUERY PLAN                            
-------------------------------------------------------------------
+                               QUERY PLAN                               
+------------------------------------------------------------------------
  Merge Append
    Sort Key: ((1 - matest0.id))
    ->  Index Scan using matest0i on public.matest0
          Output: matest0.id, matest0.name, (1 - matest0.id)
-   ->  Index Scan using matest1i on public.matest1
-         Output: matest1.id, matest1.name, (1 - matest1.id)
+   ->  Index Scan using matest1i on public.matest1 matest0_1
+         Output: matest0_1.id, matest0_1.name, (1 - matest0_1.id)
    ->  Sort
-         Output: matest2.id, matest2.name, ((1 - matest2.id))
-         Sort Key: ((1 - matest2.id))
-         ->  Seq Scan on public.matest2
-               Output: matest2.id, matest2.name, (1 - matest2.id)
-   ->  Index Scan using matest3i on public.matest3
-         Output: matest3.id, matest3.name, (1 - matest3.id)
+         Output: matest0_2.id, matest0_2.name, ((1 - matest0_2.id))
+         Sort Key: ((1 - matest0_2.id))
+         ->  Seq Scan on public.matest2 matest0_2
+               Output: matest0_2.id, matest0_2.name, (1 - matest0_2.id)
+   ->  Index Scan using matest3i on public.matest3 matest0_3
+         Output: matest0_3.id, matest0_3.name, (1 - matest0_3.id)
 (13 rows)
 
 select * from matest0 order by 1-id;
@@ -1489,8 +1489,8 @@ select * from matest0 order by 1-id;
 (6 rows)
 
 explain (verbose, costs off) select min(1-id) from matest0;
-                                QUERY PLAN                                
---------------------------------------------------------------------------
+                                   QUERY PLAN                                    
+---------------------------------------------------------------------------------
  Result
    Output: $0
    InitPlan 1 (returns $0)
@@ -1503,19 +1503,19 @@ explain (verbose, costs off) select min(1-id) from matest0;
                        ->  Index Scan using matest0i on public.matest0
                              Output: matest0.id, (1 - matest0.id)
                              Index Cond: ((1 - matest0.id) IS NOT NULL)
-                       ->  Index Scan using matest1i on public.matest1
-                             Output: matest1.id, (1 - matest1.id)
-                             Index Cond: ((1 - matest1.id) IS NOT NULL)
+                       ->  Index Scan using matest1i on public.matest1 matest0_1
+                             Output: matest0_1.id, (1 - matest0_1.id)
+                             Index Cond: ((1 - matest0_1.id) IS NOT NULL)
                        ->  Sort
-                             Output: matest2.id, ((1 - matest2.id))
-                             Sort Key: ((1 - matest2.id))
-                             ->  Bitmap Heap Scan on public.matest2
-                                   Output: matest2.id, (1 - matest2.id)
-                                   Filter: ((1 - matest2.id) IS NOT NULL)
+                             Output: matest0_2.id, ((1 - matest0_2.id))
+                             Sort Key: ((1 - matest0_2.id))
+                             ->  Bitmap Heap Scan on public.matest2 matest0_2
+                                   Output: matest0_2.id, (1 - matest0_2.id)
+                                   Filter: ((1 - matest0_2.id) IS NOT NULL)
                                    ->  Bitmap Index Scan on matest2_pkey
-                       ->  Index Scan using matest3i on public.matest3
-                             Output: matest3.id, (1 - matest3.id)
-                             Index Cond: ((1 - matest3.id) IS NOT NULL)
+                       ->  Index Scan using matest3i on public.matest3 matest0_3
+                             Output: matest0_3.id, (1 - matest0_3.id)
+                             Index Cond: ((1 - matest0_3.id) IS NOT NULL)
 (25 rows)
 
 select min(1-id) from matest0;
@@ -1780,30 +1780,30 @@ create table part_ab_cd partition of list_parted for values in ('ab', 'cd');
 create table part_ef_gh partition of list_parted for values in ('ef', 'gh');
 create table part_null_xy partition of list_parted for values in (null, 'xy');
 explain (costs off) select * from list_parted;
-           QUERY PLAN           
---------------------------------
+                  QUERY PLAN                  
+----------------------------------------------
  Append
-   ->  Seq Scan on part_ab_cd
-   ->  Seq Scan on part_ef_gh
-   ->  Seq Scan on part_null_xy
+   ->  Seq Scan on part_ab_cd list_parted
+   ->  Seq Scan on part_ef_gh list_parted_1
+   ->  Seq Scan on part_null_xy list_parted_2
 (4 rows)
 
 explain (costs off) select * from list_parted where a is null;
-        QUERY PLAN        
---------------------------
- Seq Scan on part_null_xy
+              QUERY PLAN              
+--------------------------------------
+ Seq Scan on part_null_xy list_parted
    Filter: (a IS NULL)
 (2 rows)
 
 explain (costs off) select * from list_parted where a is not null;
-           QUERY PLAN            
----------------------------------
+                  QUERY PLAN                  
+----------------------------------------------
  Append
-   ->  Seq Scan on part_ab_cd
+   ->  Seq Scan on part_ab_cd list_parted
          Filter: (a IS NOT NULL)
-   ->  Seq Scan on part_ef_gh
+   ->  Seq Scan on part_ef_gh list_parted_1
          Filter: (a IS NOT NULL)
-   ->  Seq Scan on part_null_xy
+   ->  Seq Scan on part_null_xy list_parted_2
          Filter: (a IS NOT NULL)
 (7 rows)
 
@@ -1811,23 +1811,23 @@ explain (costs off) select * from list_parted where a in ('ab', 'cd', 'ef');
                         QUERY PLAN                        
 ----------------------------------------------------------
  Append
-   ->  Seq Scan on part_ab_cd
+   ->  Seq Scan on part_ab_cd list_parted
          Filter: ((a)::text = ANY ('{ab,cd,ef}'::text[]))
-   ->  Seq Scan on part_ef_gh
+   ->  Seq Scan on part_ef_gh list_parted_1
          Filter: ((a)::text = ANY ('{ab,cd,ef}'::text[]))
 (5 rows)
 
 explain (costs off) select * from list_parted where a = 'ab' or a in (null, 'cd');
                                    QUERY PLAN                                    
 ---------------------------------------------------------------------------------
- Seq Scan on part_ab_cd
+ Seq Scan on part_ab_cd list_parted
    Filter: (((a)::text = 'ab'::text) OR ((a)::text = ANY ('{NULL,cd}'::text[])))
 (2 rows)
 
 explain (costs off) select * from list_parted where a = 'ab';
              QUERY PLAN             
 ------------------------------------
- Seq Scan on part_ab_cd
+ Seq Scan on part_ab_cd list_parted
    Filter: ((a)::text = 'ab'::text)
 (2 rows)
 
@@ -1849,41 +1849,41 @@ create table part_40_inf_ab partition of part_40_inf for values in ('ab');
 create table part_40_inf_cd partition of part_40_inf for values in ('cd');
 create table part_40_inf_null partition of part_40_inf for values in (null);
 explain (costs off) select * from range_list_parted;
-             QUERY PLAN             
-------------------------------------
+                       QUERY PLAN                       
+--------------------------------------------------------
  Append
-   ->  Seq Scan on part_1_10_ab
-   ->  Seq Scan on part_1_10_cd
-   ->  Seq Scan on part_10_20_ab
-   ->  Seq Scan on part_10_20_cd
-   ->  Seq Scan on part_21_30_ab
-   ->  Seq Scan on part_21_30_cd
-   ->  Seq Scan on part_40_inf_ab
-   ->  Seq Scan on part_40_inf_cd
-   ->  Seq Scan on part_40_inf_null
+   ->  Seq Scan on part_1_10_ab range_list_parted
+   ->  Seq Scan on part_1_10_cd range_list_parted_1
+   ->  Seq Scan on part_10_20_ab range_list_parted_2
+   ->  Seq Scan on part_10_20_cd range_list_parted_3
+   ->  Seq Scan on part_21_30_ab range_list_parted_4
+   ->  Seq Scan on part_21_30_cd range_list_parted_5
+   ->  Seq Scan on part_40_inf_ab range_list_parted_6
+   ->  Seq Scan on part_40_inf_cd range_list_parted_7
+   ->  Seq Scan on part_40_inf_null range_list_parted_8
 (10 rows)
 
 explain (costs off) select * from range_list_parted where a = 5;
-           QUERY PLAN           
---------------------------------
+                     QUERY PLAN                     
+----------------------------------------------------
  Append
-   ->  Seq Scan on part_1_10_ab
+   ->  Seq Scan on part_1_10_ab range_list_parted
          Filter: (a = 5)
-   ->  Seq Scan on part_1_10_cd
+   ->  Seq Scan on part_1_10_cd range_list_parted_1
          Filter: (a = 5)
 (5 rows)
 
 explain (costs off) select * from range_list_parted where b = 'ab';
-             QUERY PLAN             
-------------------------------------
+                      QUERY PLAN                      
+------------------------------------------------------
  Append
-   ->  Seq Scan on part_1_10_ab
+   ->  Seq Scan on part_1_10_ab range_list_parted
          Filter: (b = 'ab'::bpchar)
-   ->  Seq Scan on part_10_20_ab
+   ->  Seq Scan on part_10_20_ab range_list_parted_1
          Filter: (b = 'ab'::bpchar)
-   ->  Seq Scan on part_21_30_ab
+   ->  Seq Scan on part_21_30_ab range_list_parted_2
          Filter: (b = 'ab'::bpchar)
-   ->  Seq Scan on part_40_inf_ab
+   ->  Seq Scan on part_40_inf_ab range_list_parted_3
          Filter: (b = 'ab'::bpchar)
 (9 rows)
 
@@ -1891,11 +1891,11 @@ explain (costs off) select * from range_list_parted where a between 3 and 23 and
                            QUERY PLAN                            
 -----------------------------------------------------------------
  Append
-   ->  Seq Scan on part_1_10_ab
+   ->  Seq Scan on part_1_10_ab range_list_parted
          Filter: ((a >= 3) AND (a <= 23) AND (b = 'ab'::bpchar))
-   ->  Seq Scan on part_10_20_ab
+   ->  Seq Scan on part_10_20_ab range_list_parted_1
          Filter: ((a >= 3) AND (a <= 23) AND (b = 'ab'::bpchar))
-   ->  Seq Scan on part_21_30_ab
+   ->  Seq Scan on part_21_30_ab range_list_parted_2
          Filter: ((a >= 3) AND (a <= 23) AND (b = 'ab'::bpchar))
 (7 rows)
 
@@ -1909,45 +1909,45 @@ explain (costs off) select * from range_list_parted where a is null;
 
 /* Should only select rows from the null-accepting partition */
 explain (costs off) select * from range_list_parted where b is null;
-          QUERY PLAN          
-------------------------------
- Seq Scan on part_40_inf_null
+                   QUERY PLAN                   
+------------------------------------------------
+ Seq Scan on part_40_inf_null range_list_parted
    Filter: (b IS NULL)
 (2 rows)
 
 explain (costs off) select * from range_list_parted where a is not null and a < 67;
-                   QUERY PLAN                   
-------------------------------------------------
+                       QUERY PLAN                       
+--------------------------------------------------------
  Append
-   ->  Seq Scan on part_1_10_ab
+   ->  Seq Scan on part_1_10_ab range_list_parted
          Filter: ((a IS NOT NULL) AND (a < 67))
-   ->  Seq Scan on part_1_10_cd
+   ->  Seq Scan on part_1_10_cd range_list_parted_1
          Filter: ((a IS NOT NULL) AND (a < 67))
-   ->  Seq Scan on part_10_20_ab
+   ->  Seq Scan on part_10_20_ab range_list_parted_2
          Filter: ((a IS NOT NULL) AND (a < 67))
-   ->  Seq Scan on part_10_20_cd
+   ->  Seq Scan on part_10_20_cd range_list_parted_3
          Filter: ((a IS NOT NULL) AND (a < 67))
-   ->  Seq Scan on part_21_30_ab
+   ->  Seq Scan on part_21_30_ab range_list_parted_4
          Filter: ((a IS NOT NULL) AND (a < 67))
-   ->  Seq Scan on part_21_30_cd
+   ->  Seq Scan on part_21_30_cd range_list_parted_5
          Filter: ((a IS NOT NULL) AND (a < 67))
-   ->  Seq Scan on part_40_inf_ab
+   ->  Seq Scan on part_40_inf_ab range_list_parted_6
          Filter: ((a IS NOT NULL) AND (a < 67))
-   ->  Seq Scan on part_40_inf_cd
+   ->  Seq Scan on part_40_inf_cd range_list_parted_7
          Filter: ((a IS NOT NULL) AND (a < 67))
-   ->  Seq Scan on part_40_inf_null
+   ->  Seq Scan on part_40_inf_null range_list_parted_8
          Filter: ((a IS NOT NULL) AND (a < 67))
 (19 rows)
 
 explain (costs off) select * from range_list_parted where a >= 30;
-             QUERY PLAN             
-------------------------------------
+                       QUERY PLAN                       
+--------------------------------------------------------
  Append
-   ->  Seq Scan on part_40_inf_ab
+   ->  Seq Scan on part_40_inf_ab range_list_parted
          Filter: (a >= 30)
-   ->  Seq Scan on part_40_inf_cd
+   ->  Seq Scan on part_40_inf_cd range_list_parted_1
          Filter: (a >= 30)
-   ->  Seq Scan on part_40_inf_null
+   ->  Seq Scan on part_40_inf_null range_list_parted_2
          Filter: (a >= 30)
 (7 rows)
 
@@ -1964,12 +1964,12 @@ create table mcrparted3 partition of mcrparted for values from (11, 1, 1) to (20
 create table mcrparted4 partition of mcrparted for values from (20, 10, 10) to (20, 20, 20);
 create table mcrparted5 partition of mcrparted for values from (20, 20, 20) to (maxvalue, maxvalue, maxvalue);
 explain (costs off) select * from mcrparted where a = 0;	-- scans mcrparted0, mcrparted_def
-           QUERY PLAN            
----------------------------------
+                 QUERY PLAN                  
+---------------------------------------------
  Append
-   ->  Seq Scan on mcrparted0
+   ->  Seq Scan on mcrparted0 mcrparted
          Filter: (a = 0)
-   ->  Seq Scan on mcrparted_def
+   ->  Seq Scan on mcrparted_def mcrparted_1
          Filter: (a = 0)
 (5 rows)
 
@@ -1977,9 +1977,9 @@ explain (costs off) select * from mcrparted where a = 10 and abs(b) < 5;	-- scan
                  QUERY PLAN                  
 ---------------------------------------------
  Append
-   ->  Seq Scan on mcrparted1
+   ->  Seq Scan on mcrparted1 mcrparted
          Filter: ((a = 10) AND (abs(b) < 5))
-   ->  Seq Scan on mcrparted_def
+   ->  Seq Scan on mcrparted_def mcrparted_1
          Filter: ((a = 10) AND (abs(b) < 5))
 (5 rows)
 
@@ -1987,72 +1987,72 @@ explain (costs off) select * from mcrparted where a = 10 and abs(b) = 5;	-- scan
                  QUERY PLAN                  
 ---------------------------------------------
  Append
-   ->  Seq Scan on mcrparted1
+   ->  Seq Scan on mcrparted1 mcrparted
          Filter: ((a = 10) AND (abs(b) = 5))
-   ->  Seq Scan on mcrparted2
+   ->  Seq Scan on mcrparted2 mcrparted_1
          Filter: ((a = 10) AND (abs(b) = 5))
-   ->  Seq Scan on mcrparted_def
+   ->  Seq Scan on mcrparted_def mcrparted_2
          Filter: ((a = 10) AND (abs(b) = 5))
 (7 rows)
 
 explain (costs off) select * from mcrparted where abs(b) = 5;	-- scans all partitions
-           QUERY PLAN            
----------------------------------
+                 QUERY PLAN                  
+---------------------------------------------
  Append
-   ->  Seq Scan on mcrparted0
+   ->  Seq Scan on mcrparted0 mcrparted
          Filter: (abs(b) = 5)
-   ->  Seq Scan on mcrparted1
+   ->  Seq Scan on mcrparted1 mcrparted_1
          Filter: (abs(b) = 5)
-   ->  Seq Scan on mcrparted2
+   ->  Seq Scan on mcrparted2 mcrparted_2
          Filter: (abs(b) = 5)
-   ->  Seq Scan on mcrparted3
+   ->  Seq Scan on mcrparted3 mcrparted_3
          Filter: (abs(b) = 5)
-   ->  Seq Scan on mcrparted4
+   ->  Seq Scan on mcrparted4 mcrparted_4
          Filter: (abs(b) = 5)
-   ->  Seq Scan on mcrparted5
+   ->  Seq Scan on mcrparted5 mcrparted_5
          Filter: (abs(b) = 5)
-   ->  Seq Scan on mcrparted_def
+   ->  Seq Scan on mcrparted_def mcrparted_6
          Filter: (abs(b) = 5)
 (15 rows)
 
 explain (costs off) select * from mcrparted where a > -1;	-- scans all partitions
-             QUERY PLAN              
--------------------------------------
+                 QUERY PLAN                  
+---------------------------------------------
  Append
-   ->  Seq Scan on mcrparted0
+   ->  Seq Scan on mcrparted0 mcrparted
          Filter: (a > '-1'::integer)
-   ->  Seq Scan on mcrparted1
+   ->  Seq Scan on mcrparted1 mcrparted_1
          Filter: (a > '-1'::integer)
-   ->  Seq Scan on mcrparted2
+   ->  Seq Scan on mcrparted2 mcrparted_2
          Filter: (a > '-1'::integer)
-   ->  Seq Scan on mcrparted3
+   ->  Seq Scan on mcrparted3 mcrparted_3
          Filter: (a > '-1'::integer)
-   ->  Seq Scan on mcrparted4
+   ->  Seq Scan on mcrparted4 mcrparted_4
          Filter: (a > '-1'::integer)
-   ->  Seq Scan on mcrparted5
+   ->  Seq Scan on mcrparted5 mcrparted_5
          Filter: (a > '-1'::integer)
-   ->  Seq Scan on mcrparted_def
+   ->  Seq Scan on mcrparted_def mcrparted_6
          Filter: (a > '-1'::integer)
 (15 rows)
 
 explain (costs off) select * from mcrparted where a = 20 and abs(b) = 10 and c > 10;	-- scans mcrparted4
                      QUERY PLAN                      
 -----------------------------------------------------
- Seq Scan on mcrparted4
+ Seq Scan on mcrparted4 mcrparted
    Filter: ((c > 10) AND (a = 20) AND (abs(b) = 10))
 (2 rows)
 
 explain (costs off) select * from mcrparted where a = 20 and c > 20; -- scans mcrparted3, mcrparte4, mcrparte5, mcrparted_def
-               QUERY PLAN                
------------------------------------------
+                 QUERY PLAN                  
+---------------------------------------------
  Append
-   ->  Seq Scan on mcrparted3
+   ->  Seq Scan on mcrparted3 mcrparted
          Filter: ((c > 20) AND (a = 20))
-   ->  Seq Scan on mcrparted4
+   ->  Seq Scan on mcrparted4 mcrparted_1
          Filter: ((c > 20) AND (a = 20))
-   ->  Seq Scan on mcrparted5
+   ->  Seq Scan on mcrparted5 mcrparted_2
          Filter: ((c > 20) AND (a = 20))
-   ->  Seq Scan on mcrparted_def
+   ->  Seq Scan on mcrparted_def mcrparted_3
          Filter: ((c > 20) AND (a = 20))
 (9 rows)
 
@@ -2063,16 +2063,16 @@ create table parted_minmax1 partition of parted_minmax for values from (1) to (1
 create index parted_minmax1i on parted_minmax1 (a, b);
 insert into parted_minmax values (1,'12345');
 explain (costs off) select min(a), max(a) from parted_minmax where b = '12345';
-                                           QUERY PLAN                                            
--------------------------------------------------------------------------------------------------
+                                           QUERY PLAN                                           
+------------------------------------------------------------------------------------------------
  Result
    InitPlan 1 (returns $0)
      ->  Limit
-           ->  Index Only Scan using parted_minmax1i on parted_minmax1
+           ->  Index Only Scan using parted_minmax1i on parted_minmax1 parted_minmax
                  Index Cond: ((a IS NOT NULL) AND (b = '12345'::text))
    InitPlan 2 (returns $1)
      ->  Limit
-           ->  Index Only Scan Backward using parted_minmax1i on parted_minmax1 parted_minmax1_1
+           ->  Index Only Scan Backward using parted_minmax1i on parted_minmax1 parted_minmax_1
                  Index Cond: ((a IS NOT NULL) AND (b = '12345'::text))
 (9 rows)
 
@@ -2088,45 +2088,45 @@ drop table parted_minmax;
 create index mcrparted_a_abs_c_idx on mcrparted (a, abs(b), c);
 -- MergeAppend must be used when a default partition exists
 explain (costs off) select * from mcrparted order by a, abs(b), c;
-                            QUERY PLAN                             
--------------------------------------------------------------------
+                                  QUERY PLAN                                   
+-------------------------------------------------------------------------------
  Merge Append
-   Sort Key: mcrparted0.a, (abs(mcrparted0.b)), mcrparted0.c
-   ->  Index Scan using mcrparted0_a_abs_c_idx on mcrparted0
-   ->  Index Scan using mcrparted1_a_abs_c_idx on mcrparted1
-   ->  Index Scan using mcrparted2_a_abs_c_idx on mcrparted2
-   ->  Index Scan using mcrparted3_a_abs_c_idx on mcrparted3
-   ->  Index Scan using mcrparted4_a_abs_c_idx on mcrparted4
-   ->  Index Scan using mcrparted5_a_abs_c_idx on mcrparted5
-   ->  Index Scan using mcrparted_def_a_abs_c_idx on mcrparted_def
+   Sort Key: mcrparted.a, (abs(mcrparted.b)), mcrparted.c
+   ->  Index Scan using mcrparted0_a_abs_c_idx on mcrparted0 mcrparted
+   ->  Index Scan using mcrparted1_a_abs_c_idx on mcrparted1 mcrparted_1
+   ->  Index Scan using mcrparted2_a_abs_c_idx on mcrparted2 mcrparted_2
+   ->  Index Scan using mcrparted3_a_abs_c_idx on mcrparted3 mcrparted_3
+   ->  Index Scan using mcrparted4_a_abs_c_idx on mcrparted4 mcrparted_4
+   ->  Index Scan using mcrparted5_a_abs_c_idx on mcrparted5 mcrparted_5
+   ->  Index Scan using mcrparted_def_a_abs_c_idx on mcrparted_def mcrparted_6
 (9 rows)
 
 drop table mcrparted_def;
 -- Append is used for a RANGE partitioned table with no default
 -- and no subpartitions
 explain (costs off) select * from mcrparted order by a, abs(b), c;
-                         QUERY PLAN                          
--------------------------------------------------------------
+                               QUERY PLAN                                
+-------------------------------------------------------------------------
  Append
-   ->  Index Scan using mcrparted0_a_abs_c_idx on mcrparted0
-   ->  Index Scan using mcrparted1_a_abs_c_idx on mcrparted1
-   ->  Index Scan using mcrparted2_a_abs_c_idx on mcrparted2
-   ->  Index Scan using mcrparted3_a_abs_c_idx on mcrparted3
-   ->  Index Scan using mcrparted4_a_abs_c_idx on mcrparted4
-   ->  Index Scan using mcrparted5_a_abs_c_idx on mcrparted5
+   ->  Index Scan using mcrparted0_a_abs_c_idx on mcrparted0 mcrparted
+   ->  Index Scan using mcrparted1_a_abs_c_idx on mcrparted1 mcrparted_1
+   ->  Index Scan using mcrparted2_a_abs_c_idx on mcrparted2 mcrparted_2
+   ->  Index Scan using mcrparted3_a_abs_c_idx on mcrparted3 mcrparted_3
+   ->  Index Scan using mcrparted4_a_abs_c_idx on mcrparted4 mcrparted_4
+   ->  Index Scan using mcrparted5_a_abs_c_idx on mcrparted5 mcrparted_5
 (7 rows)
 
 -- Append is used with subpaths in reverse order with backwards index scans
 explain (costs off) select * from mcrparted order by a desc, abs(b) desc, c desc;
-                              QUERY PLAN                              
-----------------------------------------------------------------------
+                                    QUERY PLAN                                    
+----------------------------------------------------------------------------------
  Append
-   ->  Index Scan Backward using mcrparted5_a_abs_c_idx on mcrparted5
-   ->  Index Scan Backward using mcrparted4_a_abs_c_idx on mcrparted4
-   ->  Index Scan Backward using mcrparted3_a_abs_c_idx on mcrparted3
-   ->  Index Scan Backward using mcrparted2_a_abs_c_idx on mcrparted2
-   ->  Index Scan Backward using mcrparted1_a_abs_c_idx on mcrparted1
-   ->  Index Scan Backward using mcrparted0_a_abs_c_idx on mcrparted0
+   ->  Index Scan Backward using mcrparted5_a_abs_c_idx on mcrparted5 mcrparted_5
+   ->  Index Scan Backward using mcrparted4_a_abs_c_idx on mcrparted4 mcrparted_4
+   ->  Index Scan Backward using mcrparted3_a_abs_c_idx on mcrparted3 mcrparted_3
+   ->  Index Scan Backward using mcrparted2_a_abs_c_idx on mcrparted2 mcrparted_2
+   ->  Index Scan Backward using mcrparted1_a_abs_c_idx on mcrparted1 mcrparted_1
+   ->  Index Scan Backward using mcrparted0_a_abs_c_idx on mcrparted0 mcrparted
 (7 rows)
 
 -- check that Append plan is used containing a MergeAppend for sub-partitions
@@ -2136,18 +2136,18 @@ create table mcrparted5 partition of mcrparted for values from (20, 20, 20) to (
 create table mcrparted5a partition of mcrparted5 for values in(20);
 create table mcrparted5_def partition of mcrparted5 default;
 explain (costs off) select * from mcrparted order by a, abs(b), c;
-                                QUERY PLAN                                 
----------------------------------------------------------------------------
+                                      QUERY PLAN                                       
+---------------------------------------------------------------------------------------
  Append
-   ->  Index Scan using mcrparted0_a_abs_c_idx on mcrparted0
-   ->  Index Scan using mcrparted1_a_abs_c_idx on mcrparted1
-   ->  Index Scan using mcrparted2_a_abs_c_idx on mcrparted2
-   ->  Index Scan using mcrparted3_a_abs_c_idx on mcrparted3
-   ->  Index Scan using mcrparted4_a_abs_c_idx on mcrparted4
+   ->  Index Scan using mcrparted0_a_abs_c_idx on mcrparted0 mcrparted
+   ->  Index Scan using mcrparted1_a_abs_c_idx on mcrparted1 mcrparted_1
+   ->  Index Scan using mcrparted2_a_abs_c_idx on mcrparted2 mcrparted_2
+   ->  Index Scan using mcrparted3_a_abs_c_idx on mcrparted3 mcrparted_3
+   ->  Index Scan using mcrparted4_a_abs_c_idx on mcrparted4 mcrparted_4
    ->  Merge Append
-         Sort Key: mcrparted5a.a, (abs(mcrparted5a.b)), mcrparted5a.c
-         ->  Index Scan using mcrparted5a_a_abs_c_idx on mcrparted5a
-         ->  Index Scan using mcrparted5_def_a_abs_c_idx on mcrparted5_def
+         Sort Key: mcrparted_5.a, (abs(mcrparted_5.b)), mcrparted_5.c
+         ->  Index Scan using mcrparted5a_a_abs_c_idx on mcrparted5a mcrparted_5
+         ->  Index Scan using mcrparted5_def_a_abs_c_idx on mcrparted5_def mcrparted_6
 (10 rows)
 
 drop table mcrparted5_def;
@@ -2155,30 +2155,30 @@ drop table mcrparted5_def;
 -- into the main Append when the sub-partition is unordered but contains
 -- just a single sub-partition.
 explain (costs off) select a, abs(b) from mcrparted order by a, abs(b), c;
-                          QUERY PLAN                           
----------------------------------------------------------------
+                                QUERY PLAN                                 
+---------------------------------------------------------------------------
  Append
-   ->  Index Scan using mcrparted0_a_abs_c_idx on mcrparted0
-   ->  Index Scan using mcrparted1_a_abs_c_idx on mcrparted1
-   ->  Index Scan using mcrparted2_a_abs_c_idx on mcrparted2
-   ->  Index Scan using mcrparted3_a_abs_c_idx on mcrparted3
-   ->  Index Scan using mcrparted4_a_abs_c_idx on mcrparted4
-   ->  Index Scan using mcrparted5a_a_abs_c_idx on mcrparted5a
+   ->  Index Scan using mcrparted0_a_abs_c_idx on mcrparted0 mcrparted
+   ->  Index Scan using mcrparted1_a_abs_c_idx on mcrparted1 mcrparted_1
+   ->  Index Scan using mcrparted2_a_abs_c_idx on mcrparted2 mcrparted_2
+   ->  Index Scan using mcrparted3_a_abs_c_idx on mcrparted3 mcrparted_3
+   ->  Index Scan using mcrparted4_a_abs_c_idx on mcrparted4 mcrparted_4
+   ->  Index Scan using mcrparted5a_a_abs_c_idx on mcrparted5a mcrparted_5
 (7 rows)
 
 -- check that Append is used when the sub-partitioned tables are pruned
 -- during planning.
 explain (costs off) select * from mcrparted where a < 20 order by a, abs(b), c;
-                         QUERY PLAN                          
--------------------------------------------------------------
+                               QUERY PLAN                                
+-------------------------------------------------------------------------
  Append
-   ->  Index Scan using mcrparted0_a_abs_c_idx on mcrparted0
+   ->  Index Scan using mcrparted0_a_abs_c_idx on mcrparted0 mcrparted
          Index Cond: (a < 20)
-   ->  Index Scan using mcrparted1_a_abs_c_idx on mcrparted1
+   ->  Index Scan using mcrparted1_a_abs_c_idx on mcrparted1 mcrparted_1
          Index Cond: (a < 20)
-   ->  Index Scan using mcrparted2_a_abs_c_idx on mcrparted2
+   ->  Index Scan using mcrparted2_a_abs_c_idx on mcrparted2 mcrparted_2
          Index Cond: (a < 20)
-   ->  Index Scan using mcrparted3_a_abs_c_idx on mcrparted3
+   ->  Index Scan using mcrparted3_a_abs_c_idx on mcrparted3 mcrparted_3
          Index Cond: (a < 20)
 (9 rows)
 
@@ -2188,11 +2188,11 @@ create table mclparted2 partition of mclparted for values in(2);
 create index on mclparted (a);
 -- Ensure an Append is used for a list partition with an order by.
 explain (costs off) select * from mclparted order by a;
-                         QUERY PLAN                         
-------------------------------------------------------------
+                               QUERY PLAN                               
+------------------------------------------------------------------------
  Append
-   ->  Index Only Scan using mclparted1_a_idx on mclparted1
-   ->  Index Only Scan using mclparted2_a_idx on mclparted2
+   ->  Index Only Scan using mclparted1_a_idx on mclparted1 mclparted
+   ->  Index Only Scan using mclparted2_a_idx on mclparted2 mclparted_1
 (3 rows)
 
 -- Ensure a MergeAppend is used when a partition exists with interleaved
@@ -2200,14 +2200,14 @@ explain (costs off) select * from mclparted order by a;
 create table mclparted3_5 partition of mclparted for values in(3,5);
 create table mclparted4 partition of mclparted for values in(4);
 explain (costs off) select * from mclparted order by a;
-                           QUERY PLAN                           
-----------------------------------------------------------------
+                                 QUERY PLAN                                 
+----------------------------------------------------------------------------
  Merge Append
-   Sort Key: mclparted1.a
-   ->  Index Only Scan using mclparted1_a_idx on mclparted1
-   ->  Index Only Scan using mclparted2_a_idx on mclparted2
-   ->  Index Only Scan using mclparted3_5_a_idx on mclparted3_5
-   ->  Index Only Scan using mclparted4_a_idx on mclparted4
+   Sort Key: mclparted.a
+   ->  Index Only Scan using mclparted1_a_idx on mclparted1 mclparted
+   ->  Index Only Scan using mclparted2_a_idx on mclparted2 mclparted_1
+   ->  Index Only Scan using mclparted3_5_a_idx on mclparted3_5 mclparted_2
+   ->  Index Only Scan using mclparted4_a_idx on mclparted4 mclparted_3
 (6 rows)
 
 drop table mclparted;
@@ -2219,19 +2219,19 @@ create index on mcrparted2 (a, abs(b), c);
 create index on mcrparted3 (a, abs(b), c);
 create index on mcrparted4 (a, abs(b), c);
 explain (costs off) select * from mcrparted where a < 20 order by a, abs(b), c limit 1;
-                               QUERY PLAN                                
--------------------------------------------------------------------------
+                                  QUERY PLAN                                   
+-------------------------------------------------------------------------------
  Limit
    ->  Append
          ->  Sort
-               Sort Key: mcrparted0.a, (abs(mcrparted0.b)), mcrparted0.c
-               ->  Seq Scan on mcrparted0
+               Sort Key: mcrparted.a, (abs(mcrparted.b)), mcrparted.c
+               ->  Seq Scan on mcrparted0 mcrparted
                      Filter: (a < 20)
-         ->  Index Scan using mcrparted1_a_abs_c_idx on mcrparted1
+         ->  Index Scan using mcrparted1_a_abs_c_idx on mcrparted1 mcrparted_1
                Index Cond: (a < 20)
-         ->  Index Scan using mcrparted2_a_abs_c_idx on mcrparted2
+         ->  Index Scan using mcrparted2_a_abs_c_idx on mcrparted2 mcrparted_2
                Index Cond: (a < 20)
-         ->  Index Scan using mcrparted3_a_abs_c_idx on mcrparted3
+         ->  Index Scan using mcrparted3_a_abs_c_idx on mcrparted3 mcrparted_3
                Index Cond: (a < 20)
 (12 rows)
 
@@ -2239,12 +2239,12 @@ set enable_bitmapscan = 0;
 -- Ensure Append node can be used when the partition is ordered by some
 -- pathkeys which were deemed redundant.
 explain (costs off) select * from mcrparted where a = 10 order by a, abs(b), c;
-                         QUERY PLAN                          
--------------------------------------------------------------
+                               QUERY PLAN                                
+-------------------------------------------------------------------------
  Append
-   ->  Index Scan using mcrparted1_a_abs_c_idx on mcrparted1
+   ->  Index Scan using mcrparted1_a_abs_c_idx on mcrparted1 mcrparted
          Index Cond: (a = 10)
-   ->  Index Scan using mcrparted2_a_abs_c_idx on mcrparted2
+   ->  Index Scan using mcrparted2_a_abs_c_idx on mcrparted2 mcrparted_1
          Index Cond: (a = 10)
 (5 rows)
 
@@ -2256,11 +2256,11 @@ create table bool_lp_true partition of bool_lp for values in(true);
 create table bool_lp_false partition of bool_lp for values in(false);
 create index on bool_lp (b);
 explain (costs off) select * from bool_lp order by b;
-                            QUERY PLAN                            
-------------------------------------------------------------------
+                                QUERY PLAN                                
+--------------------------------------------------------------------------
  Append
-   ->  Index Only Scan using bool_lp_false_b_idx on bool_lp_false
-   ->  Index Only Scan using bool_lp_true_b_idx on bool_lp_true
+   ->  Index Only Scan using bool_lp_false_b_idx on bool_lp_false bool_lp
+   ->  Index Only Scan using bool_lp_true_b_idx on bool_lp_true bool_lp_1
 (3 rows)
 
 drop table bool_lp;
@@ -2272,42 +2272,42 @@ create table bool_rp_false_2k partition of bool_rp for values from (false,1000)
 create table bool_rp_true_2k partition of bool_rp for values from (true,1000) to (true,2000);
 create index on bool_rp (b,a);
 explain (costs off) select * from bool_rp where b = true order by b,a;
-                               QUERY PLAN                               
-------------------------------------------------------------------------
+                                    QUERY PLAN                                    
+----------------------------------------------------------------------------------
  Append
-   ->  Index Only Scan using bool_rp_true_1k_b_a_idx on bool_rp_true_1k
+   ->  Index Only Scan using bool_rp_true_1k_b_a_idx on bool_rp_true_1k bool_rp
          Index Cond: (b = true)
-   ->  Index Only Scan using bool_rp_true_2k_b_a_idx on bool_rp_true_2k
+   ->  Index Only Scan using bool_rp_true_2k_b_a_idx on bool_rp_true_2k bool_rp_1
          Index Cond: (b = true)
 (5 rows)
 
 explain (costs off) select * from bool_rp where b = false order by b,a;
-                                QUERY PLAN                                
---------------------------------------------------------------------------
+                                     QUERY PLAN                                     
+------------------------------------------------------------------------------------
  Append
-   ->  Index Only Scan using bool_rp_false_1k_b_a_idx on bool_rp_false_1k
+   ->  Index Only Scan using bool_rp_false_1k_b_a_idx on bool_rp_false_1k bool_rp
          Index Cond: (b = false)
-   ->  Index Only Scan using bool_rp_false_2k_b_a_idx on bool_rp_false_2k
+   ->  Index Only Scan using bool_rp_false_2k_b_a_idx on bool_rp_false_2k bool_rp_1
          Index Cond: (b = false)
 (5 rows)
 
 explain (costs off) select * from bool_rp where b = true order by a;
-                               QUERY PLAN                               
-------------------------------------------------------------------------
+                                    QUERY PLAN                                    
+----------------------------------------------------------------------------------
  Append
-   ->  Index Only Scan using bool_rp_true_1k_b_a_idx on bool_rp_true_1k
+   ->  Index Only Scan using bool_rp_true_1k_b_a_idx on bool_rp_true_1k bool_rp
          Index Cond: (b = true)
-   ->  Index Only Scan using bool_rp_true_2k_b_a_idx on bool_rp_true_2k
+   ->  Index Only Scan using bool_rp_true_2k_b_a_idx on bool_rp_true_2k bool_rp_1
          Index Cond: (b = true)
 (5 rows)
 
 explain (costs off) select * from bool_rp where b = false order by a;
-                                QUERY PLAN                                
---------------------------------------------------------------------------
+                                     QUERY PLAN                                     
+------------------------------------------------------------------------------------
  Append
-   ->  Index Only Scan using bool_rp_false_1k_b_a_idx on bool_rp_false_1k
+   ->  Index Only Scan using bool_rp_false_1k_b_a_idx on bool_rp_false_1k bool_rp
          Index Cond: (b = false)
-   ->  Index Only Scan using bool_rp_false_2k_b_a_idx on bool_rp_false_2k
+   ->  Index Only Scan using bool_rp_false_2k_b_a_idx on bool_rp_false_2k bool_rp_1
          Index Cond: (b = false)
 (5 rows)
 
@@ -2319,19 +2319,19 @@ create table range_parted1 partition of range_parted for values from (0,0) to (1
 create table range_parted2 partition of range_parted for values from (10,10) to (20,20);
 create index on range_parted (a,b,c);
 explain (costs off) select * from range_parted order by a,b,c;
-                              QUERY PLAN                              
-----------------------------------------------------------------------
+                                     QUERY PLAN                                      
+-------------------------------------------------------------------------------------
  Append
-   ->  Index Only Scan using range_parted1_a_b_c_idx on range_parted1
-   ->  Index Only Scan using range_parted2_a_b_c_idx on range_parted2
+   ->  Index Only Scan using range_parted1_a_b_c_idx on range_parted1 range_parted
+   ->  Index Only Scan using range_parted2_a_b_c_idx on range_parted2 range_parted_1
 (3 rows)
 
 explain (costs off) select * from range_parted order by a desc,b desc,c desc;
-                                  QUERY PLAN                                   
--------------------------------------------------------------------------------
+                                          QUERY PLAN                                          
+----------------------------------------------------------------------------------------------
  Append
-   ->  Index Only Scan Backward using range_parted2_a_b_c_idx on range_parted2
-   ->  Index Only Scan Backward using range_parted1_a_b_c_idx on range_parted1
+   ->  Index Only Scan Backward using range_parted2_a_b_c_idx on range_parted2 range_parted_1
+   ->  Index Only Scan Backward using range_parted1_a_b_c_idx on range_parted1 range_parted
 (3 rows)
 
 drop table range_parted;
diff --git a/src/test/regress/expected/partition_aggregate.out b/src/test/regress/expected/partition_aggregate.out
index 10349ec29c40..b3fec2a21cb2 100644
--- a/src/test/regress/expected/partition_aggregate.out
+++ b/src/test/regress/expected/partition_aggregate.out
@@ -20,23 +20,23 @@ ANALYZE pagg_tab;
 -- When GROUP BY clause matches; full aggregation is performed for each partition.
 EXPLAIN (COSTS OFF)
 SELECT c, sum(a), avg(b), count(*), min(a), max(b) FROM pagg_tab GROUP BY c HAVING avg(d) < 15 ORDER BY 1, 2, 3;
-                              QUERY PLAN                               
------------------------------------------------------------------------
+                          QUERY PLAN                          
+--------------------------------------------------------------
  Sort
-   Sort Key: pagg_tab_p1.c, (sum(pagg_tab_p1.a)), (avg(pagg_tab_p1.b))
+   Sort Key: pagg_tab.c, (sum(pagg_tab.a)), (avg(pagg_tab.b))
    ->  Append
          ->  HashAggregate
-               Group Key: pagg_tab_p1.c
-               Filter: (avg(pagg_tab_p1.d) < '15'::numeric)
-               ->  Seq Scan on pagg_tab_p1
+               Group Key: pagg_tab.c
+               Filter: (avg(pagg_tab.d) < '15'::numeric)
+               ->  Seq Scan on pagg_tab_p1 pagg_tab
          ->  HashAggregate
-               Group Key: pagg_tab_p2.c
-               Filter: (avg(pagg_tab_p2.d) < '15'::numeric)
-               ->  Seq Scan on pagg_tab_p2
+               Group Key: pagg_tab_1.c
+               Filter: (avg(pagg_tab_1.d) < '15'::numeric)
+               ->  Seq Scan on pagg_tab_p2 pagg_tab_1
          ->  HashAggregate
-               Group Key: pagg_tab_p3.c
-               Filter: (avg(pagg_tab_p3.d) < '15'::numeric)
-               ->  Seq Scan on pagg_tab_p3
+               Group Key: pagg_tab_2.c
+               Filter: (avg(pagg_tab_2.d) < '15'::numeric)
+               ->  Seq Scan on pagg_tab_p3 pagg_tab_2
 (15 rows)
 
 SELECT c, sum(a), avg(b), count(*), min(a), max(b) FROM pagg_tab GROUP BY c HAVING avg(d) < 15 ORDER BY 1, 2, 3;
@@ -53,23 +53,23 @@ SELECT c, sum(a), avg(b), count(*), min(a), max(b) FROM pagg_tab GROUP BY c HAVI
 -- When GROUP BY clause does not match; partial aggregation is performed for each partition.
 EXPLAIN (COSTS OFF)
 SELECT a, sum(b), avg(b), count(*), min(a), max(b) FROM pagg_tab GROUP BY a HAVING avg(d) < 15 ORDER BY 1, 2, 3;
-                              QUERY PLAN                               
------------------------------------------------------------------------
+                          QUERY PLAN                          
+--------------------------------------------------------------
  Sort
-   Sort Key: pagg_tab_p1.a, (sum(pagg_tab_p1.b)), (avg(pagg_tab_p1.b))
+   Sort Key: pagg_tab.a, (sum(pagg_tab.b)), (avg(pagg_tab.b))
    ->  Finalize HashAggregate
-         Group Key: pagg_tab_p1.a
-         Filter: (avg(pagg_tab_p1.d) < '15'::numeric)
+         Group Key: pagg_tab.a
+         Filter: (avg(pagg_tab.d) < '15'::numeric)
          ->  Append
                ->  Partial HashAggregate
-                     Group Key: pagg_tab_p1.a
-                     ->  Seq Scan on pagg_tab_p1
+                     Group Key: pagg_tab.a
+                     ->  Seq Scan on pagg_tab_p1 pagg_tab
                ->  Partial HashAggregate
-                     Group Key: pagg_tab_p2.a
-                     ->  Seq Scan on pagg_tab_p2
+                     Group Key: pagg_tab_1.a
+                     ->  Seq Scan on pagg_tab_p2 pagg_tab_1
                ->  Partial HashAggregate
-                     Group Key: pagg_tab_p3.a
-                     ->  Seq Scan on pagg_tab_p3
+                     Group Key: pagg_tab_2.a
+                     ->  Seq Scan on pagg_tab_p3 pagg_tab_2
 (15 rows)
 
 SELECT a, sum(b), avg(b), count(*), min(a), max(b) FROM pagg_tab GROUP BY a HAVING avg(d) < 15 ORDER BY 1, 2, 3;
@@ -90,52 +90,52 @@ SELECT a, sum(b), avg(b), count(*), min(a), max(b) FROM pagg_tab GROUP BY a HAVI
 -- Check with multiple columns in GROUP BY
 EXPLAIN (COSTS OFF)
 SELECT a, c, count(*) FROM pagg_tab GROUP BY a, c;
-                   QUERY PLAN                    
--------------------------------------------------
+                   QUERY PLAN                   
+------------------------------------------------
  Append
    ->  HashAggregate
-         Group Key: pagg_tab_p1.a, pagg_tab_p1.c
-         ->  Seq Scan on pagg_tab_p1
+         Group Key: pagg_tab.a, pagg_tab.c
+         ->  Seq Scan on pagg_tab_p1 pagg_tab
    ->  HashAggregate
-         Group Key: pagg_tab_p2.a, pagg_tab_p2.c
-         ->  Seq Scan on pagg_tab_p2
+         Group Key: pagg_tab_1.a, pagg_tab_1.c
+         ->  Seq Scan on pagg_tab_p2 pagg_tab_1
    ->  HashAggregate
-         Group Key: pagg_tab_p3.a, pagg_tab_p3.c
-         ->  Seq Scan on pagg_tab_p3
+         Group Key: pagg_tab_2.a, pagg_tab_2.c
+         ->  Seq Scan on pagg_tab_p3 pagg_tab_2
 (10 rows)
 
 -- Check with multiple columns in GROUP BY, order in GROUP BY is reversed
 EXPLAIN (COSTS OFF)
 SELECT a, c, count(*) FROM pagg_tab GROUP BY c, a;
-                   QUERY PLAN                    
--------------------------------------------------
+                   QUERY PLAN                   
+------------------------------------------------
  Append
    ->  HashAggregate
-         Group Key: pagg_tab_p1.c, pagg_tab_p1.a
-         ->  Seq Scan on pagg_tab_p1
+         Group Key: pagg_tab.c, pagg_tab.a
+         ->  Seq Scan on pagg_tab_p1 pagg_tab
    ->  HashAggregate
-         Group Key: pagg_tab_p2.c, pagg_tab_p2.a
-         ->  Seq Scan on pagg_tab_p2
+         Group Key: pagg_tab_1.c, pagg_tab_1.a
+         ->  Seq Scan on pagg_tab_p2 pagg_tab_1
    ->  HashAggregate
-         Group Key: pagg_tab_p3.c, pagg_tab_p3.a
-         ->  Seq Scan on pagg_tab_p3
+         Group Key: pagg_tab_2.c, pagg_tab_2.a
+         ->  Seq Scan on pagg_tab_p3 pagg_tab_2
 (10 rows)
 
 -- Check with multiple columns in GROUP BY, order in target-list is reversed
 EXPLAIN (COSTS OFF)
 SELECT c, a, count(*) FROM pagg_tab GROUP BY a, c;
-                   QUERY PLAN                    
--------------------------------------------------
+                   QUERY PLAN                   
+------------------------------------------------
  Append
    ->  HashAggregate
-         Group Key: pagg_tab_p1.a, pagg_tab_p1.c
-         ->  Seq Scan on pagg_tab_p1
+         Group Key: pagg_tab.a, pagg_tab.c
+         ->  Seq Scan on pagg_tab_p1 pagg_tab
    ->  HashAggregate
-         Group Key: pagg_tab_p2.a, pagg_tab_p2.c
-         ->  Seq Scan on pagg_tab_p2
+         Group Key: pagg_tab_1.a, pagg_tab_1.c
+         ->  Seq Scan on pagg_tab_p2 pagg_tab_1
    ->  HashAggregate
-         Group Key: pagg_tab_p3.a, pagg_tab_p3.c
-         ->  Seq Scan on pagg_tab_p3
+         Group Key: pagg_tab_2.a, pagg_tab_2.c
+         ->  Seq Scan on pagg_tab_p3 pagg_tab_2
 (10 rows)
 
 -- Test when input relation for grouping is dummy
@@ -174,29 +174,29 @@ SET enable_hashagg TO false;
 -- When GROUP BY clause matches full aggregation is performed for each partition.
 EXPLAIN (COSTS OFF)
 SELECT c, sum(a), avg(b), count(*) FROM pagg_tab GROUP BY 1 HAVING avg(d) < 15 ORDER BY 1, 2, 3;
-                              QUERY PLAN                               
------------------------------------------------------------------------
+                          QUERY PLAN                          
+--------------------------------------------------------------
  Sort
-   Sort Key: pagg_tab_p1.c, (sum(pagg_tab_p1.a)), (avg(pagg_tab_p1.b))
+   Sort Key: pagg_tab.c, (sum(pagg_tab.a)), (avg(pagg_tab.b))
    ->  Append
          ->  GroupAggregate
-               Group Key: pagg_tab_p1.c
-               Filter: (avg(pagg_tab_p1.d) < '15'::numeric)
+               Group Key: pagg_tab.c
+               Filter: (avg(pagg_tab.d) < '15'::numeric)
                ->  Sort
-                     Sort Key: pagg_tab_p1.c
-                     ->  Seq Scan on pagg_tab_p1
+                     Sort Key: pagg_tab.c
+                     ->  Seq Scan on pagg_tab_p1 pagg_tab
          ->  GroupAggregate
-               Group Key: pagg_tab_p2.c
-               Filter: (avg(pagg_tab_p2.d) < '15'::numeric)
+               Group Key: pagg_tab_1.c
+               Filter: (avg(pagg_tab_1.d) < '15'::numeric)
                ->  Sort
-                     Sort Key: pagg_tab_p2.c
-                     ->  Seq Scan on pagg_tab_p2
+                     Sort Key: pagg_tab_1.c
+                     ->  Seq Scan on pagg_tab_p2 pagg_tab_1
          ->  GroupAggregate
-               Group Key: pagg_tab_p3.c
-               Filter: (avg(pagg_tab_p3.d) < '15'::numeric)
+               Group Key: pagg_tab_2.c
+               Filter: (avg(pagg_tab_2.d) < '15'::numeric)
                ->  Sort
-                     Sort Key: pagg_tab_p3.c
-                     ->  Seq Scan on pagg_tab_p3
+                     Sort Key: pagg_tab_2.c
+                     ->  Seq Scan on pagg_tab_p3 pagg_tab_2
 (21 rows)
 
 SELECT c, sum(a), avg(b), count(*) FROM pagg_tab GROUP BY 1 HAVING avg(d) < 15 ORDER BY 1, 2, 3;
@@ -213,30 +213,30 @@ SELECT c, sum(a), avg(b), count(*) FROM pagg_tab GROUP BY 1 HAVING avg(d) < 15 O
 -- When GROUP BY clause does not match; partial aggregation is performed for each partition.
 EXPLAIN (COSTS OFF)
 SELECT a, sum(b), avg(b), count(*) FROM pagg_tab GROUP BY 1 HAVING avg(d) < 15 ORDER BY 1, 2, 3;
-                              QUERY PLAN                               
------------------------------------------------------------------------
+                            QUERY PLAN                            
+------------------------------------------------------------------
  Sort
-   Sort Key: pagg_tab_p1.a, (sum(pagg_tab_p1.b)), (avg(pagg_tab_p1.b))
+   Sort Key: pagg_tab.a, (sum(pagg_tab.b)), (avg(pagg_tab.b))
    ->  Finalize GroupAggregate
-         Group Key: pagg_tab_p1.a
-         Filter: (avg(pagg_tab_p1.d) < '15'::numeric)
+         Group Key: pagg_tab.a
+         Filter: (avg(pagg_tab.d) < '15'::numeric)
          ->  Merge Append
-               Sort Key: pagg_tab_p1.a
+               Sort Key: pagg_tab.a
                ->  Partial GroupAggregate
-                     Group Key: pagg_tab_p1.a
+                     Group Key: pagg_tab.a
                      ->  Sort
-                           Sort Key: pagg_tab_p1.a
-                           ->  Seq Scan on pagg_tab_p1
+                           Sort Key: pagg_tab.a
+                           ->  Seq Scan on pagg_tab_p1 pagg_tab
                ->  Partial GroupAggregate
-                     Group Key: pagg_tab_p2.a
+                     Group Key: pagg_tab_1.a
                      ->  Sort
-                           Sort Key: pagg_tab_p2.a
-                           ->  Seq Scan on pagg_tab_p2
+                           Sort Key: pagg_tab_1.a
+                           ->  Seq Scan on pagg_tab_p2 pagg_tab_1
                ->  Partial GroupAggregate
-                     Group Key: pagg_tab_p3.a
+                     Group Key: pagg_tab_2.a
                      ->  Sort
-                           Sort Key: pagg_tab_p3.a
-                           ->  Seq Scan on pagg_tab_p3
+                           Sort Key: pagg_tab_2.a
+                           ->  Seq Scan on pagg_tab_p3 pagg_tab_2
 (22 rows)
 
 SELECT a, sum(b), avg(b), count(*) FROM pagg_tab GROUP BY 1 HAVING avg(d) < 15 ORDER BY 1, 2, 3;
@@ -257,25 +257,25 @@ SELECT a, sum(b), avg(b), count(*) FROM pagg_tab GROUP BY 1 HAVING avg(d) < 15 O
 -- Test partitionwise grouping without any aggregates
 EXPLAIN (COSTS OFF)
 SELECT c FROM pagg_tab GROUP BY c ORDER BY 1;
-                QUERY PLAN                 
--------------------------------------------
+                      QUERY PLAN                      
+------------------------------------------------------
  Merge Append
-   Sort Key: pagg_tab_p1.c
+   Sort Key: pagg_tab.c
    ->  Group
-         Group Key: pagg_tab_p1.c
+         Group Key: pagg_tab.c
          ->  Sort
-               Sort Key: pagg_tab_p1.c
-               ->  Seq Scan on pagg_tab_p1
+               Sort Key: pagg_tab.c
+               ->  Seq Scan on pagg_tab_p1 pagg_tab
    ->  Group
-         Group Key: pagg_tab_p2.c
+         Group Key: pagg_tab_1.c
          ->  Sort
-               Sort Key: pagg_tab_p2.c
-               ->  Seq Scan on pagg_tab_p2
+               Sort Key: pagg_tab_1.c
+               ->  Seq Scan on pagg_tab_p2 pagg_tab_1
    ->  Group
-         Group Key: pagg_tab_p3.c
+         Group Key: pagg_tab_2.c
          ->  Sort
-               Sort Key: pagg_tab_p3.c
-               ->  Seq Scan on pagg_tab_p3
+               Sort Key: pagg_tab_2.c
+               ->  Seq Scan on pagg_tab_p3 pagg_tab_2
 (17 rows)
 
 SELECT c FROM pagg_tab GROUP BY c ORDER BY 1;
@@ -297,29 +297,29 @@ SELECT c FROM pagg_tab GROUP BY c ORDER BY 1;
 
 EXPLAIN (COSTS OFF)
 SELECT a FROM pagg_tab WHERE a < 3 GROUP BY a ORDER BY 1;
-                   QUERY PLAN                    
--------------------------------------------------
+                         QUERY PLAN                         
+------------------------------------------------------------
  Group
-   Group Key: pagg_tab_p1.a
+   Group Key: pagg_tab.a
    ->  Merge Append
-         Sort Key: pagg_tab_p1.a
+         Sort Key: pagg_tab.a
          ->  Group
-               Group Key: pagg_tab_p1.a
+               Group Key: pagg_tab.a
                ->  Sort
-                     Sort Key: pagg_tab_p1.a
-                     ->  Seq Scan on pagg_tab_p1
+                     Sort Key: pagg_tab.a
+                     ->  Seq Scan on pagg_tab_p1 pagg_tab
                            Filter: (a < 3)
          ->  Group
-               Group Key: pagg_tab_p2.a
+               Group Key: pagg_tab_1.a
                ->  Sort
-                     Sort Key: pagg_tab_p2.a
-                     ->  Seq Scan on pagg_tab_p2
+                     Sort Key: pagg_tab_1.a
+                     ->  Seq Scan on pagg_tab_p2 pagg_tab_1
                            Filter: (a < 3)
          ->  Group
-               Group Key: pagg_tab_p3.a
+               Group Key: pagg_tab_2.a
                ->  Sort
-                     Sort Key: pagg_tab_p3.a
-                     ->  Seq Scan on pagg_tab_p3
+                     Sort Key: pagg_tab_2.a
+                     ->  Seq Scan on pagg_tab_p3 pagg_tab_2
                            Filter: (a < 3)
 (22 rows)
 
@@ -335,17 +335,17 @@ RESET enable_hashagg;
 -- ROLLUP, partitionwise aggregation does not apply
 EXPLAIN (COSTS OFF)
 SELECT c, sum(a) FROM pagg_tab GROUP BY rollup(c) ORDER BY 1, 2;
-                   QUERY PLAN                    
--------------------------------------------------
+                      QUERY PLAN                      
+------------------------------------------------------
  Sort
-   Sort Key: pagg_tab_p1.c, (sum(pagg_tab_p1.a))
+   Sort Key: pagg_tab.c, (sum(pagg_tab.a))
    ->  MixedAggregate
-         Hash Key: pagg_tab_p1.c
+         Hash Key: pagg_tab.c
          Group Key: ()
          ->  Append
-               ->  Seq Scan on pagg_tab_p1
-               ->  Seq Scan on pagg_tab_p2
-               ->  Seq Scan on pagg_tab_p3
+               ->  Seq Scan on pagg_tab_p1 pagg_tab
+               ->  Seq Scan on pagg_tab_p2 pagg_tab_1
+               ->  Seq Scan on pagg_tab_p3 pagg_tab_2
 (9 rows)
 
 -- ORDERED SET within the aggregate.
@@ -354,26 +354,26 @@ SELECT c, sum(a) FROM pagg_tab GROUP BY rollup(c) ORDER BY 1, 2;
 -- make any difference.
 EXPLAIN (COSTS OFF)
 SELECT c, sum(b order by a) FROM pagg_tab GROUP BY c ORDER BY 1, 2;
-                               QUERY PLAN                               
-------------------------------------------------------------------------
+                          QUERY PLAN                           
+---------------------------------------------------------------
  Sort
-   Sort Key: pagg_tab_p1.c, (sum(pagg_tab_p1.b ORDER BY pagg_tab_p1.a))
+   Sort Key: pagg_tab.c, (sum(pagg_tab.b ORDER BY pagg_tab.a))
    ->  Append
          ->  GroupAggregate
-               Group Key: pagg_tab_p1.c
+               Group Key: pagg_tab.c
                ->  Sort
-                     Sort Key: pagg_tab_p1.c
-                     ->  Seq Scan on pagg_tab_p1
+                     Sort Key: pagg_tab.c
+                     ->  Seq Scan on pagg_tab_p1 pagg_tab
          ->  GroupAggregate
-               Group Key: pagg_tab_p2.c
+               Group Key: pagg_tab_1.c
                ->  Sort
-                     Sort Key: pagg_tab_p2.c
-                     ->  Seq Scan on pagg_tab_p2
+                     Sort Key: pagg_tab_1.c
+                     ->  Seq Scan on pagg_tab_p2 pagg_tab_1
          ->  GroupAggregate
-               Group Key: pagg_tab_p3.c
+               Group Key: pagg_tab_2.c
                ->  Sort
-                     Sort Key: pagg_tab_p3.c
-                     ->  Seq Scan on pagg_tab_p3
+                     Sort Key: pagg_tab_2.c
+                     ->  Seq Scan on pagg_tab_p3 pagg_tab_2
 (18 rows)
 
 -- Since GROUP BY clause does not match with PARTITION KEY; we need to do
@@ -381,18 +381,18 @@ SELECT c, sum(b order by a) FROM pagg_tab GROUP BY c ORDER BY 1, 2;
 -- partitionwise aggregation plan is not generated.
 EXPLAIN (COSTS OFF)
 SELECT a, sum(b order by a) FROM pagg_tab GROUP BY a ORDER BY 1, 2;
-                               QUERY PLAN                               
-------------------------------------------------------------------------
+                          QUERY PLAN                           
+---------------------------------------------------------------
  Sort
-   Sort Key: pagg_tab_p1.a, (sum(pagg_tab_p1.b ORDER BY pagg_tab_p1.a))
+   Sort Key: pagg_tab.a, (sum(pagg_tab.b ORDER BY pagg_tab.a))
    ->  GroupAggregate
-         Group Key: pagg_tab_p1.a
+         Group Key: pagg_tab.a
          ->  Sort
-               Sort Key: pagg_tab_p1.a
+               Sort Key: pagg_tab.a
                ->  Append
-                     ->  Seq Scan on pagg_tab_p1
-                     ->  Seq Scan on pagg_tab_p2
-                     ->  Seq Scan on pagg_tab_p3
+                     ->  Seq Scan on pagg_tab_p1 pagg_tab
+                     ->  Seq Scan on pagg_tab_p2 pagg_tab_1
+                     ->  Seq Scan on pagg_tab_p3 pagg_tab_2
 (10 rows)
 
 -- JOIN query
@@ -722,25 +722,25 @@ SELECT a.x, sum(b.x) FROM pagg_tab1 a FULL OUTER JOIN pagg_tab2 b ON a.x = b.y G
 -- But right now we are unable to do partitionwise join in this case.
 EXPLAIN (COSTS OFF)
 SELECT a.x, b.y, count(*) FROM (SELECT * FROM pagg_tab1 WHERE x < 20) a LEFT JOIN (SELECT * FROM pagg_tab2 WHERE y > 10) b ON a.x = b.y WHERE a.x > 5 or b.y < 20  GROUP BY a.x, b.y ORDER BY 1, 2;
-                              QUERY PLAN                               
------------------------------------------------------------------------
+                             QUERY PLAN                             
+--------------------------------------------------------------------
  Sort
-   Sort Key: pagg_tab1_p1.x, pagg_tab2_p2.y
+   Sort Key: pagg_tab1.x, pagg_tab2.y
    ->  HashAggregate
-         Group Key: pagg_tab1_p1.x, pagg_tab2_p2.y
+         Group Key: pagg_tab1.x, pagg_tab2.y
          ->  Hash Left Join
-               Hash Cond: (pagg_tab1_p1.x = pagg_tab2_p2.y)
-               Filter: ((pagg_tab1_p1.x > 5) OR (pagg_tab2_p2.y < 20))
+               Hash Cond: (pagg_tab1.x = pagg_tab2.y)
+               Filter: ((pagg_tab1.x > 5) OR (pagg_tab2.y < 20))
                ->  Append
-                     ->  Seq Scan on pagg_tab1_p1
+                     ->  Seq Scan on pagg_tab1_p1 pagg_tab1
                            Filter: (x < 20)
-                     ->  Seq Scan on pagg_tab1_p2
+                     ->  Seq Scan on pagg_tab1_p2 pagg_tab1_1
                            Filter: (x < 20)
                ->  Hash
                      ->  Append
-                           ->  Seq Scan on pagg_tab2_p2
+                           ->  Seq Scan on pagg_tab2_p2 pagg_tab2
                                  Filter: (y > 10)
-                           ->  Seq Scan on pagg_tab2_p3
+                           ->  Seq Scan on pagg_tab2_p3 pagg_tab2_1
                                  Filter: (y > 10)
 (18 rows)
 
@@ -762,25 +762,25 @@ SELECT a.x, b.y, count(*) FROM (SELECT * FROM pagg_tab1 WHERE x < 20) a LEFT JOI
 -- But right now we are unable to do partitionwise join in this case.
 EXPLAIN (COSTS OFF)
 SELECT a.x, b.y, count(*) FROM (SELECT * FROM pagg_tab1 WHERE x < 20) a FULL JOIN (SELECT * FROM pagg_tab2 WHERE y > 10) b ON a.x = b.y WHERE a.x > 5 or b.y < 20  GROUP BY a.x, b.y ORDER BY 1, 2;
-                              QUERY PLAN                               
------------------------------------------------------------------------
+                             QUERY PLAN                             
+--------------------------------------------------------------------
  Sort
-   Sort Key: pagg_tab1_p1.x, pagg_tab2_p2.y
+   Sort Key: pagg_tab1.x, pagg_tab2.y
    ->  HashAggregate
-         Group Key: pagg_tab1_p1.x, pagg_tab2_p2.y
+         Group Key: pagg_tab1.x, pagg_tab2.y
          ->  Hash Full Join
-               Hash Cond: (pagg_tab1_p1.x = pagg_tab2_p2.y)
-               Filter: ((pagg_tab1_p1.x > 5) OR (pagg_tab2_p2.y < 20))
+               Hash Cond: (pagg_tab1.x = pagg_tab2.y)
+               Filter: ((pagg_tab1.x > 5) OR (pagg_tab2.y < 20))
                ->  Append
-                     ->  Seq Scan on pagg_tab1_p1
+                     ->  Seq Scan on pagg_tab1_p1 pagg_tab1
                            Filter: (x < 20)
-                     ->  Seq Scan on pagg_tab1_p2
+                     ->  Seq Scan on pagg_tab1_p2 pagg_tab1_1
                            Filter: (x < 20)
                ->  Hash
                      ->  Append
-                           ->  Seq Scan on pagg_tab2_p2
+                           ->  Seq Scan on pagg_tab2_p2 pagg_tab2
                                  Filter: (y > 10)
-                           ->  Seq Scan on pagg_tab2_p3
+                           ->  Seq Scan on pagg_tab2_p3 pagg_tab2_1
                                  Filter: (y > 10)
 (18 rows)
 
@@ -825,23 +825,23 @@ ANALYZE pagg_tab_m;
 -- Partial aggregation as GROUP BY clause does not match with PARTITION KEY
 EXPLAIN (COSTS OFF)
 SELECT a, sum(b), avg(c), count(*) FROM pagg_tab_m GROUP BY a HAVING avg(c) < 22 ORDER BY 1, 2, 3;
-                                 QUERY PLAN                                  
------------------------------------------------------------------------------
+                             QUERY PLAN                             
+--------------------------------------------------------------------
  Sort
-   Sort Key: pagg_tab_m_p1.a, (sum(pagg_tab_m_p1.b)), (avg(pagg_tab_m_p1.c))
+   Sort Key: pagg_tab_m.a, (sum(pagg_tab_m.b)), (avg(pagg_tab_m.c))
    ->  Finalize HashAggregate
-         Group Key: pagg_tab_m_p1.a
-         Filter: (avg(pagg_tab_m_p1.c) < '22'::numeric)
+         Group Key: pagg_tab_m.a
+         Filter: (avg(pagg_tab_m.c) < '22'::numeric)
          ->  Append
                ->  Partial HashAggregate
-                     Group Key: pagg_tab_m_p1.a
-                     ->  Seq Scan on pagg_tab_m_p1
+                     Group Key: pagg_tab_m.a
+                     ->  Seq Scan on pagg_tab_m_p1 pagg_tab_m
                ->  Partial HashAggregate
-                     Group Key: pagg_tab_m_p2.a
-                     ->  Seq Scan on pagg_tab_m_p2
+                     Group Key: pagg_tab_m_1.a
+                     ->  Seq Scan on pagg_tab_m_p2 pagg_tab_m_1
                ->  Partial HashAggregate
-                     Group Key: pagg_tab_m_p3.a
-                     ->  Seq Scan on pagg_tab_m_p3
+                     Group Key: pagg_tab_m_2.a
+                     ->  Seq Scan on pagg_tab_m_p3 pagg_tab_m_2
 (15 rows)
 
 SELECT a, sum(b), avg(c), count(*) FROM pagg_tab_m GROUP BY a HAVING avg(c) < 22 ORDER BY 1, 2, 3;
@@ -858,23 +858,23 @@ SELECT a, sum(b), avg(c), count(*) FROM pagg_tab_m GROUP BY a HAVING avg(c) < 22
 -- Full aggregation as GROUP BY clause matches with PARTITION KEY
 EXPLAIN (COSTS OFF)
 SELECT a, sum(b), avg(c), count(*) FROM pagg_tab_m GROUP BY a, (a+b)/2 HAVING sum(b) < 50 ORDER BY 1, 2, 3;
-                                     QUERY PLAN                                      
--------------------------------------------------------------------------------------
+                                    QUERY PLAN                                    
+----------------------------------------------------------------------------------
  Sort
-   Sort Key: pagg_tab_m_p1.a, (sum(pagg_tab_m_p1.b)), (avg(pagg_tab_m_p1.c))
+   Sort Key: pagg_tab_m.a, (sum(pagg_tab_m.b)), (avg(pagg_tab_m.c))
    ->  Append
          ->  HashAggregate
-               Group Key: pagg_tab_m_p1.a, ((pagg_tab_m_p1.a + pagg_tab_m_p1.b) / 2)
-               Filter: (sum(pagg_tab_m_p1.b) < 50)
-               ->  Seq Scan on pagg_tab_m_p1
+               Group Key: pagg_tab_m.a, ((pagg_tab_m.a + pagg_tab_m.b) / 2)
+               Filter: (sum(pagg_tab_m.b) < 50)
+               ->  Seq Scan on pagg_tab_m_p1 pagg_tab_m
          ->  HashAggregate
-               Group Key: pagg_tab_m_p2.a, ((pagg_tab_m_p2.a + pagg_tab_m_p2.b) / 2)
-               Filter: (sum(pagg_tab_m_p2.b) < 50)
-               ->  Seq Scan on pagg_tab_m_p2
+               Group Key: pagg_tab_m_1.a, ((pagg_tab_m_1.a + pagg_tab_m_1.b) / 2)
+               Filter: (sum(pagg_tab_m_1.b) < 50)
+               ->  Seq Scan on pagg_tab_m_p2 pagg_tab_m_1
          ->  HashAggregate
-               Group Key: pagg_tab_m_p3.a, ((pagg_tab_m_p3.a + pagg_tab_m_p3.b) / 2)
-               Filter: (sum(pagg_tab_m_p3.b) < 50)
-               ->  Seq Scan on pagg_tab_m_p3
+               Group Key: pagg_tab_m_2.a, ((pagg_tab_m_2.a + pagg_tab_m_2.b) / 2)
+               Filter: (sum(pagg_tab_m_2.b) < 50)
+               ->  Seq Scan on pagg_tab_m_p3 pagg_tab_m_2
 (15 rows)
 
 SELECT a, sum(b), avg(c), count(*) FROM pagg_tab_m GROUP BY a, (a+b)/2 HAVING sum(b) < 50 ORDER BY 1, 2, 3;
@@ -891,23 +891,23 @@ SELECT a, sum(b), avg(c), count(*) FROM pagg_tab_m GROUP BY a, (a+b)/2 HAVING su
 -- Full aggregation as PARTITION KEY is part of GROUP BY clause
 EXPLAIN (COSTS OFF)
 SELECT a, c, sum(b), avg(c), count(*) FROM pagg_tab_m GROUP BY (a+b)/2, 2, 1 HAVING sum(b) = 50 AND avg(c) > 25 ORDER BY 1, 2, 3;
-                                              QUERY PLAN                                              
-------------------------------------------------------------------------------------------------------
+                                            QUERY PLAN                                            
+--------------------------------------------------------------------------------------------------
  Sort
-   Sort Key: pagg_tab_m_p1.a, pagg_tab_m_p1.c, (sum(pagg_tab_m_p1.b))
+   Sort Key: pagg_tab_m.a, pagg_tab_m.c, (sum(pagg_tab_m.b))
    ->  Append
          ->  HashAggregate
-               Group Key: ((pagg_tab_m_p1.a + pagg_tab_m_p1.b) / 2), pagg_tab_m_p1.c, pagg_tab_m_p1.a
-               Filter: ((sum(pagg_tab_m_p1.b) = 50) AND (avg(pagg_tab_m_p1.c) > '25'::numeric))
-               ->  Seq Scan on pagg_tab_m_p1
+               Group Key: ((pagg_tab_m.a + pagg_tab_m.b) / 2), pagg_tab_m.c, pagg_tab_m.a
+               Filter: ((sum(pagg_tab_m.b) = 50) AND (avg(pagg_tab_m.c) > '25'::numeric))
+               ->  Seq Scan on pagg_tab_m_p1 pagg_tab_m
          ->  HashAggregate
-               Group Key: ((pagg_tab_m_p2.a + pagg_tab_m_p2.b) / 2), pagg_tab_m_p2.c, pagg_tab_m_p2.a
-               Filter: ((sum(pagg_tab_m_p2.b) = 50) AND (avg(pagg_tab_m_p2.c) > '25'::numeric))
-               ->  Seq Scan on pagg_tab_m_p2
+               Group Key: ((pagg_tab_m_1.a + pagg_tab_m_1.b) / 2), pagg_tab_m_1.c, pagg_tab_m_1.a
+               Filter: ((sum(pagg_tab_m_1.b) = 50) AND (avg(pagg_tab_m_1.c) > '25'::numeric))
+               ->  Seq Scan on pagg_tab_m_p2 pagg_tab_m_1
          ->  HashAggregate
-               Group Key: ((pagg_tab_m_p3.a + pagg_tab_m_p3.b) / 2), pagg_tab_m_p3.c, pagg_tab_m_p3.a
-               Filter: ((sum(pagg_tab_m_p3.b) = 50) AND (avg(pagg_tab_m_p3.c) > '25'::numeric))
-               ->  Seq Scan on pagg_tab_m_p3
+               Group Key: ((pagg_tab_m_2.a + pagg_tab_m_2.b) / 2), pagg_tab_m_2.c, pagg_tab_m_2.a
+               Filter: ((sum(pagg_tab_m_2.b) = 50) AND (avg(pagg_tab_m_2.c) > '25'::numeric))
+               ->  Seq Scan on pagg_tab_m_p3 pagg_tab_m_2
 (15 rows)
 
 SELECT a, c, sum(b), avg(c), count(*) FROM pagg_tab_m GROUP BY (a+b)/2, 2, 1 HAVING sum(b) = 50 AND avg(c) > 25 ORDER BY 1, 2, 3;
@@ -943,35 +943,35 @@ SET max_parallel_workers_per_gather TO 2;
 -- is not partial agg safe.
 EXPLAIN (COSTS OFF)
 SELECT a, sum(b), array_agg(distinct c), count(*) FROM pagg_tab_ml GROUP BY a HAVING avg(b) < 3 ORDER BY 1, 2, 3;
-                                               QUERY PLAN                                               
---------------------------------------------------------------------------------------------------------
+                                         QUERY PLAN                                         
+--------------------------------------------------------------------------------------------
  Sort
-   Sort Key: pagg_tab_ml_p2_s1.a, (sum(pagg_tab_ml_p2_s1.b)), (array_agg(DISTINCT pagg_tab_ml_p2_s1.c))
+   Sort Key: pagg_tab_ml_1.a, (sum(pagg_tab_ml_1.b)), (array_agg(DISTINCT pagg_tab_ml_1.c))
    ->  Gather
          Workers Planned: 2
          ->  Parallel Append
                ->  GroupAggregate
-                     Group Key: pagg_tab_ml_p2_s1.a
-                     Filter: (avg(pagg_tab_ml_p2_s1.b) < '3'::numeric)
+                     Group Key: pagg_tab_ml_1.a
+                     Filter: (avg(pagg_tab_ml_1.b) < '3'::numeric)
                      ->  Sort
-                           Sort Key: pagg_tab_ml_p2_s1.a
+                           Sort Key: pagg_tab_ml_1.a
                            ->  Append
-                                 ->  Seq Scan on pagg_tab_ml_p2_s1
-                                 ->  Seq Scan on pagg_tab_ml_p2_s2
+                                 ->  Seq Scan on pagg_tab_ml_p2_s1 pagg_tab_ml_1
+                                 ->  Seq Scan on pagg_tab_ml_p2_s2 pagg_tab_ml_2
                ->  GroupAggregate
-                     Group Key: pagg_tab_ml_p3_s1.a
-                     Filter: (avg(pagg_tab_ml_p3_s1.b) < '3'::numeric)
+                     Group Key: pagg_tab_ml_3.a
+                     Filter: (avg(pagg_tab_ml_3.b) < '3'::numeric)
                      ->  Sort
-                           Sort Key: pagg_tab_ml_p3_s1.a
+                           Sort Key: pagg_tab_ml_3.a
                            ->  Append
-                                 ->  Seq Scan on pagg_tab_ml_p3_s1
-                                 ->  Seq Scan on pagg_tab_ml_p3_s2
+                                 ->  Seq Scan on pagg_tab_ml_p3_s1 pagg_tab_ml_3
+                                 ->  Seq Scan on pagg_tab_ml_p3_s2 pagg_tab_ml_4
                ->  GroupAggregate
-                     Group Key: pagg_tab_ml_p1.a
-                     Filter: (avg(pagg_tab_ml_p1.b) < '3'::numeric)
+                     Group Key: pagg_tab_ml.a
+                     Filter: (avg(pagg_tab_ml.b) < '3'::numeric)
                      ->  Sort
-                           Sort Key: pagg_tab_ml_p1.a
-                           ->  Seq Scan on pagg_tab_ml_p1
+                           Sort Key: pagg_tab_ml.a
+                           ->  Seq Scan on pagg_tab_ml_p1 pagg_tab_ml
 (27 rows)
 
 SELECT a, sum(b), array_agg(distinct c), count(*) FROM pagg_tab_ml GROUP BY a HAVING avg(b) < 3 ORDER BY 1, 2, 3;
@@ -991,33 +991,33 @@ SELECT a, sum(b), array_agg(distinct c), count(*) FROM pagg_tab_ml GROUP BY a HA
 -- Without ORDER BY clause, to test Gather at top-most path
 EXPLAIN (COSTS OFF)
 SELECT a, sum(b), array_agg(distinct c), count(*) FROM pagg_tab_ml GROUP BY a HAVING avg(b) < 3;
-                           QUERY PLAN                            
------------------------------------------------------------------
+                                QUERY PLAN                                 
+---------------------------------------------------------------------------
  Gather
    Workers Planned: 2
    ->  Parallel Append
          ->  GroupAggregate
-               Group Key: pagg_tab_ml_p2_s1.a
-               Filter: (avg(pagg_tab_ml_p2_s1.b) < '3'::numeric)
+               Group Key: pagg_tab_ml_1.a
+               Filter: (avg(pagg_tab_ml_1.b) < '3'::numeric)
                ->  Sort
-                     Sort Key: pagg_tab_ml_p2_s1.a
+                     Sort Key: pagg_tab_ml_1.a
                      ->  Append
-                           ->  Seq Scan on pagg_tab_ml_p2_s1
-                           ->  Seq Scan on pagg_tab_ml_p2_s2
+                           ->  Seq Scan on pagg_tab_ml_p2_s1 pagg_tab_ml_1
+                           ->  Seq Scan on pagg_tab_ml_p2_s2 pagg_tab_ml_2
          ->  GroupAggregate
-               Group Key: pagg_tab_ml_p3_s1.a
-               Filter: (avg(pagg_tab_ml_p3_s1.b) < '3'::numeric)
+               Group Key: pagg_tab_ml_3.a
+               Filter: (avg(pagg_tab_ml_3.b) < '3'::numeric)
                ->  Sort
-                     Sort Key: pagg_tab_ml_p3_s1.a
+                     Sort Key: pagg_tab_ml_3.a
                      ->  Append
-                           ->  Seq Scan on pagg_tab_ml_p3_s1
-                           ->  Seq Scan on pagg_tab_ml_p3_s2
+                           ->  Seq Scan on pagg_tab_ml_p3_s1 pagg_tab_ml_3
+                           ->  Seq Scan on pagg_tab_ml_p3_s2 pagg_tab_ml_4
          ->  GroupAggregate
-               Group Key: pagg_tab_ml_p1.a
-               Filter: (avg(pagg_tab_ml_p1.b) < '3'::numeric)
+               Group Key: pagg_tab_ml.a
+               Filter: (avg(pagg_tab_ml.b) < '3'::numeric)
                ->  Sort
-                     Sort Key: pagg_tab_ml_p1.a
-                     ->  Seq Scan on pagg_tab_ml_p1
+                     Sort Key: pagg_tab_ml.a
+                     ->  Seq Scan on pagg_tab_ml_p1 pagg_tab_ml
 (25 rows)
 
 -- Full aggregation at level 1 as GROUP BY clause matches with PARTITION KEY
@@ -1025,39 +1025,39 @@ SELECT a, sum(b), array_agg(distinct c), count(*) FROM pagg_tab_ml GROUP BY a HA
 -- PARTITION KEY, thus we will have a partial aggregation for them.
 EXPLAIN (COSTS OFF)
 SELECT a, sum(b), count(*) FROM pagg_tab_ml GROUP BY a HAVING avg(b) < 3 ORDER BY 1, 2, 3;
-                            QUERY PLAN                             
--------------------------------------------------------------------
+                                   QUERY PLAN                                    
+---------------------------------------------------------------------------------
  Sort
-   Sort Key: pagg_tab_ml_p1.a, (sum(pagg_tab_ml_p1.b)), (count(*))
+   Sort Key: pagg_tab_ml.a, (sum(pagg_tab_ml.b)), (count(*))
    ->  Append
          ->  HashAggregate
-               Group Key: pagg_tab_ml_p1.a
-               Filter: (avg(pagg_tab_ml_p1.b) < '3'::numeric)
-               ->  Seq Scan on pagg_tab_ml_p1
+               Group Key: pagg_tab_ml.a
+               Filter: (avg(pagg_tab_ml.b) < '3'::numeric)
+               ->  Seq Scan on pagg_tab_ml_p1 pagg_tab_ml
          ->  Finalize GroupAggregate
-               Group Key: pagg_tab_ml_p2_s1.a
-               Filter: (avg(pagg_tab_ml_p2_s1.b) < '3'::numeric)
+               Group Key: pagg_tab_ml_1.a
+               Filter: (avg(pagg_tab_ml_1.b) < '3'::numeric)
                ->  Sort
-                     Sort Key: pagg_tab_ml_p2_s1.a
+                     Sort Key: pagg_tab_ml_1.a
                      ->  Append
                            ->  Partial HashAggregate
-                                 Group Key: pagg_tab_ml_p2_s1.a
-                                 ->  Seq Scan on pagg_tab_ml_p2_s1
+                                 Group Key: pagg_tab_ml_1.a
+                                 ->  Seq Scan on pagg_tab_ml_p2_s1 pagg_tab_ml_1
                            ->  Partial HashAggregate
-                                 Group Key: pagg_tab_ml_p2_s2.a
-                                 ->  Seq Scan on pagg_tab_ml_p2_s2
+                                 Group Key: pagg_tab_ml_2.a
+                                 ->  Seq Scan on pagg_tab_ml_p2_s2 pagg_tab_ml_2
          ->  Finalize GroupAggregate
-               Group Key: pagg_tab_ml_p3_s1.a
-               Filter: (avg(pagg_tab_ml_p3_s1.b) < '3'::numeric)
+               Group Key: pagg_tab_ml_3.a
+               Filter: (avg(pagg_tab_ml_3.b) < '3'::numeric)
                ->  Sort
-                     Sort Key: pagg_tab_ml_p3_s1.a
+                     Sort Key: pagg_tab_ml_3.a
                      ->  Append
                            ->  Partial HashAggregate
-                                 Group Key: pagg_tab_ml_p3_s1.a
-                                 ->  Seq Scan on pagg_tab_ml_p3_s1
+                                 Group Key: pagg_tab_ml_3.a
+                                 ->  Seq Scan on pagg_tab_ml_p3_s1 pagg_tab_ml_3
                            ->  Partial HashAggregate
-                                 Group Key: pagg_tab_ml_p3_s2.a
-                                 ->  Seq Scan on pagg_tab_ml_p3_s2
+                                 Group Key: pagg_tab_ml_4.a
+                                 ->  Seq Scan on pagg_tab_ml_p3_s2 pagg_tab_ml_4
 (31 rows)
 
 SELECT a, sum(b), count(*) FROM pagg_tab_ml GROUP BY a HAVING avg(b) < 3 ORDER BY 1, 2, 3;
@@ -1078,30 +1078,30 @@ SELECT a, sum(b), count(*) FROM pagg_tab_ml GROUP BY a HAVING avg(b) < 3 ORDER B
 -- PARTITION KEY
 EXPLAIN (COSTS OFF)
 SELECT b, sum(a), count(*) FROM pagg_tab_ml GROUP BY b ORDER BY 1, 2, 3;
-                            QUERY PLAN                             
--------------------------------------------------------------------
+                                QUERY PLAN                                 
+---------------------------------------------------------------------------
  Sort
-   Sort Key: pagg_tab_ml_p1.b, (sum(pagg_tab_ml_p1.a)), (count(*))
+   Sort Key: pagg_tab_ml.b, (sum(pagg_tab_ml.a)), (count(*))
    ->  Finalize GroupAggregate
-         Group Key: pagg_tab_ml_p1.b
+         Group Key: pagg_tab_ml.b
          ->  Sort
-               Sort Key: pagg_tab_ml_p1.b
+               Sort Key: pagg_tab_ml.b
                ->  Append
                      ->  Partial HashAggregate
-                           Group Key: pagg_tab_ml_p1.b
-                           ->  Seq Scan on pagg_tab_ml_p1
+                           Group Key: pagg_tab_ml.b
+                           ->  Seq Scan on pagg_tab_ml_p1 pagg_tab_ml
                      ->  Partial HashAggregate
-                           Group Key: pagg_tab_ml_p2_s1.b
-                           ->  Seq Scan on pagg_tab_ml_p2_s1
+                           Group Key: pagg_tab_ml_1.b
+                           ->  Seq Scan on pagg_tab_ml_p2_s1 pagg_tab_ml_1
                      ->  Partial HashAggregate
-                           Group Key: pagg_tab_ml_p2_s2.b
-                           ->  Seq Scan on pagg_tab_ml_p2_s2
+                           Group Key: pagg_tab_ml_2.b
+                           ->  Seq Scan on pagg_tab_ml_p2_s2 pagg_tab_ml_2
                      ->  Partial HashAggregate
-                           Group Key: pagg_tab_ml_p3_s1.b
-                           ->  Seq Scan on pagg_tab_ml_p3_s1
+                           Group Key: pagg_tab_ml_3.b
+                           ->  Seq Scan on pagg_tab_ml_p3_s1 pagg_tab_ml_3
                      ->  Partial HashAggregate
-                           Group Key: pagg_tab_ml_p3_s2.b
-                           ->  Seq Scan on pagg_tab_ml_p3_s2
+                           Group Key: pagg_tab_ml_4.b
+                           ->  Seq Scan on pagg_tab_ml_p3_s2 pagg_tab_ml_4
 (22 rows)
 
 SELECT b, sum(a), count(*) FROM pagg_tab_ml GROUP BY b HAVING avg(a) < 15 ORDER BY 1, 2, 3;
@@ -1117,31 +1117,31 @@ SELECT b, sum(a), count(*) FROM pagg_tab_ml GROUP BY b HAVING avg(a) < 15 ORDER
 -- Full aggregation at all levels as GROUP BY clause matches with PARTITION KEY
 EXPLAIN (COSTS OFF)
 SELECT a, sum(b), count(*) FROM pagg_tab_ml GROUP BY a, b, c HAVING avg(b) > 7 ORDER BY 1, 2, 3;
-                                       QUERY PLAN                                       
-----------------------------------------------------------------------------------------
+                                 QUERY PLAN                                 
+----------------------------------------------------------------------------
  Sort
-   Sort Key: pagg_tab_ml_p1.a, (sum(pagg_tab_ml_p1.b)), (count(*))
+   Sort Key: pagg_tab_ml.a, (sum(pagg_tab_ml.b)), (count(*))
    ->  Append
          ->  HashAggregate
-               Group Key: pagg_tab_ml_p1.a, pagg_tab_ml_p1.b, pagg_tab_ml_p1.c
-               Filter: (avg(pagg_tab_ml_p1.b) > '7'::numeric)
-               ->  Seq Scan on pagg_tab_ml_p1
+               Group Key: pagg_tab_ml.a, pagg_tab_ml.b, pagg_tab_ml.c
+               Filter: (avg(pagg_tab_ml.b) > '7'::numeric)
+               ->  Seq Scan on pagg_tab_ml_p1 pagg_tab_ml
          ->  HashAggregate
-               Group Key: pagg_tab_ml_p2_s1.a, pagg_tab_ml_p2_s1.b, pagg_tab_ml_p2_s1.c
-               Filter: (avg(pagg_tab_ml_p2_s1.b) > '7'::numeric)
-               ->  Seq Scan on pagg_tab_ml_p2_s1
+               Group Key: pagg_tab_ml_1.a, pagg_tab_ml_1.b, pagg_tab_ml_1.c
+               Filter: (avg(pagg_tab_ml_1.b) > '7'::numeric)
+               ->  Seq Scan on pagg_tab_ml_p2_s1 pagg_tab_ml_1
          ->  HashAggregate
-               Group Key: pagg_tab_ml_p2_s2.a, pagg_tab_ml_p2_s2.b, pagg_tab_ml_p2_s2.c
-               Filter: (avg(pagg_tab_ml_p2_s2.b) > '7'::numeric)
-               ->  Seq Scan on pagg_tab_ml_p2_s2
+               Group Key: pagg_tab_ml_2.a, pagg_tab_ml_2.b, pagg_tab_ml_2.c
+               Filter: (avg(pagg_tab_ml_2.b) > '7'::numeric)
+               ->  Seq Scan on pagg_tab_ml_p2_s2 pagg_tab_ml_2
          ->  HashAggregate
-               Group Key: pagg_tab_ml_p3_s1.a, pagg_tab_ml_p3_s1.b, pagg_tab_ml_p3_s1.c
-               Filter: (avg(pagg_tab_ml_p3_s1.b) > '7'::numeric)
-               ->  Seq Scan on pagg_tab_ml_p3_s1
+               Group Key: pagg_tab_ml_3.a, pagg_tab_ml_3.b, pagg_tab_ml_3.c
+               Filter: (avg(pagg_tab_ml_3.b) > '7'::numeric)
+               ->  Seq Scan on pagg_tab_ml_p3_s1 pagg_tab_ml_3
          ->  HashAggregate
-               Group Key: pagg_tab_ml_p3_s2.a, pagg_tab_ml_p3_s2.b, pagg_tab_ml_p3_s2.c
-               Filter: (avg(pagg_tab_ml_p3_s2.b) > '7'::numeric)
-               ->  Seq Scan on pagg_tab_ml_p3_s2
+               Group Key: pagg_tab_ml_4.a, pagg_tab_ml_4.b, pagg_tab_ml_4.c
+               Filter: (avg(pagg_tab_ml_4.b) > '7'::numeric)
+               ->  Seq Scan on pagg_tab_ml_p3_s2 pagg_tab_ml_4
 (23 rows)
 
 SELECT a, sum(b), count(*) FROM pagg_tab_ml GROUP BY a, b, c HAVING avg(b) > 7 ORDER BY 1, 2, 3;
@@ -1169,49 +1169,49 @@ SET parallel_setup_cost TO 0;
 -- PARTITION KEY, thus we will have a partial aggregation for them.
 EXPLAIN (COSTS OFF)
 SELECT a, sum(b), count(*) FROM pagg_tab_ml GROUP BY a HAVING avg(b) < 3 ORDER BY 1, 2, 3;
-                                    QUERY PLAN                                    
-----------------------------------------------------------------------------------
+                                           QUERY PLAN                                           
+------------------------------------------------------------------------------------------------
  Sort
-   Sort Key: pagg_tab_ml_p1.a, (sum(pagg_tab_ml_p1.b)), (count(*))
+   Sort Key: pagg_tab_ml.a, (sum(pagg_tab_ml.b)), (count(*))
    ->  Append
          ->  Finalize GroupAggregate
-               Group Key: pagg_tab_ml_p1.a
-               Filter: (avg(pagg_tab_ml_p1.b) < '3'::numeric)
+               Group Key: pagg_tab_ml.a
+               Filter: (avg(pagg_tab_ml.b) < '3'::numeric)
                ->  Gather Merge
                      Workers Planned: 2
                      ->  Sort
-                           Sort Key: pagg_tab_ml_p1.a
+                           Sort Key: pagg_tab_ml.a
                            ->  Partial HashAggregate
-                                 Group Key: pagg_tab_ml_p1.a
-                                 ->  Parallel Seq Scan on pagg_tab_ml_p1
+                                 Group Key: pagg_tab_ml.a
+                                 ->  Parallel Seq Scan on pagg_tab_ml_p1 pagg_tab_ml
          ->  Finalize GroupAggregate
-               Group Key: pagg_tab_ml_p2_s1.a
-               Filter: (avg(pagg_tab_ml_p2_s1.b) < '3'::numeric)
+               Group Key: pagg_tab_ml_1.a
+               Filter: (avg(pagg_tab_ml_1.b) < '3'::numeric)
                ->  Gather Merge
                      Workers Planned: 2
                      ->  Sort
-                           Sort Key: pagg_tab_ml_p2_s1.a
+                           Sort Key: pagg_tab_ml_1.a
                            ->  Parallel Append
                                  ->  Partial HashAggregate
-                                       Group Key: pagg_tab_ml_p2_s1.a
-                                       ->  Parallel Seq Scan on pagg_tab_ml_p2_s1
+                                       Group Key: pagg_tab_ml_1.a
+                                       ->  Parallel Seq Scan on pagg_tab_ml_p2_s1 pagg_tab_ml_1
                                  ->  Partial HashAggregate
-                                       Group Key: pagg_tab_ml_p2_s2.a
-                                       ->  Parallel Seq Scan on pagg_tab_ml_p2_s2
+                                       Group Key: pagg_tab_ml_2.a
+                                       ->  Parallel Seq Scan on pagg_tab_ml_p2_s2 pagg_tab_ml_2
          ->  Finalize GroupAggregate
-               Group Key: pagg_tab_ml_p3_s1.a
-               Filter: (avg(pagg_tab_ml_p3_s1.b) < '3'::numeric)
+               Group Key: pagg_tab_ml_3.a
+               Filter: (avg(pagg_tab_ml_3.b) < '3'::numeric)
                ->  Gather Merge
                      Workers Planned: 2
                      ->  Sort
-                           Sort Key: pagg_tab_ml_p3_s1.a
+                           Sort Key: pagg_tab_ml_3.a
                            ->  Parallel Append
                                  ->  Partial HashAggregate
-                                       Group Key: pagg_tab_ml_p3_s1.a
-                                       ->  Parallel Seq Scan on pagg_tab_ml_p3_s1
+                                       Group Key: pagg_tab_ml_3.a
+                                       ->  Parallel Seq Scan on pagg_tab_ml_p3_s1 pagg_tab_ml_3
                                  ->  Partial HashAggregate
-                                       Group Key: pagg_tab_ml_p3_s2.a
-                                       ->  Parallel Seq Scan on pagg_tab_ml_p3_s2
+                                       Group Key: pagg_tab_ml_4.a
+                                       ->  Parallel Seq Scan on pagg_tab_ml_p3_s2 pagg_tab_ml_4
 (41 rows)
 
 SELECT a, sum(b), count(*) FROM pagg_tab_ml GROUP BY a HAVING avg(b) < 3 ORDER BY 1, 2, 3;
@@ -1232,32 +1232,32 @@ SELECT a, sum(b), count(*) FROM pagg_tab_ml GROUP BY a HAVING avg(b) < 3 ORDER B
 -- PARTITION KEY
 EXPLAIN (COSTS OFF)
 SELECT b, sum(a), count(*) FROM pagg_tab_ml GROUP BY b ORDER BY 1, 2, 3;
-                                 QUERY PLAN                                 
-----------------------------------------------------------------------------
+                                        QUERY PLAN                                        
+------------------------------------------------------------------------------------------
  Sort
-   Sort Key: pagg_tab_ml_p1.b, (sum(pagg_tab_ml_p1.a)), (count(*))
+   Sort Key: pagg_tab_ml.b, (sum(pagg_tab_ml.a)), (count(*))
    ->  Finalize GroupAggregate
-         Group Key: pagg_tab_ml_p1.b
+         Group Key: pagg_tab_ml.b
          ->  Gather Merge
                Workers Planned: 2
                ->  Sort
-                     Sort Key: pagg_tab_ml_p1.b
+                     Sort Key: pagg_tab_ml.b
                      ->  Parallel Append
                            ->  Partial HashAggregate
-                                 Group Key: pagg_tab_ml_p1.b
-                                 ->  Parallel Seq Scan on pagg_tab_ml_p1
+                                 Group Key: pagg_tab_ml.b
+                                 ->  Parallel Seq Scan on pagg_tab_ml_p1 pagg_tab_ml
                            ->  Partial HashAggregate
-                                 Group Key: pagg_tab_ml_p2_s1.b
-                                 ->  Parallel Seq Scan on pagg_tab_ml_p2_s1
+                                 Group Key: pagg_tab_ml_1.b
+                                 ->  Parallel Seq Scan on pagg_tab_ml_p2_s1 pagg_tab_ml_1
                            ->  Partial HashAggregate
-                                 Group Key: pagg_tab_ml_p2_s2.b
-                                 ->  Parallel Seq Scan on pagg_tab_ml_p2_s2
+                                 Group Key: pagg_tab_ml_2.b
+                                 ->  Parallel Seq Scan on pagg_tab_ml_p2_s2 pagg_tab_ml_2
                            ->  Partial HashAggregate
-                                 Group Key: pagg_tab_ml_p3_s1.b
-                                 ->  Parallel Seq Scan on pagg_tab_ml_p3_s1
+                                 Group Key: pagg_tab_ml_3.b
+                                 ->  Parallel Seq Scan on pagg_tab_ml_p3_s1 pagg_tab_ml_3
                            ->  Partial HashAggregate
-                                 Group Key: pagg_tab_ml_p3_s2.b
-                                 ->  Parallel Seq Scan on pagg_tab_ml_p3_s2
+                                 Group Key: pagg_tab_ml_4.b
+                                 ->  Parallel Seq Scan on pagg_tab_ml_p3_s2 pagg_tab_ml_4
 (24 rows)
 
 SELECT b, sum(a), count(*) FROM pagg_tab_ml GROUP BY b HAVING avg(a) < 15 ORDER BY 1, 2, 3;
@@ -1273,33 +1273,33 @@ SELECT b, sum(a), count(*) FROM pagg_tab_ml GROUP BY b HAVING avg(a) < 15 ORDER
 -- Full aggregation at all levels as GROUP BY clause matches with PARTITION KEY
 EXPLAIN (COSTS OFF)
 SELECT a, sum(b), count(*) FROM pagg_tab_ml GROUP BY a, b, c HAVING avg(b) > 7 ORDER BY 1, 2, 3;
-                                          QUERY PLAN                                          
-----------------------------------------------------------------------------------------------
+                                    QUERY PLAN                                    
+----------------------------------------------------------------------------------
  Gather Merge
    Workers Planned: 2
    ->  Sort
-         Sort Key: pagg_tab_ml_p1.a, (sum(pagg_tab_ml_p1.b)), (count(*))
+         Sort Key: pagg_tab_ml.a, (sum(pagg_tab_ml.b)), (count(*))
          ->  Parallel Append
                ->  HashAggregate
-                     Group Key: pagg_tab_ml_p1.a, pagg_tab_ml_p1.b, pagg_tab_ml_p1.c
-                     Filter: (avg(pagg_tab_ml_p1.b) > '7'::numeric)
-                     ->  Seq Scan on pagg_tab_ml_p1
+                     Group Key: pagg_tab_ml.a, pagg_tab_ml.b, pagg_tab_ml.c
+                     Filter: (avg(pagg_tab_ml.b) > '7'::numeric)
+                     ->  Seq Scan on pagg_tab_ml_p1 pagg_tab_ml
                ->  HashAggregate
-                     Group Key: pagg_tab_ml_p2_s1.a, pagg_tab_ml_p2_s1.b, pagg_tab_ml_p2_s1.c
-                     Filter: (avg(pagg_tab_ml_p2_s1.b) > '7'::numeric)
-                     ->  Seq Scan on pagg_tab_ml_p2_s1
+                     Group Key: pagg_tab_ml_1.a, pagg_tab_ml_1.b, pagg_tab_ml_1.c
+                     Filter: (avg(pagg_tab_ml_1.b) > '7'::numeric)
+                     ->  Seq Scan on pagg_tab_ml_p2_s1 pagg_tab_ml_1
                ->  HashAggregate
-                     Group Key: pagg_tab_ml_p2_s2.a, pagg_tab_ml_p2_s2.b, pagg_tab_ml_p2_s2.c
-                     Filter: (avg(pagg_tab_ml_p2_s2.b) > '7'::numeric)
-                     ->  Seq Scan on pagg_tab_ml_p2_s2
+                     Group Key: pagg_tab_ml_2.a, pagg_tab_ml_2.b, pagg_tab_ml_2.c
+                     Filter: (avg(pagg_tab_ml_2.b) > '7'::numeric)
+                     ->  Seq Scan on pagg_tab_ml_p2_s2 pagg_tab_ml_2
                ->  HashAggregate
-                     Group Key: pagg_tab_ml_p3_s1.a, pagg_tab_ml_p3_s1.b, pagg_tab_ml_p3_s1.c
-                     Filter: (avg(pagg_tab_ml_p3_s1.b) > '7'::numeric)
-                     ->  Seq Scan on pagg_tab_ml_p3_s1
+                     Group Key: pagg_tab_ml_3.a, pagg_tab_ml_3.b, pagg_tab_ml_3.c
+                     Filter: (avg(pagg_tab_ml_3.b) > '7'::numeric)
+                     ->  Seq Scan on pagg_tab_ml_p3_s1 pagg_tab_ml_3
                ->  HashAggregate
-                     Group Key: pagg_tab_ml_p3_s2.a, pagg_tab_ml_p3_s2.b, pagg_tab_ml_p3_s2.c
-                     Filter: (avg(pagg_tab_ml_p3_s2.b) > '7'::numeric)
-                     ->  Seq Scan on pagg_tab_ml_p3_s2
+                     Group Key: pagg_tab_ml_4.a, pagg_tab_ml_4.b, pagg_tab_ml_4.c
+                     Filter: (avg(pagg_tab_ml_4.b) > '7'::numeric)
+                     ->  Seq Scan on pagg_tab_ml_p3_s2 pagg_tab_ml_4
 (25 rows)
 
 SELECT a, sum(b), count(*) FROM pagg_tab_ml GROUP BY a, b, c HAVING avg(b) > 7 ORDER BY 1, 2, 3;
@@ -1337,27 +1337,27 @@ ANALYZE pagg_tab_para;
 -- When GROUP BY clause matches; full aggregation is performed for each partition.
 EXPLAIN (COSTS OFF)
 SELECT x, sum(y), avg(y), count(*) FROM pagg_tab_para GROUP BY x HAVING avg(y) < 7 ORDER BY 1, 2, 3;
-                                      QUERY PLAN                                      
---------------------------------------------------------------------------------------
+                                        QUERY PLAN                                         
+-------------------------------------------------------------------------------------------
  Sort
-   Sort Key: pagg_tab_para_p1.x, (sum(pagg_tab_para_p1.y)), (avg(pagg_tab_para_p1.y))
+   Sort Key: pagg_tab_para.x, (sum(pagg_tab_para.y)), (avg(pagg_tab_para.y))
    ->  Finalize GroupAggregate
-         Group Key: pagg_tab_para_p1.x
-         Filter: (avg(pagg_tab_para_p1.y) < '7'::numeric)
+         Group Key: pagg_tab_para.x
+         Filter: (avg(pagg_tab_para.y) < '7'::numeric)
          ->  Gather Merge
                Workers Planned: 2
                ->  Sort
-                     Sort Key: pagg_tab_para_p1.x
+                     Sort Key: pagg_tab_para.x
                      ->  Parallel Append
                            ->  Partial HashAggregate
-                                 Group Key: pagg_tab_para_p1.x
-                                 ->  Parallel Seq Scan on pagg_tab_para_p1
+                                 Group Key: pagg_tab_para.x
+                                 ->  Parallel Seq Scan on pagg_tab_para_p1 pagg_tab_para
                            ->  Partial HashAggregate
-                                 Group Key: pagg_tab_para_p2.x
-                                 ->  Parallel Seq Scan on pagg_tab_para_p2
+                                 Group Key: pagg_tab_para_1.x
+                                 ->  Parallel Seq Scan on pagg_tab_para_p2 pagg_tab_para_1
                            ->  Partial HashAggregate
-                                 Group Key: pagg_tab_para_p3.x
-                                 ->  Parallel Seq Scan on pagg_tab_para_p3
+                                 Group Key: pagg_tab_para_2.x
+                                 ->  Parallel Seq Scan on pagg_tab_para_p3 pagg_tab_para_2
 (19 rows)
 
 SELECT x, sum(y), avg(y), count(*) FROM pagg_tab_para GROUP BY x HAVING avg(y) < 7 ORDER BY 1, 2, 3;
@@ -1374,27 +1374,27 @@ SELECT x, sum(y), avg(y), count(*) FROM pagg_tab_para GROUP BY x HAVING avg(y) <
 -- When GROUP BY clause does not match; partial aggregation is performed for each partition.
 EXPLAIN (COSTS OFF)
 SELECT y, sum(x), avg(x), count(*) FROM pagg_tab_para GROUP BY y HAVING avg(x) < 12 ORDER BY 1, 2, 3;
-                                      QUERY PLAN                                      
---------------------------------------------------------------------------------------
+                                        QUERY PLAN                                         
+-------------------------------------------------------------------------------------------
  Sort
-   Sort Key: pagg_tab_para_p1.y, (sum(pagg_tab_para_p1.x)), (avg(pagg_tab_para_p1.x))
+   Sort Key: pagg_tab_para.y, (sum(pagg_tab_para.x)), (avg(pagg_tab_para.x))
    ->  Finalize GroupAggregate
-         Group Key: pagg_tab_para_p1.y
-         Filter: (avg(pagg_tab_para_p1.x) < '12'::numeric)
+         Group Key: pagg_tab_para.y
+         Filter: (avg(pagg_tab_para.x) < '12'::numeric)
          ->  Gather Merge
                Workers Planned: 2
                ->  Sort
-                     Sort Key: pagg_tab_para_p1.y
+                     Sort Key: pagg_tab_para.y
                      ->  Parallel Append
                            ->  Partial HashAggregate
-                                 Group Key: pagg_tab_para_p1.y
-                                 ->  Parallel Seq Scan on pagg_tab_para_p1
+                                 Group Key: pagg_tab_para.y
+                                 ->  Parallel Seq Scan on pagg_tab_para_p1 pagg_tab_para
                            ->  Partial HashAggregate
-                                 Group Key: pagg_tab_para_p2.y
-                                 ->  Parallel Seq Scan on pagg_tab_para_p2
+                                 Group Key: pagg_tab_para_1.y
+                                 ->  Parallel Seq Scan on pagg_tab_para_p2 pagg_tab_para_1
                            ->  Partial HashAggregate
-                                 Group Key: pagg_tab_para_p3.y
-                                 ->  Parallel Seq Scan on pagg_tab_para_p3
+                                 Group Key: pagg_tab_para_2.y
+                                 ->  Parallel Seq Scan on pagg_tab_para_p3 pagg_tab_para_2
 (19 rows)
 
 SELECT y, sum(x), avg(x), count(*) FROM pagg_tab_para GROUP BY y HAVING avg(x) < 12 ORDER BY 1, 2, 3;
@@ -1412,23 +1412,23 @@ ALTER TABLE pagg_tab_para_p3 SET (parallel_workers = 0);
 ANALYZE pagg_tab_para;
 EXPLAIN (COSTS OFF)
 SELECT x, sum(y), avg(y), count(*) FROM pagg_tab_para GROUP BY x HAVING avg(y) < 7 ORDER BY 1, 2, 3;
-                                      QUERY PLAN                                      
---------------------------------------------------------------------------------------
+                                        QUERY PLAN                                         
+-------------------------------------------------------------------------------------------
  Sort
-   Sort Key: pagg_tab_para_p1.x, (sum(pagg_tab_para_p1.y)), (avg(pagg_tab_para_p1.y))
+   Sort Key: pagg_tab_para.x, (sum(pagg_tab_para.y)), (avg(pagg_tab_para.y))
    ->  Finalize GroupAggregate
-         Group Key: pagg_tab_para_p1.x
-         Filter: (avg(pagg_tab_para_p1.y) < '7'::numeric)
+         Group Key: pagg_tab_para.x
+         Filter: (avg(pagg_tab_para.y) < '7'::numeric)
          ->  Gather Merge
                Workers Planned: 2
                ->  Sort
-                     Sort Key: pagg_tab_para_p1.x
+                     Sort Key: pagg_tab_para.x
                      ->  Partial HashAggregate
-                           Group Key: pagg_tab_para_p1.x
+                           Group Key: pagg_tab_para.x
                            ->  Parallel Append
-                                 ->  Seq Scan on pagg_tab_para_p1
-                                 ->  Seq Scan on pagg_tab_para_p3
-                                 ->  Parallel Seq Scan on pagg_tab_para_p2
+                                 ->  Seq Scan on pagg_tab_para_p1 pagg_tab_para
+                                 ->  Seq Scan on pagg_tab_para_p3 pagg_tab_para_2
+                                 ->  Parallel Seq Scan on pagg_tab_para_p2 pagg_tab_para_1
 (15 rows)
 
 SELECT x, sum(y), avg(y), count(*) FROM pagg_tab_para GROUP BY x HAVING avg(y) < 7 ORDER BY 1, 2, 3;
@@ -1446,23 +1446,23 @@ ALTER TABLE pagg_tab_para_p2 SET (parallel_workers = 0);
 ANALYZE pagg_tab_para;
 EXPLAIN (COSTS OFF)
 SELECT x, sum(y), avg(y), count(*) FROM pagg_tab_para GROUP BY x HAVING avg(y) < 7 ORDER BY 1, 2, 3;
-                                      QUERY PLAN                                      
---------------------------------------------------------------------------------------
+                                    QUERY PLAN                                    
+----------------------------------------------------------------------------------
  Sort
-   Sort Key: pagg_tab_para_p1.x, (sum(pagg_tab_para_p1.y)), (avg(pagg_tab_para_p1.y))
+   Sort Key: pagg_tab_para.x, (sum(pagg_tab_para.y)), (avg(pagg_tab_para.y))
    ->  Finalize GroupAggregate
-         Group Key: pagg_tab_para_p1.x
-         Filter: (avg(pagg_tab_para_p1.y) < '7'::numeric)
+         Group Key: pagg_tab_para.x
+         Filter: (avg(pagg_tab_para.y) < '7'::numeric)
          ->  Gather Merge
                Workers Planned: 2
                ->  Sort
-                     Sort Key: pagg_tab_para_p1.x
+                     Sort Key: pagg_tab_para.x
                      ->  Partial HashAggregate
-                           Group Key: pagg_tab_para_p1.x
+                           Group Key: pagg_tab_para.x
                            ->  Parallel Append
-                                 ->  Seq Scan on pagg_tab_para_p1
-                                 ->  Seq Scan on pagg_tab_para_p2
-                                 ->  Seq Scan on pagg_tab_para_p3
+                                 ->  Seq Scan on pagg_tab_para_p1 pagg_tab_para
+                                 ->  Seq Scan on pagg_tab_para_p2 pagg_tab_para_1
+                                 ->  Seq Scan on pagg_tab_para_p3 pagg_tab_para_2
 (15 rows)
 
 SELECT x, sum(y), avg(y), count(*) FROM pagg_tab_para GROUP BY x HAVING avg(y) < 7 ORDER BY 1, 2, 3;
@@ -1481,23 +1481,23 @@ RESET min_parallel_table_scan_size;
 RESET parallel_setup_cost;
 EXPLAIN (COSTS OFF)
 SELECT x, sum(y), avg(y), count(*) FROM pagg_tab_para GROUP BY x HAVING avg(y) < 7 ORDER BY 1, 2, 3;
-                                      QUERY PLAN                                      
---------------------------------------------------------------------------------------
+                                 QUERY PLAN                                  
+-----------------------------------------------------------------------------
  Sort
-   Sort Key: pagg_tab_para_p1.x, (sum(pagg_tab_para_p1.y)), (avg(pagg_tab_para_p1.y))
+   Sort Key: pagg_tab_para.x, (sum(pagg_tab_para.y)), (avg(pagg_tab_para.y))
    ->  Append
          ->  HashAggregate
-               Group Key: pagg_tab_para_p1.x
-               Filter: (avg(pagg_tab_para_p1.y) < '7'::numeric)
-               ->  Seq Scan on pagg_tab_para_p1
+               Group Key: pagg_tab_para.x
+               Filter: (avg(pagg_tab_para.y) < '7'::numeric)
+               ->  Seq Scan on pagg_tab_para_p1 pagg_tab_para
          ->  HashAggregate
-               Group Key: pagg_tab_para_p2.x
-               Filter: (avg(pagg_tab_para_p2.y) < '7'::numeric)
-               ->  Seq Scan on pagg_tab_para_p2
+               Group Key: pagg_tab_para_1.x
+               Filter: (avg(pagg_tab_para_1.y) < '7'::numeric)
+               ->  Seq Scan on pagg_tab_para_p2 pagg_tab_para_1
          ->  HashAggregate
-               Group Key: pagg_tab_para_p3.x
-               Filter: (avg(pagg_tab_para_p3.y) < '7'::numeric)
-               ->  Seq Scan on pagg_tab_para_p3
+               Group Key: pagg_tab_para_2.x
+               Filter: (avg(pagg_tab_para_2.y) < '7'::numeric)
+               ->  Seq Scan on pagg_tab_para_p3 pagg_tab_para_2
 (15 rows)
 
 SELECT x, sum(y), avg(y), count(*) FROM pagg_tab_para GROUP BY x HAVING avg(y) < 7 ORDER BY 1, 2, 3;
diff --git a/src/test/regress/expected/partition_join.out b/src/test/regress/expected/partition_join.out
index 975bf6765ca5..8e7127e586dc 100644
--- a/src/test/regress/expected/partition_join.out
+++ b/src/test/regress/expected/partition_join.out
@@ -145,34 +145,34 @@ SELECT t1.a, t1.c, t2.b, t2.c FROM prt1 t1 RIGHT JOIN prt2 t2 ON t1.a = t2.b WHE
 -- full outer join, with placeholder vars
 EXPLAIN (COSTS OFF)
 SELECT t1.a, t1.c, t2.b, t2.c FROM (SELECT 50 phv, * FROM prt1 WHERE prt1.b = 0) t1 FULL JOIN (SELECT 75 phv, * FROM prt2 WHERE prt2.a = 0) t2 ON (t1.a = t2.b) WHERE t1.phv = t1.a OR t2.phv = t2.b ORDER BY t1.a, t2.b;
-                            QUERY PLAN                            
-------------------------------------------------------------------
+                           QUERY PLAN                           
+----------------------------------------------------------------
  Sort
-   Sort Key: prt1_p1.a, prt2_p1.b
+   Sort Key: prt1.a, prt2.b
    ->  Append
          ->  Hash Full Join
-               Hash Cond: (prt1_p1.a = prt2_p1.b)
-               Filter: (((50) = prt1_p1.a) OR ((75) = prt2_p1.b))
-               ->  Seq Scan on prt1_p1
+               Hash Cond: (prt1.a = prt2.b)
+               Filter: (((50) = prt1.a) OR ((75) = prt2.b))
+               ->  Seq Scan on prt1_p1 prt1
                      Filter: (b = 0)
                ->  Hash
-                     ->  Seq Scan on prt2_p1
+                     ->  Seq Scan on prt2_p1 prt2
                            Filter: (a = 0)
          ->  Hash Full Join
-               Hash Cond: (prt1_p2.a = prt2_p2.b)
-               Filter: (((50) = prt1_p2.a) OR ((75) = prt2_p2.b))
-               ->  Seq Scan on prt1_p2
+               Hash Cond: (prt1_1.a = prt2_1.b)
+               Filter: (((50) = prt1_1.a) OR ((75) = prt2_1.b))
+               ->  Seq Scan on prt1_p2 prt1_1
                      Filter: (b = 0)
                ->  Hash
-                     ->  Seq Scan on prt2_p2
+                     ->  Seq Scan on prt2_p2 prt2_1
                            Filter: (a = 0)
          ->  Hash Full Join
-               Hash Cond: (prt1_p3.a = prt2_p3.b)
-               Filter: (((50) = prt1_p3.a) OR ((75) = prt2_p3.b))
-               ->  Seq Scan on prt1_p3
+               Hash Cond: (prt1_2.a = prt2_2.b)
+               Filter: (((50) = prt1_2.a) OR ((75) = prt2_2.b))
+               ->  Seq Scan on prt1_p3 prt1_2
                      Filter: (b = 0)
                ->  Hash
-                     ->  Seq Scan on prt2_p3
+                     ->  Seq Scan on prt2_p3 prt2_2
                            Filter: (a = 0)
 (27 rows)
 
@@ -211,19 +211,19 @@ SELECT t1.a, t1.c, t2.b, t2.c FROM (SELECT * FROM prt1 WHERE a < 450) t1 LEFT JO
                         QUERY PLAN                         
 -----------------------------------------------------------
  Sort
-   Sort Key: prt1_p1.a, prt2_p2.b
+   Sort Key: prt1.a, prt2.b
    ->  Hash Right Join
-         Hash Cond: (prt2_p2.b = prt1_p1.a)
+         Hash Cond: (prt2.b = prt1.a)
          ->  Append
-               ->  Seq Scan on prt2_p2
+               ->  Seq Scan on prt2_p2 prt2
                      Filter: (b > 250)
-               ->  Seq Scan on prt2_p3
+               ->  Seq Scan on prt2_p3 prt2_1
                      Filter: (b > 250)
          ->  Hash
                ->  Append
-                     ->  Seq Scan on prt1_p1
+                     ->  Seq Scan on prt1_p1 prt1
                            Filter: ((a < 450) AND (b = 0))
-                     ->  Seq Scan on prt1_p2
+                     ->  Seq Scan on prt1_p2 prt1_1
                            Filter: ((a < 450) AND (b = 0))
 (15 rows)
 
@@ -244,23 +244,23 @@ SELECT t1.a, t1.c, t2.b, t2.c FROM (SELECT * FROM prt1 WHERE a < 450) t1 LEFT JO
 -- Currently we can't do partitioned join if nullable-side partitions are pruned
 EXPLAIN (COSTS OFF)
 SELECT t1.a, t1.c, t2.b, t2.c FROM (SELECT * FROM prt1 WHERE a < 450) t1 FULL JOIN (SELECT * FROM prt2 WHERE b > 250) t2 ON t1.a = t2.b WHERE t1.b = 0 OR t2.a = 0 ORDER BY t1.a, t2.b;
-                      QUERY PLAN                      
-------------------------------------------------------
+                     QUERY PLAN                     
+----------------------------------------------------
  Sort
-   Sort Key: prt1_p1.a, prt2_p2.b
+   Sort Key: prt1.a, prt2.b
    ->  Hash Full Join
-         Hash Cond: (prt1_p1.a = prt2_p2.b)
-         Filter: ((prt1_p1.b = 0) OR (prt2_p2.a = 0))
+         Hash Cond: (prt1.a = prt2.b)
+         Filter: ((prt1.b = 0) OR (prt2.a = 0))
          ->  Append
-               ->  Seq Scan on prt1_p1
+               ->  Seq Scan on prt1_p1 prt1
                      Filter: (a < 450)
-               ->  Seq Scan on prt1_p2
+               ->  Seq Scan on prt1_p2 prt1_1
                      Filter: (a < 450)
          ->  Hash
                ->  Append
-                     ->  Seq Scan on prt2_p2
+                     ->  Seq Scan on prt2_p2 prt2
                            Filter: (b > 250)
-                     ->  Seq Scan on prt2_p3
+                     ->  Seq Scan on prt2_p3 prt2_1
                            Filter: (b > 250)
 (16 rows)
 
@@ -466,48 +466,48 @@ EXPLAIN (COSTS OFF)
 SELECT a, b FROM prt1 FULL JOIN prt2 p2(b,a,c) USING(a,b)
   WHERE a BETWEEN 490 AND 510
   GROUP BY 1, 2 ORDER BY 1, 2;
-                                                    QUERY PLAN                                                     
--------------------------------------------------------------------------------------------------------------------
+                                                   QUERY PLAN                                                    
+-----------------------------------------------------------------------------------------------------------------
  Group
-   Group Key: (COALESCE(prt1_p1.a, p2.a)), (COALESCE(prt1_p1.b, p2.b))
+   Group Key: (COALESCE(prt1.a, p2.a)), (COALESCE(prt1.b, p2.b))
    ->  Merge Append
-         Sort Key: (COALESCE(prt1_p1.a, p2.a)), (COALESCE(prt1_p1.b, p2.b))
+         Sort Key: (COALESCE(prt1.a, p2.a)), (COALESCE(prt1.b, p2.b))
          ->  Group
-               Group Key: (COALESCE(prt1_p1.a, p2.a)), (COALESCE(prt1_p1.b, p2.b))
+               Group Key: (COALESCE(prt1.a, p2.a)), (COALESCE(prt1.b, p2.b))
                ->  Sort
-                     Sort Key: (COALESCE(prt1_p1.a, p2.a)), (COALESCE(prt1_p1.b, p2.b))
+                     Sort Key: (COALESCE(prt1.a, p2.a)), (COALESCE(prt1.b, p2.b))
                      ->  Merge Full Join
-                           Merge Cond: ((prt1_p1.a = p2.a) AND (prt1_p1.b = p2.b))
-                           Filter: ((COALESCE(prt1_p1.a, p2.a) >= 490) AND (COALESCE(prt1_p1.a, p2.a) <= 510))
+                           Merge Cond: ((prt1.a = p2.a) AND (prt1.b = p2.b))
+                           Filter: ((COALESCE(prt1.a, p2.a) >= 490) AND (COALESCE(prt1.a, p2.a) <= 510))
                            ->  Sort
-                                 Sort Key: prt1_p1.a, prt1_p1.b
-                                 ->  Seq Scan on prt1_p1
+                                 Sort Key: prt1.a, prt1.b
+                                 ->  Seq Scan on prt1_p1 prt1
                            ->  Sort
                                  Sort Key: p2.a, p2.b
                                  ->  Seq Scan on prt2_p1 p2
          ->  Group
-               Group Key: (COALESCE(prt1_p2.a, p2_1.a)), (COALESCE(prt1_p2.b, p2_1.b))
+               Group Key: (COALESCE(prt1_1.a, p2_1.a)), (COALESCE(prt1_1.b, p2_1.b))
                ->  Sort
-                     Sort Key: (COALESCE(prt1_p2.a, p2_1.a)), (COALESCE(prt1_p2.b, p2_1.b))
+                     Sort Key: (COALESCE(prt1_1.a, p2_1.a)), (COALESCE(prt1_1.b, p2_1.b))
                      ->  Merge Full Join
-                           Merge Cond: ((prt1_p2.a = p2_1.a) AND (prt1_p2.b = p2_1.b))
-                           Filter: ((COALESCE(prt1_p2.a, p2_1.a) >= 490) AND (COALESCE(prt1_p2.a, p2_1.a) <= 510))
+                           Merge Cond: ((prt1_1.a = p2_1.a) AND (prt1_1.b = p2_1.b))
+                           Filter: ((COALESCE(prt1_1.a, p2_1.a) >= 490) AND (COALESCE(prt1_1.a, p2_1.a) <= 510))
                            ->  Sort
-                                 Sort Key: prt1_p2.a, prt1_p2.b
-                                 ->  Seq Scan on prt1_p2
+                                 Sort Key: prt1_1.a, prt1_1.b
+                                 ->  Seq Scan on prt1_p2 prt1_1
                            ->  Sort
                                  Sort Key: p2_1.a, p2_1.b
                                  ->  Seq Scan on prt2_p2 p2_1
          ->  Group
-               Group Key: (COALESCE(prt1_p3.a, p2_2.a)), (COALESCE(prt1_p3.b, p2_2.b))
+               Group Key: (COALESCE(prt1_2.a, p2_2.a)), (COALESCE(prt1_2.b, p2_2.b))
                ->  Sort
-                     Sort Key: (COALESCE(prt1_p3.a, p2_2.a)), (COALESCE(prt1_p3.b, p2_2.b))
+                     Sort Key: (COALESCE(prt1_2.a, p2_2.a)), (COALESCE(prt1_2.b, p2_2.b))
                      ->  Merge Full Join
-                           Merge Cond: ((prt1_p3.a = p2_2.a) AND (prt1_p3.b = p2_2.b))
-                           Filter: ((COALESCE(prt1_p3.a, p2_2.a) >= 490) AND (COALESCE(prt1_p3.a, p2_2.a) <= 510))
+                           Merge Cond: ((prt1_2.a = p2_2.a) AND (prt1_2.b = p2_2.b))
+                           Filter: ((COALESCE(prt1_2.a, p2_2.a) >= 490) AND (COALESCE(prt1_2.a, p2_2.a) <= 510))
                            ->  Sort
-                                 Sort Key: prt1_p3.a, prt1_p3.b
-                                 ->  Seq Scan on prt1_p3
+                                 Sort Key: prt1_2.a, prt1_2.b
+                                 ->  Seq Scan on prt1_p3 prt1_2
                            ->  Sort
                                  Sort Key: p2_2.a, p2_2.b
                                  ->  Seq Scan on prt2_p3 p2_2
@@ -754,49 +754,49 @@ SELECT t1.a, t1.c, t2.b, t2.c, t3.a + t3.b, t3.c FROM (prt1 t1 LEFT JOIN prt2 t2
 -- make sure these go to null as expected
 EXPLAIN (COSTS OFF)
 SELECT t1.a, t1.phv, t2.b, t2.phv, t3.a + t3.b, t3.phv FROM ((SELECT 50 phv, * FROM prt1 WHERE prt1.b = 0) t1 FULL JOIN (SELECT 75 phv, * FROM prt2 WHERE prt2.a = 0) t2 ON (t1.a = t2.b)) FULL JOIN (SELECT 50 phv, * FROM prt1_e WHERE prt1_e.c = 0) t3 ON (t1.a = (t3.a + t3.b)/2) WHERE t1.a = t1.phv OR t2.b = t2.phv OR (t3.a + t3.b)/2 = t3.phv ORDER BY t1.a, t2.b, t3.a + t3.b;
-                                                   QUERY PLAN                                                   
-----------------------------------------------------------------------------------------------------------------
+                                                 QUERY PLAN                                                 
+------------------------------------------------------------------------------------------------------------
  Sort
-   Sort Key: prt1_p1.a, prt2_p1.b, ((prt1_e_p1.a + prt1_e_p1.b))
+   Sort Key: prt1.a, prt2.b, ((prt1_e.a + prt1_e.b))
    ->  Append
          ->  Hash Full Join
-               Hash Cond: (prt1_p1.a = ((prt1_e_p1.a + prt1_e_p1.b) / 2))
-               Filter: ((prt1_p1.a = (50)) OR (prt2_p1.b = (75)) OR (((prt1_e_p1.a + prt1_e_p1.b) / 2) = (50)))
+               Hash Cond: (prt1.a = ((prt1_e.a + prt1_e.b) / 2))
+               Filter: ((prt1.a = (50)) OR (prt2.b = (75)) OR (((prt1_e.a + prt1_e.b) / 2) = (50)))
                ->  Hash Full Join
-                     Hash Cond: (prt1_p1.a = prt2_p1.b)
-                     ->  Seq Scan on prt1_p1
+                     Hash Cond: (prt1.a = prt2.b)
+                     ->  Seq Scan on prt1_p1 prt1
                            Filter: (b = 0)
                      ->  Hash
-                           ->  Seq Scan on prt2_p1
+                           ->  Seq Scan on prt2_p1 prt2
                                  Filter: (a = 0)
                ->  Hash
-                     ->  Seq Scan on prt1_e_p1
+                     ->  Seq Scan on prt1_e_p1 prt1_e
                            Filter: (c = 0)
          ->  Hash Full Join
-               Hash Cond: (prt1_p2.a = ((prt1_e_p2.a + prt1_e_p2.b) / 2))
-               Filter: ((prt1_p2.a = (50)) OR (prt2_p2.b = (75)) OR (((prt1_e_p2.a + prt1_e_p2.b) / 2) = (50)))
+               Hash Cond: (prt1_1.a = ((prt1_e_1.a + prt1_e_1.b) / 2))
+               Filter: ((prt1_1.a = (50)) OR (prt2_1.b = (75)) OR (((prt1_e_1.a + prt1_e_1.b) / 2) = (50)))
                ->  Hash Full Join
-                     Hash Cond: (prt1_p2.a = prt2_p2.b)
-                     ->  Seq Scan on prt1_p2
+                     Hash Cond: (prt1_1.a = prt2_1.b)
+                     ->  Seq Scan on prt1_p2 prt1_1
                            Filter: (b = 0)
                      ->  Hash
-                           ->  Seq Scan on prt2_p2
+                           ->  Seq Scan on prt2_p2 prt2_1
                                  Filter: (a = 0)
                ->  Hash
-                     ->  Seq Scan on prt1_e_p2
+                     ->  Seq Scan on prt1_e_p2 prt1_e_1
                            Filter: (c = 0)
          ->  Hash Full Join
-               Hash Cond: (prt1_p3.a = ((prt1_e_p3.a + prt1_e_p3.b) / 2))
-               Filter: ((prt1_p3.a = (50)) OR (prt2_p3.b = (75)) OR (((prt1_e_p3.a + prt1_e_p3.b) / 2) = (50)))
+               Hash Cond: (prt1_2.a = ((prt1_e_2.a + prt1_e_2.b) / 2))
+               Filter: ((prt1_2.a = (50)) OR (prt2_2.b = (75)) OR (((prt1_e_2.a + prt1_e_2.b) / 2) = (50)))
                ->  Hash Full Join
-                     Hash Cond: (prt1_p3.a = prt2_p3.b)
-                     ->  Seq Scan on prt1_p3
+                     Hash Cond: (prt1_2.a = prt2_2.b)
+                     ->  Seq Scan on prt1_p3 prt1_2
                            Filter: (b = 0)
                      ->  Hash
-                           ->  Seq Scan on prt2_p3
+                           ->  Seq Scan on prt2_p3 prt2_2
                                  Filter: (a = 0)
                ->  Hash
-                     ->  Seq Scan on prt1_e_p3
+                     ->  Seq Scan on prt1_e_p3 prt1_e_2
                            Filter: (c = 0)
 (42 rows)
 
@@ -1064,22 +1064,22 @@ SELECT t1.a, t2.b FROM (SELECT * FROM prt1 WHERE a < 450) t1 LEFT JOIN (SELECT *
                         QUERY PLAN                         
 -----------------------------------------------------------
  Sort
-   Sort Key: prt1_p1.a, prt2_p2.b
+   Sort Key: prt1.a, prt2.b
    ->  Merge Left Join
-         Merge Cond: (prt1_p1.a = prt2_p2.b)
+         Merge Cond: (prt1.a = prt2.b)
          ->  Sort
-               Sort Key: prt1_p1.a
+               Sort Key: prt1.a
                ->  Append
-                     ->  Seq Scan on prt1_p1
+                     ->  Seq Scan on prt1_p1 prt1
                            Filter: ((a < 450) AND (b = 0))
-                     ->  Seq Scan on prt1_p2
+                     ->  Seq Scan on prt1_p2 prt1_1
                            Filter: ((a < 450) AND (b = 0))
          ->  Sort
-               Sort Key: prt2_p2.b
+               Sort Key: prt2.b
                ->  Append
-                     ->  Seq Scan on prt2_p2
+                     ->  Seq Scan on prt2_p2 prt2
                            Filter: (b > 250)
-                     ->  Seq Scan on prt2_p3
+                     ->  Seq Scan on prt2_p3 prt2_1
                            Filter: (b > 250)
 (18 rows)
 
@@ -1150,31 +1150,31 @@ INSERT INTO prt2_m SELECT i, i, i % 25 FROM generate_series(0, 599, 3) i;
 ANALYZE prt2_m;
 EXPLAIN (COSTS OFF)
 SELECT t1.a, t1.c, t2.b, t2.c FROM (SELECT * FROM prt1_m WHERE prt1_m.c = 0) t1 FULL JOIN (SELECT * FROM prt2_m WHERE prt2_m.c = 0) t2 ON (t1.a = (t2.b + t2.a)/2 AND t2.b = (t1.a + t1.b)/2) ORDER BY t1.a, t2.b;
-                                                             QUERY PLAN                                                             
-------------------------------------------------------------------------------------------------------------------------------------
+                                                          QUERY PLAN                                                          
+------------------------------------------------------------------------------------------------------------------------------
  Sort
-   Sort Key: prt1_m_p1.a, prt2_m_p1.b
+   Sort Key: prt1_m.a, prt2_m.b
    ->  Append
          ->  Hash Full Join
-               Hash Cond: ((prt1_m_p1.a = ((prt2_m_p1.b + prt2_m_p1.a) / 2)) AND (((prt1_m_p1.a + prt1_m_p1.b) / 2) = prt2_m_p1.b))
-               ->  Seq Scan on prt1_m_p1
+               Hash Cond: ((prt1_m.a = ((prt2_m.b + prt2_m.a) / 2)) AND (((prt1_m.a + prt1_m.b) / 2) = prt2_m.b))
+               ->  Seq Scan on prt1_m_p1 prt1_m
                      Filter: (c = 0)
                ->  Hash
-                     ->  Seq Scan on prt2_m_p1
+                     ->  Seq Scan on prt2_m_p1 prt2_m
                            Filter: (c = 0)
          ->  Hash Full Join
-               Hash Cond: ((prt1_m_p2.a = ((prt2_m_p2.b + prt2_m_p2.a) / 2)) AND (((prt1_m_p2.a + prt1_m_p2.b) / 2) = prt2_m_p2.b))
-               ->  Seq Scan on prt1_m_p2
+               Hash Cond: ((prt1_m_1.a = ((prt2_m_1.b + prt2_m_1.a) / 2)) AND (((prt1_m_1.a + prt1_m_1.b) / 2) = prt2_m_1.b))
+               ->  Seq Scan on prt1_m_p2 prt1_m_1
                      Filter: (c = 0)
                ->  Hash
-                     ->  Seq Scan on prt2_m_p2
+                     ->  Seq Scan on prt2_m_p2 prt2_m_1
                            Filter: (c = 0)
          ->  Hash Full Join
-               Hash Cond: ((prt1_m_p3.a = ((prt2_m_p3.b + prt2_m_p3.a) / 2)) AND (((prt1_m_p3.a + prt1_m_p3.b) / 2) = prt2_m_p3.b))
-               ->  Seq Scan on prt1_m_p3
+               Hash Cond: ((prt1_m_2.a = ((prt2_m_2.b + prt2_m_2.a) / 2)) AND (((prt1_m_2.a + prt1_m_2.b) / 2) = prt2_m_2.b))
+               ->  Seq Scan on prt1_m_p3 prt1_m_2
                      Filter: (c = 0)
                ->  Hash
-                     ->  Seq Scan on prt2_m_p3
+                     ->  Seq Scan on prt2_m_p3 prt2_m_2
                            Filter: (c = 0)
 (24 rows)
 
@@ -1659,38 +1659,38 @@ SELECT t1.a, t1.c, t2.b, t2.c FROM prt1_l t1 RIGHT JOIN prt2_l t2 ON t1.a = t2.b
 -- full join
 EXPLAIN (COSTS OFF)
 SELECT t1.a, t1.c, t2.b, t2.c FROM (SELECT * FROM prt1_l WHERE prt1_l.b = 0) t1 FULL JOIN (SELECT * FROM prt2_l WHERE prt2_l.a = 0) t2 ON (t1.a = t2.b AND t1.c = t2.c) ORDER BY t1.a, t2.b;
-                                                     QUERY PLAN                                                     
---------------------------------------------------------------------------------------------------------------------
+                                             QUERY PLAN                                             
+----------------------------------------------------------------------------------------------------
  Sort
-   Sort Key: prt1_l_p1.a, prt2_l_p1.b
+   Sort Key: prt1_l.a, prt2_l.b
    ->  Append
          ->  Hash Full Join
-               Hash Cond: ((prt1_l_p1.a = prt2_l_p1.b) AND ((prt1_l_p1.c)::text = (prt2_l_p1.c)::text))
-               ->  Seq Scan on prt1_l_p1
+               Hash Cond: ((prt1_l.a = prt2_l.b) AND ((prt1_l.c)::text = (prt2_l.c)::text))
+               ->  Seq Scan on prt1_l_p1 prt1_l
                      Filter: (b = 0)
                ->  Hash
-                     ->  Seq Scan on prt2_l_p1
+                     ->  Seq Scan on prt2_l_p1 prt2_l
                            Filter: (a = 0)
          ->  Hash Full Join
-               Hash Cond: ((prt1_l_p2_p1.a = prt2_l_p2_p1.b) AND ((prt1_l_p2_p1.c)::text = (prt2_l_p2_p1.c)::text))
-               ->  Seq Scan on prt1_l_p2_p1
+               Hash Cond: ((prt1_l_1.a = prt2_l_1.b) AND ((prt1_l_1.c)::text = (prt2_l_1.c)::text))
+               ->  Seq Scan on prt1_l_p2_p1 prt1_l_1
                      Filter: (b = 0)
                ->  Hash
-                     ->  Seq Scan on prt2_l_p2_p1
+                     ->  Seq Scan on prt2_l_p2_p1 prt2_l_1
                            Filter: (a = 0)
          ->  Hash Full Join
-               Hash Cond: ((prt1_l_p2_p2.a = prt2_l_p2_p2.b) AND ((prt1_l_p2_p2.c)::text = (prt2_l_p2_p2.c)::text))
-               ->  Seq Scan on prt1_l_p2_p2
+               Hash Cond: ((prt1_l_2.a = prt2_l_2.b) AND ((prt1_l_2.c)::text = (prt2_l_2.c)::text))
+               ->  Seq Scan on prt1_l_p2_p2 prt1_l_2
                      Filter: (b = 0)
                ->  Hash
-                     ->  Seq Scan on prt2_l_p2_p2
+                     ->  Seq Scan on prt2_l_p2_p2 prt2_l_2
                            Filter: (a = 0)
          ->  Hash Full Join
-               Hash Cond: ((prt1_l_p3_p1.a = prt2_l_p3_p1.b) AND ((prt1_l_p3_p1.c)::text = (prt2_l_p3_p1.c)::text))
-               ->  Seq Scan on prt1_l_p3_p1
+               Hash Cond: ((prt1_l_3.a = prt2_l_3.b) AND ((prt1_l_3.c)::text = (prt2_l_3.c)::text))
+               ->  Seq Scan on prt1_l_p3_p1 prt1_l_3
                      Filter: (b = 0)
                ->  Hash
-                     ->  Seq Scan on prt2_l_p3_p1
+                     ->  Seq Scan on prt2_l_p3_p1 prt2_l_3
                            Filter: (a = 0)
 (31 rows)
 
@@ -1819,11 +1819,11 @@ WHERE EXISTS (
                           QUERY PLAN                           
 ---------------------------------------------------------------
  Delete on prt1_l
-   Delete on prt1_l_p1
-   Delete on prt1_l_p3_p1
-   Delete on prt1_l_p3_p2
+   Delete on prt1_l_p1 prt1_l_1
+   Delete on prt1_l_p3_p1 prt1_l_2
+   Delete on prt1_l_p3_p2 prt1_l_3
    ->  Nested Loop Semi Join
-         ->  Seq Scan on prt1_l_p1
+         ->  Seq Scan on prt1_l_p1 prt1_l_1
                Filter: (c IS NULL)
          ->  Nested Loop
                ->  Seq Scan on int4_tbl
@@ -1831,7 +1831,7 @@ WHERE EXISTS (
                      ->  Limit
                            ->  Seq Scan on int8_tbl
    ->  Nested Loop Semi Join
-         ->  Seq Scan on prt1_l_p3_p1
+         ->  Seq Scan on prt1_l_p3_p1 prt1_l_2
                Filter: (c IS NULL)
          ->  Nested Loop
                ->  Seq Scan on int4_tbl
@@ -1839,7 +1839,7 @@ WHERE EXISTS (
                      ->  Limit
                            ->  Seq Scan on int8_tbl int8_tbl_1
    ->  Nested Loop Semi Join
-         ->  Seq Scan on prt1_l_p3_p2
+         ->  Seq Scan on prt1_l_p3_p2 prt1_l_3
                Filter: (c IS NULL)
          ->  Nested Loop
                ->  Seq Scan on int4_tbl
diff --git a/src/test/regress/expected/partition_prune.out b/src/test/regress/expected/partition_prune.out
index 12c0109d6dd2..f9eeda60e6a6 100644
--- a/src/test/regress/expected/partition_prune.out
+++ b/src/test/regress/expected/partition_prune.out
@@ -11,24 +11,24 @@ create table lp_bc partition of lp for values in ('b', 'c');
 create table lp_g partition of lp for values in ('g');
 create table lp_null partition of lp for values in (null);
 explain (costs off) select * from lp;
-          QUERY PLAN          
-------------------------------
+            QUERY PLAN             
+-----------------------------------
  Append
-   ->  Seq Scan on lp_ad
-   ->  Seq Scan on lp_bc
-   ->  Seq Scan on lp_ef
-   ->  Seq Scan on lp_g
-   ->  Seq Scan on lp_null
-   ->  Seq Scan on lp_default
+   ->  Seq Scan on lp_ad lp
+   ->  Seq Scan on lp_bc lp_1
+   ->  Seq Scan on lp_ef lp_2
+   ->  Seq Scan on lp_g lp_3
+   ->  Seq Scan on lp_null lp_4
+   ->  Seq Scan on lp_default lp_5
 (7 rows)
 
 explain (costs off) select * from lp where a > 'a' and a < 'd';
                         QUERY PLAN                         
 -----------------------------------------------------------
  Append
-   ->  Seq Scan on lp_bc
+   ->  Seq Scan on lp_bc lp
          Filter: ((a > 'a'::bpchar) AND (a < 'd'::bpchar))
-   ->  Seq Scan on lp_default
+   ->  Seq Scan on lp_default lp_1
          Filter: ((a > 'a'::bpchar) AND (a < 'd'::bpchar))
 (5 rows)
 
@@ -36,48 +36,48 @@ explain (costs off) select * from lp where a > 'a' and a <= 'd';
                          QUERY PLAN                         
 ------------------------------------------------------------
  Append
-   ->  Seq Scan on lp_ad
+   ->  Seq Scan on lp_ad lp
          Filter: ((a > 'a'::bpchar) AND (a <= 'd'::bpchar))
-   ->  Seq Scan on lp_bc
+   ->  Seq Scan on lp_bc lp_1
          Filter: ((a > 'a'::bpchar) AND (a <= 'd'::bpchar))
-   ->  Seq Scan on lp_default
+   ->  Seq Scan on lp_default lp_2
          Filter: ((a > 'a'::bpchar) AND (a <= 'd'::bpchar))
 (7 rows)
 
 explain (costs off) select * from lp where a = 'a';
          QUERY PLAN          
 -----------------------------
- Seq Scan on lp_ad
+ Seq Scan on lp_ad lp
    Filter: (a = 'a'::bpchar)
 (2 rows)
 
 explain (costs off) select * from lp where 'a' = a;	/* commuted */
          QUERY PLAN          
 -----------------------------
- Seq Scan on lp_ad
+ Seq Scan on lp_ad lp
    Filter: ('a'::bpchar = a)
 (2 rows)
 
 explain (costs off) select * from lp where a is not null;
-           QUERY PLAN            
----------------------------------
+            QUERY PLAN             
+-----------------------------------
  Append
-   ->  Seq Scan on lp_ad
+   ->  Seq Scan on lp_ad lp
          Filter: (a IS NOT NULL)
-   ->  Seq Scan on lp_bc
+   ->  Seq Scan on lp_bc lp_1
          Filter: (a IS NOT NULL)
-   ->  Seq Scan on lp_ef
+   ->  Seq Scan on lp_ef lp_2
          Filter: (a IS NOT NULL)
-   ->  Seq Scan on lp_g
+   ->  Seq Scan on lp_g lp_3
          Filter: (a IS NOT NULL)
-   ->  Seq Scan on lp_default
+   ->  Seq Scan on lp_default lp_4
          Filter: (a IS NOT NULL)
 (11 rows)
 
 explain (costs off) select * from lp where a is null;
-      QUERY PLAN       
------------------------
- Seq Scan on lp_null
+       QUERY PLAN       
+------------------------
+ Seq Scan on lp_null lp
    Filter: (a IS NULL)
 (2 rows)
 
@@ -85,9 +85,9 @@ explain (costs off) select * from lp where a = 'a' or a = 'c';
                         QUERY PLAN                        
 ----------------------------------------------------------
  Append
-   ->  Seq Scan on lp_ad
+   ->  Seq Scan on lp_ad lp
          Filter: ((a = 'a'::bpchar) OR (a = 'c'::bpchar))
-   ->  Seq Scan on lp_bc
+   ->  Seq Scan on lp_bc lp_1
          Filter: ((a = 'a'::bpchar) OR (a = 'c'::bpchar))
 (5 rows)
 
@@ -95,9 +95,9 @@ explain (costs off) select * from lp where a is not null and (a = 'a' or a = 'c'
                                    QUERY PLAN                                   
 --------------------------------------------------------------------------------
  Append
-   ->  Seq Scan on lp_ad
+   ->  Seq Scan on lp_ad lp
          Filter: ((a IS NOT NULL) AND ((a = 'a'::bpchar) OR (a = 'c'::bpchar)))
-   ->  Seq Scan on lp_bc
+   ->  Seq Scan on lp_bc lp_1
          Filter: ((a IS NOT NULL) AND ((a = 'a'::bpchar) OR (a = 'c'::bpchar)))
 (5 rows)
 
@@ -105,13 +105,13 @@ explain (costs off) select * from lp where a <> 'g';
              QUERY PLAN             
 ------------------------------------
  Append
-   ->  Seq Scan on lp_ad
+   ->  Seq Scan on lp_ad lp
          Filter: (a <> 'g'::bpchar)
-   ->  Seq Scan on lp_bc
+   ->  Seq Scan on lp_bc lp_1
          Filter: (a <> 'g'::bpchar)
-   ->  Seq Scan on lp_ef
+   ->  Seq Scan on lp_ef lp_2
          Filter: (a <> 'g'::bpchar)
-   ->  Seq Scan on lp_default
+   ->  Seq Scan on lp_default lp_3
          Filter: (a <> 'g'::bpchar)
 (9 rows)
 
@@ -119,13 +119,13 @@ explain (costs off) select * from lp where a <> 'a' and a <> 'd';
                          QUERY PLAN                          
 -------------------------------------------------------------
  Append
-   ->  Seq Scan on lp_bc
+   ->  Seq Scan on lp_bc lp
          Filter: ((a <> 'a'::bpchar) AND (a <> 'd'::bpchar))
-   ->  Seq Scan on lp_ef
+   ->  Seq Scan on lp_ef lp_1
          Filter: ((a <> 'a'::bpchar) AND (a <> 'd'::bpchar))
-   ->  Seq Scan on lp_g
+   ->  Seq Scan on lp_g lp_2
          Filter: ((a <> 'a'::bpchar) AND (a <> 'd'::bpchar))
-   ->  Seq Scan on lp_default
+   ->  Seq Scan on lp_default lp_3
          Filter: ((a <> 'a'::bpchar) AND (a <> 'd'::bpchar))
 (9 rows)
 
@@ -133,13 +133,13 @@ explain (costs off) select * from lp where a not in ('a', 'd');
                    QUERY PLAN                   
 ------------------------------------------------
  Append
-   ->  Seq Scan on lp_bc
+   ->  Seq Scan on lp_bc lp
          Filter: (a <> ALL ('{a,d}'::bpchar[]))
-   ->  Seq Scan on lp_ef
+   ->  Seq Scan on lp_ef lp_1
          Filter: (a <> ALL ('{a,d}'::bpchar[]))
-   ->  Seq Scan on lp_g
+   ->  Seq Scan on lp_g lp_2
          Filter: (a <> ALL ('{a,d}'::bpchar[]))
-   ->  Seq Scan on lp_default
+   ->  Seq Scan on lp_default lp_3
          Filter: (a <> ALL ('{a,d}'::bpchar[]))
 (9 rows)
 
@@ -149,9 +149,9 @@ create table coll_pruning_a partition of coll_pruning for values in ('a');
 create table coll_pruning_b partition of coll_pruning for values in ('b');
 create table coll_pruning_def partition of coll_pruning default;
 explain (costs off) select * from coll_pruning where a collate "C" = 'a' collate "C";
-              QUERY PLAN               
----------------------------------------
- Seq Scan on coll_pruning_a
+               QUERY PLAN                
+-----------------------------------------
+ Seq Scan on coll_pruning_a coll_pruning
    Filter: (a = 'a'::text COLLATE "C")
 (2 rows)
 
@@ -160,11 +160,11 @@ explain (costs off) select * from coll_pruning where a collate "POSIX" = 'a' col
                        QUERY PLAN                        
 ---------------------------------------------------------
  Append
-   ->  Seq Scan on coll_pruning_a
+   ->  Seq Scan on coll_pruning_a coll_pruning
          Filter: ((a)::text = 'a'::text COLLATE "POSIX")
-   ->  Seq Scan on coll_pruning_b
+   ->  Seq Scan on coll_pruning_b coll_pruning_1
          Filter: ((a)::text = 'a'::text COLLATE "POSIX")
-   ->  Seq Scan on coll_pruning_def
+   ->  Seq Scan on coll_pruning_def coll_pruning_2
          Filter: ((a)::text = 'a'::text COLLATE "POSIX")
 (7 rows)
 
@@ -190,40 +190,40 @@ create table rlp5 partition of rlp for values from (31) to (maxvalue) partition
 create table rlp5_default partition of rlp5 default;
 create table rlp5_1 partition of rlp5 for values from (31) to (40);
 explain (costs off) select * from rlp where a < 1;
-    QUERY PLAN     
--------------------
- Seq Scan on rlp1
+      QUERY PLAN      
+----------------------
+ Seq Scan on rlp1 rlp
    Filter: (a < 1)
 (2 rows)
 
 explain (costs off) select * from rlp where 1 > a;	/* commuted */
-    QUERY PLAN     
--------------------
- Seq Scan on rlp1
+      QUERY PLAN      
+----------------------
+ Seq Scan on rlp1 rlp
    Filter: (1 > a)
 (2 rows)
 
 explain (costs off) select * from rlp where a <= 1;
-        QUERY PLAN        
---------------------------
+          QUERY PLAN          
+------------------------------
  Append
-   ->  Seq Scan on rlp1
+   ->  Seq Scan on rlp1 rlp
          Filter: (a <= 1)
-   ->  Seq Scan on rlp2
+   ->  Seq Scan on rlp2 rlp_1
          Filter: (a <= 1)
 (5 rows)
 
 explain (costs off) select * from rlp where a = 1;
-    QUERY PLAN     
--------------------
- Seq Scan on rlp2
+      QUERY PLAN      
+----------------------
+ Seq Scan on rlp2 rlp
    Filter: (a = 1)
 (2 rows)
 
 explain (costs off) select * from rlp where a = 1::bigint;		/* same as above */
          QUERY PLAN          
 -----------------------------
- Seq Scan on rlp2
+ Seq Scan on rlp2 rlp
    Filter: (a = '1'::bigint)
 (2 rows)
 
@@ -231,113 +231,113 @@ explain (costs off) select * from rlp where a = 1::numeric;		/* no pruning */
                   QUERY PLAN                   
 -----------------------------------------------
  Append
-   ->  Seq Scan on rlp1
+   ->  Seq Scan on rlp1 rlp
          Filter: ((a)::numeric = '1'::numeric)
-   ->  Seq Scan on rlp2
+   ->  Seq Scan on rlp2 rlp_1
          Filter: ((a)::numeric = '1'::numeric)
-   ->  Seq Scan on rlp3abcd
+   ->  Seq Scan on rlp3abcd rlp_2
          Filter: ((a)::numeric = '1'::numeric)
-   ->  Seq Scan on rlp3efgh
+   ->  Seq Scan on rlp3efgh rlp_3
          Filter: ((a)::numeric = '1'::numeric)
-   ->  Seq Scan on rlp3nullxy
+   ->  Seq Scan on rlp3nullxy rlp_4
          Filter: ((a)::numeric = '1'::numeric)
-   ->  Seq Scan on rlp3_default
+   ->  Seq Scan on rlp3_default rlp_5
          Filter: ((a)::numeric = '1'::numeric)
-   ->  Seq Scan on rlp4_1
+   ->  Seq Scan on rlp4_1 rlp_6
          Filter: ((a)::numeric = '1'::numeric)
-   ->  Seq Scan on rlp4_2
+   ->  Seq Scan on rlp4_2 rlp_7
          Filter: ((a)::numeric = '1'::numeric)
-   ->  Seq Scan on rlp4_default
+   ->  Seq Scan on rlp4_default rlp_8
          Filter: ((a)::numeric = '1'::numeric)
-   ->  Seq Scan on rlp5_1
+   ->  Seq Scan on rlp5_1 rlp_9
          Filter: ((a)::numeric = '1'::numeric)
-   ->  Seq Scan on rlp5_default
+   ->  Seq Scan on rlp5_default rlp_10
          Filter: ((a)::numeric = '1'::numeric)
-   ->  Seq Scan on rlp_default_10
+   ->  Seq Scan on rlp_default_10 rlp_11
          Filter: ((a)::numeric = '1'::numeric)
-   ->  Seq Scan on rlp_default_30
+   ->  Seq Scan on rlp_default_30 rlp_12
          Filter: ((a)::numeric = '1'::numeric)
-   ->  Seq Scan on rlp_default_null
+   ->  Seq Scan on rlp_default_null rlp_13
          Filter: ((a)::numeric = '1'::numeric)
-   ->  Seq Scan on rlp_default_default
+   ->  Seq Scan on rlp_default_default rlp_14
          Filter: ((a)::numeric = '1'::numeric)
 (31 rows)
 
 explain (costs off) select * from rlp where a <= 10;
-              QUERY PLAN               
----------------------------------------
+                 QUERY PLAN                  
+---------------------------------------------
  Append
-   ->  Seq Scan on rlp1
+   ->  Seq Scan on rlp1 rlp
          Filter: (a <= 10)
-   ->  Seq Scan on rlp2
+   ->  Seq Scan on rlp2 rlp_1
          Filter: (a <= 10)
-   ->  Seq Scan on rlp_default_10
+   ->  Seq Scan on rlp_default_10 rlp_2
          Filter: (a <= 10)
-   ->  Seq Scan on rlp_default_default
+   ->  Seq Scan on rlp_default_default rlp_3
          Filter: (a <= 10)
 (9 rows)
 
 explain (costs off) select * from rlp where a > 10;
-              QUERY PLAN               
----------------------------------------
+                  QUERY PLAN                  
+----------------------------------------------
  Append
-   ->  Seq Scan on rlp3abcd
+   ->  Seq Scan on rlp3abcd rlp
          Filter: (a > 10)
-   ->  Seq Scan on rlp3efgh
+   ->  Seq Scan on rlp3efgh rlp_1
          Filter: (a > 10)
-   ->  Seq Scan on rlp3nullxy
+   ->  Seq Scan on rlp3nullxy rlp_2
          Filter: (a > 10)
-   ->  Seq Scan on rlp3_default
+   ->  Seq Scan on rlp3_default rlp_3
          Filter: (a > 10)
-   ->  Seq Scan on rlp4_1
+   ->  Seq Scan on rlp4_1 rlp_4
          Filter: (a > 10)
-   ->  Seq Scan on rlp4_2
+   ->  Seq Scan on rlp4_2 rlp_5
          Filter: (a > 10)
-   ->  Seq Scan on rlp4_default
+   ->  Seq Scan on rlp4_default rlp_6
          Filter: (a > 10)
-   ->  Seq Scan on rlp5_1
+   ->  Seq Scan on rlp5_1 rlp_7
          Filter: (a > 10)
-   ->  Seq Scan on rlp5_default
+   ->  Seq Scan on rlp5_default rlp_8
          Filter: (a > 10)
-   ->  Seq Scan on rlp_default_30
+   ->  Seq Scan on rlp_default_30 rlp_9
          Filter: (a > 10)
-   ->  Seq Scan on rlp_default_default
+   ->  Seq Scan on rlp_default_default rlp_10
          Filter: (a > 10)
 (23 rows)
 
 explain (costs off) select * from rlp where a < 15;
-              QUERY PLAN               
----------------------------------------
+                 QUERY PLAN                  
+---------------------------------------------
  Append
-   ->  Seq Scan on rlp1
+   ->  Seq Scan on rlp1 rlp
          Filter: (a < 15)
-   ->  Seq Scan on rlp2
+   ->  Seq Scan on rlp2 rlp_1
          Filter: (a < 15)
-   ->  Seq Scan on rlp_default_10
+   ->  Seq Scan on rlp_default_10 rlp_2
          Filter: (a < 15)
-   ->  Seq Scan on rlp_default_default
+   ->  Seq Scan on rlp_default_default rlp_3
          Filter: (a < 15)
 (9 rows)
 
 explain (costs off) select * from rlp where a <= 15;
-              QUERY PLAN               
----------------------------------------
+                 QUERY PLAN                  
+---------------------------------------------
  Append
-   ->  Seq Scan on rlp1
+   ->  Seq Scan on rlp1 rlp
          Filter: (a <= 15)
-   ->  Seq Scan on rlp2
+   ->  Seq Scan on rlp2 rlp_1
          Filter: (a <= 15)
-   ->  Seq Scan on rlp3abcd
+   ->  Seq Scan on rlp3abcd rlp_2
          Filter: (a <= 15)
-   ->  Seq Scan on rlp3efgh
+   ->  Seq Scan on rlp3efgh rlp_3
          Filter: (a <= 15)
-   ->  Seq Scan on rlp3nullxy
+   ->  Seq Scan on rlp3nullxy rlp_4
          Filter: (a <= 15)
-   ->  Seq Scan on rlp3_default
+   ->  Seq Scan on rlp3_default rlp_5
          Filter: (a <= 15)
-   ->  Seq Scan on rlp_default_10
+   ->  Seq Scan on rlp_default_10 rlp_6
          Filter: (a <= 15)
-   ->  Seq Scan on rlp_default_default
+   ->  Seq Scan on rlp_default_default rlp_7
          Filter: (a <= 15)
 (17 rows)
 
@@ -345,49 +345,49 @@ explain (costs off) select * from rlp where a > 15 and b = 'ab';
                        QUERY PLAN                        
 ---------------------------------------------------------
  Append
-   ->  Seq Scan on rlp3abcd
+   ->  Seq Scan on rlp3abcd rlp
          Filter: ((a > 15) AND ((b)::text = 'ab'::text))
-   ->  Seq Scan on rlp4_1
+   ->  Seq Scan on rlp4_1 rlp_1
          Filter: ((a > 15) AND ((b)::text = 'ab'::text))
-   ->  Seq Scan on rlp4_2
+   ->  Seq Scan on rlp4_2 rlp_2
          Filter: ((a > 15) AND ((b)::text = 'ab'::text))
-   ->  Seq Scan on rlp4_default
+   ->  Seq Scan on rlp4_default rlp_3
          Filter: ((a > 15) AND ((b)::text = 'ab'::text))
-   ->  Seq Scan on rlp5_1
+   ->  Seq Scan on rlp5_1 rlp_4
          Filter: ((a > 15) AND ((b)::text = 'ab'::text))
-   ->  Seq Scan on rlp5_default
+   ->  Seq Scan on rlp5_default rlp_5
          Filter: ((a > 15) AND ((b)::text = 'ab'::text))
-   ->  Seq Scan on rlp_default_30
+   ->  Seq Scan on rlp_default_30 rlp_6
          Filter: ((a > 15) AND ((b)::text = 'ab'::text))
-   ->  Seq Scan on rlp_default_default
+   ->  Seq Scan on rlp_default_default rlp_7
          Filter: ((a > 15) AND ((b)::text = 'ab'::text))
 (17 rows)
 
 explain (costs off) select * from rlp where a = 16;
-           QUERY PLAN           
---------------------------------
+              QUERY PLAN              
+--------------------------------------
  Append
-   ->  Seq Scan on rlp3abcd
+   ->  Seq Scan on rlp3abcd rlp
          Filter: (a = 16)
-   ->  Seq Scan on rlp3efgh
+   ->  Seq Scan on rlp3efgh rlp_1
          Filter: (a = 16)
-   ->  Seq Scan on rlp3nullxy
+   ->  Seq Scan on rlp3nullxy rlp_2
          Filter: (a = 16)
-   ->  Seq Scan on rlp3_default
+   ->  Seq Scan on rlp3_default rlp_3
          Filter: (a = 16)
 (9 rows)
 
 explain (costs off) select * from rlp where a = 16 and b in ('not', 'in', 'here');
                               QUERY PLAN                              
 ----------------------------------------------------------------------
- Seq Scan on rlp3_default
+ Seq Scan on rlp3_default rlp
    Filter: ((a = 16) AND ((b)::text = ANY ('{not,in,here}'::text[])))
 (2 rows)
 
 explain (costs off) select * from rlp where a = 16 and b < 'ab';
                     QUERY PLAN                     
 ---------------------------------------------------
- Seq Scan on rlp3_default
+ Seq Scan on rlp3_default rlp
    Filter: (((b)::text < 'ab'::text) AND (a = 16))
 (2 rows)
 
@@ -395,16 +395,16 @@ explain (costs off) select * from rlp where a = 16 and b <= 'ab';
                         QUERY PLAN                        
 ----------------------------------------------------------
  Append
-   ->  Seq Scan on rlp3abcd
+   ->  Seq Scan on rlp3abcd rlp
          Filter: (((b)::text <= 'ab'::text) AND (a = 16))
-   ->  Seq Scan on rlp3_default
+   ->  Seq Scan on rlp3_default rlp_1
          Filter: (((b)::text <= 'ab'::text) AND (a = 16))
 (5 rows)
 
 explain (costs off) select * from rlp where a = 16 and b is null;
               QUERY PLAN              
 --------------------------------------
- Seq Scan on rlp3nullxy
+ Seq Scan on rlp3nullxy rlp
    Filter: ((b IS NULL) AND (a = 16))
 (2 rows)
 
@@ -412,112 +412,112 @@ explain (costs off) select * from rlp where a = 16 and b is not null;
                    QUERY PLAN                   
 ------------------------------------------------
  Append
-   ->  Seq Scan on rlp3abcd
+   ->  Seq Scan on rlp3abcd rlp
          Filter: ((b IS NOT NULL) AND (a = 16))
-   ->  Seq Scan on rlp3efgh
+   ->  Seq Scan on rlp3efgh rlp_1
          Filter: ((b IS NOT NULL) AND (a = 16))
-   ->  Seq Scan on rlp3nullxy
+   ->  Seq Scan on rlp3nullxy rlp_2
          Filter: ((b IS NOT NULL) AND (a = 16))
-   ->  Seq Scan on rlp3_default
+   ->  Seq Scan on rlp3_default rlp_3
          Filter: ((b IS NOT NULL) AND (a = 16))
 (9 rows)
 
 explain (costs off) select * from rlp where a is null;
-          QUERY PLAN          
-------------------------------
- Seq Scan on rlp_default_null
+            QUERY PLAN            
+----------------------------------
+ Seq Scan on rlp_default_null rlp
    Filter: (a IS NULL)
 (2 rows)
 
 explain (costs off) select * from rlp where a is not null;
-              QUERY PLAN               
----------------------------------------
+                  QUERY PLAN                  
+----------------------------------------------
  Append
-   ->  Seq Scan on rlp1
+   ->  Seq Scan on rlp1 rlp
          Filter: (a IS NOT NULL)
-   ->  Seq Scan on rlp2
+   ->  Seq Scan on rlp2 rlp_1
          Filter: (a IS NOT NULL)
-   ->  Seq Scan on rlp3abcd
+   ->  Seq Scan on rlp3abcd rlp_2
          Filter: (a IS NOT NULL)
-   ->  Seq Scan on rlp3efgh
+   ->  Seq Scan on rlp3efgh rlp_3
          Filter: (a IS NOT NULL)
-   ->  Seq Scan on rlp3nullxy
+   ->  Seq Scan on rlp3nullxy rlp_4
          Filter: (a IS NOT NULL)
-   ->  Seq Scan on rlp3_default
+   ->  Seq Scan on rlp3_default rlp_5
          Filter: (a IS NOT NULL)
-   ->  Seq Scan on rlp4_1
+   ->  Seq Scan on rlp4_1 rlp_6
          Filter: (a IS NOT NULL)
-   ->  Seq Scan on rlp4_2
+   ->  Seq Scan on rlp4_2 rlp_7
          Filter: (a IS NOT NULL)
-   ->  Seq Scan on rlp4_default
+   ->  Seq Scan on rlp4_default rlp_8
          Filter: (a IS NOT NULL)
-   ->  Seq Scan on rlp5_1
+   ->  Seq Scan on rlp5_1 rlp_9
          Filter: (a IS NOT NULL)
-   ->  Seq Scan on rlp5_default
+   ->  Seq Scan on rlp5_default rlp_10
          Filter: (a IS NOT NULL)
-   ->  Seq Scan on rlp_default_10
+   ->  Seq Scan on rlp_default_10 rlp_11
          Filter: (a IS NOT NULL)
-   ->  Seq Scan on rlp_default_30
+   ->  Seq Scan on rlp_default_30 rlp_12
          Filter: (a IS NOT NULL)
-   ->  Seq Scan on rlp_default_default
+   ->  Seq Scan on rlp_default_default rlp_13
          Filter: (a IS NOT NULL)
 (29 rows)
 
 explain (costs off) select * from rlp where a > 30;
-              QUERY PLAN               
----------------------------------------
+                 QUERY PLAN                  
+---------------------------------------------
  Append
-   ->  Seq Scan on rlp5_1
+   ->  Seq Scan on rlp5_1 rlp
          Filter: (a > 30)
-   ->  Seq Scan on rlp5_default
+   ->  Seq Scan on rlp5_default rlp_1
          Filter: (a > 30)
-   ->  Seq Scan on rlp_default_default
+   ->  Seq Scan on rlp_default_default rlp_2
          Filter: (a > 30)
 (7 rows)
 
 explain (costs off) select * from rlp where a = 30;	/* only default is scanned */
-         QUERY PLAN         
-----------------------------
- Seq Scan on rlp_default_30
+           QUERY PLAN           
+--------------------------------
+ Seq Scan on rlp_default_30 rlp
    Filter: (a = 30)
 (2 rows)
 
 explain (costs off) select * from rlp where a <= 31;
-              QUERY PLAN               
----------------------------------------
+                  QUERY PLAN                  
+----------------------------------------------
  Append
-   ->  Seq Scan on rlp1
+   ->  Seq Scan on rlp1 rlp
          Filter: (a <= 31)
-   ->  Seq Scan on rlp2
+   ->  Seq Scan on rlp2 rlp_1
          Filter: (a <= 31)
-   ->  Seq Scan on rlp3abcd
+   ->  Seq Scan on rlp3abcd rlp_2
          Filter: (a <= 31)
-   ->  Seq Scan on rlp3efgh
+   ->  Seq Scan on rlp3efgh rlp_3
          Filter: (a <= 31)
-   ->  Seq Scan on rlp3nullxy
+   ->  Seq Scan on rlp3nullxy rlp_4
          Filter: (a <= 31)
-   ->  Seq Scan on rlp3_default
+   ->  Seq Scan on rlp3_default rlp_5
          Filter: (a <= 31)
-   ->  Seq Scan on rlp4_1
+   ->  Seq Scan on rlp4_1 rlp_6
          Filter: (a <= 31)
-   ->  Seq Scan on rlp4_2
+   ->  Seq Scan on rlp4_2 rlp_7
          Filter: (a <= 31)
-   ->  Seq Scan on rlp4_default
+   ->  Seq Scan on rlp4_default rlp_8
          Filter: (a <= 31)
-   ->  Seq Scan on rlp5_1
+   ->  Seq Scan on rlp5_1 rlp_9
          Filter: (a <= 31)
-   ->  Seq Scan on rlp_default_10
+   ->  Seq Scan on rlp_default_10 rlp_10
          Filter: (a <= 31)
-   ->  Seq Scan on rlp_default_30
+   ->  Seq Scan on rlp_default_30 rlp_11
          Filter: (a <= 31)
-   ->  Seq Scan on rlp_default_default
+   ->  Seq Scan on rlp_default_default rlp_12
          Filter: (a <= 31)
 (27 rows)
 
 explain (costs off) select * from rlp where a = 1 or a = 7;
            QUERY PLAN           
 --------------------------------
- Seq Scan on rlp2
+ Seq Scan on rlp2 rlp
    Filter: ((a = 1) OR (a = 7))
 (2 rows)
 
@@ -525,29 +525,29 @@ explain (costs off) select * from rlp where a = 1 or b = 'ab';
                       QUERY PLAN                       
 -------------------------------------------------------
  Append
-   ->  Seq Scan on rlp1
+   ->  Seq Scan on rlp1 rlp
          Filter: ((a = 1) OR ((b)::text = 'ab'::text))
-   ->  Seq Scan on rlp2
+   ->  Seq Scan on rlp2 rlp_1
          Filter: ((a = 1) OR ((b)::text = 'ab'::text))
-   ->  Seq Scan on rlp3abcd
+   ->  Seq Scan on rlp3abcd rlp_2
          Filter: ((a = 1) OR ((b)::text = 'ab'::text))
-   ->  Seq Scan on rlp4_1
+   ->  Seq Scan on rlp4_1 rlp_3
          Filter: ((a = 1) OR ((b)::text = 'ab'::text))
-   ->  Seq Scan on rlp4_2
+   ->  Seq Scan on rlp4_2 rlp_4
          Filter: ((a = 1) OR ((b)::text = 'ab'::text))
-   ->  Seq Scan on rlp4_default
+   ->  Seq Scan on rlp4_default rlp_5
          Filter: ((a = 1) OR ((b)::text = 'ab'::text))
-   ->  Seq Scan on rlp5_1
+   ->  Seq Scan on rlp5_1 rlp_6
          Filter: ((a = 1) OR ((b)::text = 'ab'::text))
-   ->  Seq Scan on rlp5_default
+   ->  Seq Scan on rlp5_default rlp_7
          Filter: ((a = 1) OR ((b)::text = 'ab'::text))
-   ->  Seq Scan on rlp_default_10
+   ->  Seq Scan on rlp_default_10 rlp_8
          Filter: ((a = 1) OR ((b)::text = 'ab'::text))
-   ->  Seq Scan on rlp_default_30
+   ->  Seq Scan on rlp_default_30 rlp_9
          Filter: ((a = 1) OR ((b)::text = 'ab'::text))
-   ->  Seq Scan on rlp_default_null
+   ->  Seq Scan on rlp_default_null rlp_10
          Filter: ((a = 1) OR ((b)::text = 'ab'::text))
-   ->  Seq Scan on rlp_default_default
+   ->  Seq Scan on rlp_default_default rlp_11
          Filter: ((a = 1) OR ((b)::text = 'ab'::text))
 (25 rows)
 
@@ -555,32 +555,32 @@ explain (costs off) select * from rlp where a > 20 and a < 27;
                QUERY PLAN                
 -----------------------------------------
  Append
-   ->  Seq Scan on rlp4_1
+   ->  Seq Scan on rlp4_1 rlp
          Filter: ((a > 20) AND (a < 27))
-   ->  Seq Scan on rlp4_2
+   ->  Seq Scan on rlp4_2 rlp_1
          Filter: ((a > 20) AND (a < 27))
 (5 rows)
 
 explain (costs off) select * from rlp where a = 29;
-        QUERY PLAN        
---------------------------
- Seq Scan on rlp4_default
+          QUERY PLAN          
+------------------------------
+ Seq Scan on rlp4_default rlp
    Filter: (a = 29)
 (2 rows)
 
 explain (costs off) select * from rlp where a >= 29;
-              QUERY PLAN               
----------------------------------------
+                 QUERY PLAN                  
+---------------------------------------------
  Append
-   ->  Seq Scan on rlp4_default
+   ->  Seq Scan on rlp4_default rlp
          Filter: (a >= 29)
-   ->  Seq Scan on rlp5_1
+   ->  Seq Scan on rlp5_1 rlp_1
          Filter: (a >= 29)
-   ->  Seq Scan on rlp5_default
+   ->  Seq Scan on rlp5_default rlp_2
          Filter: (a >= 29)
-   ->  Seq Scan on rlp_default_30
+   ->  Seq Scan on rlp_default_30 rlp_3
          Filter: (a >= 29)
-   ->  Seq Scan on rlp_default_default
+   ->  Seq Scan on rlp_default_default rlp_4
          Filter: (a >= 29)
 (11 rows)
 
@@ -588,9 +588,9 @@ explain (costs off) select * from rlp where a < 1 or (a > 20 and a < 25);
                       QUERY PLAN                      
 ------------------------------------------------------
  Append
-   ->  Seq Scan on rlp1
+   ->  Seq Scan on rlp1 rlp
          Filter: ((a < 1) OR ((a > 20) AND (a < 25)))
-   ->  Seq Scan on rlp4_1
+   ->  Seq Scan on rlp4_1 rlp_1
          Filter: ((a < 1) OR ((a > 20) AND (a < 25)))
 (5 rows)
 
@@ -599,9 +599,9 @@ explain (costs off) select * from rlp where a = 20 or a = 40;
                QUERY PLAN               
 ----------------------------------------
  Append
-   ->  Seq Scan on rlp4_1
+   ->  Seq Scan on rlp4_1 rlp
          Filter: ((a = 20) OR (a = 40))
-   ->  Seq Scan on rlp5_default
+   ->  Seq Scan on rlp5_default rlp_1
          Filter: ((a = 20) OR (a = 40))
 (5 rows)
 
@@ -616,35 +616,35 @@ explain (costs off) select * from rlp3 where a = 20;   /* empty */
 explain (costs off) select * from rlp where a > 1 and a = 10;	/* only default */
             QUERY PLAN            
 ----------------------------------
- Seq Scan on rlp_default_10
+ Seq Scan on rlp_default_10 rlp
    Filter: ((a > 1) AND (a = 10))
 (2 rows)
 
 explain (costs off) select * from rlp where a > 1 and a >=15;	/* rlp3 onwards, including default */
-               QUERY PLAN                
------------------------------------------
+                  QUERY PLAN                  
+----------------------------------------------
  Append
-   ->  Seq Scan on rlp3abcd
+   ->  Seq Scan on rlp3abcd rlp
          Filter: ((a > 1) AND (a >= 15))
-   ->  Seq Scan on rlp3efgh
+   ->  Seq Scan on rlp3efgh rlp_1
          Filter: ((a > 1) AND (a >= 15))
-   ->  Seq Scan on rlp3nullxy
+   ->  Seq Scan on rlp3nullxy rlp_2
          Filter: ((a > 1) AND (a >= 15))
-   ->  Seq Scan on rlp3_default
+   ->  Seq Scan on rlp3_default rlp_3
          Filter: ((a > 1) AND (a >= 15))
-   ->  Seq Scan on rlp4_1
+   ->  Seq Scan on rlp4_1 rlp_4
          Filter: ((a > 1) AND (a >= 15))
-   ->  Seq Scan on rlp4_2
+   ->  Seq Scan on rlp4_2 rlp_5
          Filter: ((a > 1) AND (a >= 15))
-   ->  Seq Scan on rlp4_default
+   ->  Seq Scan on rlp4_default rlp_6
          Filter: ((a > 1) AND (a >= 15))
-   ->  Seq Scan on rlp5_1
+   ->  Seq Scan on rlp5_1 rlp_7
          Filter: ((a > 1) AND (a >= 15))
-   ->  Seq Scan on rlp5_default
+   ->  Seq Scan on rlp5_default rlp_8
          Filter: ((a > 1) AND (a >= 15))
-   ->  Seq Scan on rlp_default_30
+   ->  Seq Scan on rlp_default_30 rlp_9
          Filter: ((a > 1) AND (a >= 15))
-   ->  Seq Scan on rlp_default_default
+   ->  Seq Scan on rlp_default_default rlp_10
          Filter: ((a > 1) AND (a >= 15))
 (23 rows)
 
@@ -659,15 +659,15 @@ explain (costs off) select * from rlp where (a = 1 and a = 3) or (a > 1 and a =
                             QUERY PLAN                             
 -------------------------------------------------------------------
  Append
-   ->  Seq Scan on rlp2
+   ->  Seq Scan on rlp2 rlp
          Filter: (((a = 1) AND (a = 3)) OR ((a > 1) AND (a = 15)))
-   ->  Seq Scan on rlp3abcd
+   ->  Seq Scan on rlp3abcd rlp_1
          Filter: (((a = 1) AND (a = 3)) OR ((a > 1) AND (a = 15)))
-   ->  Seq Scan on rlp3efgh
+   ->  Seq Scan on rlp3efgh rlp_2
          Filter: (((a = 1) AND (a = 3)) OR ((a > 1) AND (a = 15)))
-   ->  Seq Scan on rlp3nullxy
+   ->  Seq Scan on rlp3nullxy rlp_3
          Filter: (((a = 1) AND (a = 3)) OR ((a > 1) AND (a = 15)))
-   ->  Seq Scan on rlp3_default
+   ->  Seq Scan on rlp3_default rlp_4
          Filter: (((a = 1) AND (a = 3)) OR ((a > 1) AND (a = 15)))
 (11 rows)
 
@@ -683,14 +683,14 @@ create table mc3p5 partition of mc3p for values from (11, 1, 1) to (20, 10, 10);
 create table mc3p6 partition of mc3p for values from (20, 10, 10) to (20, 20, 20);
 create table mc3p7 partition of mc3p for values from (20, 20, 20) to (maxvalue, maxvalue, maxvalue);
 explain (costs off) select * from mc3p where a = 1;
-           QUERY PLAN           
---------------------------------
+              QUERY PLAN               
+---------------------------------------
  Append
-   ->  Seq Scan on mc3p0
+   ->  Seq Scan on mc3p0 mc3p
          Filter: (a = 1)
-   ->  Seq Scan on mc3p1
+   ->  Seq Scan on mc3p1 mc3p_1
          Filter: (a = 1)
-   ->  Seq Scan on mc3p_default
+   ->  Seq Scan on mc3p_default mc3p_2
          Filter: (a = 1)
 (7 rows)
 
@@ -698,9 +698,9 @@ explain (costs off) select * from mc3p where a = 1 and abs(b) < 1;
                  QUERY PLAN                 
 --------------------------------------------
  Append
-   ->  Seq Scan on mc3p0
+   ->  Seq Scan on mc3p0 mc3p
          Filter: ((a = 1) AND (abs(b) < 1))
-   ->  Seq Scan on mc3p_default
+   ->  Seq Scan on mc3p_default mc3p_1
          Filter: ((a = 1) AND (abs(b) < 1))
 (5 rows)
 
@@ -708,11 +708,11 @@ explain (costs off) select * from mc3p where a = 1 and abs(b) = 1;
                  QUERY PLAN                 
 --------------------------------------------
  Append
-   ->  Seq Scan on mc3p0
+   ->  Seq Scan on mc3p0 mc3p
          Filter: ((a = 1) AND (abs(b) = 1))
-   ->  Seq Scan on mc3p1
+   ->  Seq Scan on mc3p1 mc3p_1
          Filter: ((a = 1) AND (abs(b) = 1))
-   ->  Seq Scan on mc3p_default
+   ->  Seq Scan on mc3p_default mc3p_2
          Filter: ((a = 1) AND (abs(b) = 1))
 (7 rows)
 
@@ -720,9 +720,9 @@ explain (costs off) select * from mc3p where a = 1 and abs(b) = 1 and c < 8;
                        QUERY PLAN                       
 --------------------------------------------------------
  Append
-   ->  Seq Scan on mc3p0
+   ->  Seq Scan on mc3p0 mc3p
          Filter: ((c < 8) AND (a = 1) AND (abs(b) = 1))
-   ->  Seq Scan on mc3p1
+   ->  Seq Scan on mc3p1 mc3p_1
          Filter: ((c < 8) AND (a = 1) AND (abs(b) = 1))
 (5 rows)
 
@@ -730,63 +730,63 @@ explain (costs off) select * from mc3p where a = 10 and abs(b) between 5 and 35;
                            QUERY PLAN                            
 -----------------------------------------------------------------
  Append
-   ->  Seq Scan on mc3p1
+   ->  Seq Scan on mc3p1 mc3p
          Filter: ((a = 10) AND (abs(b) >= 5) AND (abs(b) <= 35))
-   ->  Seq Scan on mc3p2
+   ->  Seq Scan on mc3p2 mc3p_1
          Filter: ((a = 10) AND (abs(b) >= 5) AND (abs(b) <= 35))
-   ->  Seq Scan on mc3p3
+   ->  Seq Scan on mc3p3 mc3p_2
          Filter: ((a = 10) AND (abs(b) >= 5) AND (abs(b) <= 35))
-   ->  Seq Scan on mc3p4
+   ->  Seq Scan on mc3p4 mc3p_3
          Filter: ((a = 10) AND (abs(b) >= 5) AND (abs(b) <= 35))
-   ->  Seq Scan on mc3p_default
+   ->  Seq Scan on mc3p_default mc3p_4
          Filter: ((a = 10) AND (abs(b) >= 5) AND (abs(b) <= 35))
 (11 rows)
 
 explain (costs off) select * from mc3p where a > 10;
-           QUERY PLAN           
---------------------------------
+              QUERY PLAN               
+---------------------------------------
  Append
-   ->  Seq Scan on mc3p5
+   ->  Seq Scan on mc3p5 mc3p
          Filter: (a > 10)
-   ->  Seq Scan on mc3p6
+   ->  Seq Scan on mc3p6 mc3p_1
          Filter: (a > 10)
-   ->  Seq Scan on mc3p7
+   ->  Seq Scan on mc3p7 mc3p_2
          Filter: (a > 10)
-   ->  Seq Scan on mc3p_default
+   ->  Seq Scan on mc3p_default mc3p_3
          Filter: (a > 10)
 (9 rows)
 
 explain (costs off) select * from mc3p where a >= 10;
-           QUERY PLAN           
---------------------------------
+              QUERY PLAN               
+---------------------------------------
  Append
-   ->  Seq Scan on mc3p1
+   ->  Seq Scan on mc3p1 mc3p
          Filter: (a >= 10)
-   ->  Seq Scan on mc3p2
+   ->  Seq Scan on mc3p2 mc3p_1
          Filter: (a >= 10)
-   ->  Seq Scan on mc3p3
+   ->  Seq Scan on mc3p3 mc3p_2
          Filter: (a >= 10)
-   ->  Seq Scan on mc3p4
+   ->  Seq Scan on mc3p4 mc3p_3
          Filter: (a >= 10)
-   ->  Seq Scan on mc3p5
+   ->  Seq Scan on mc3p5 mc3p_4
          Filter: (a >= 10)
-   ->  Seq Scan on mc3p6
+   ->  Seq Scan on mc3p6 mc3p_5
          Filter: (a >= 10)
-   ->  Seq Scan on mc3p7
+   ->  Seq Scan on mc3p7 mc3p_6
          Filter: (a >= 10)
-   ->  Seq Scan on mc3p_default
+   ->  Seq Scan on mc3p_default mc3p_7
          Filter: (a >= 10)
 (17 rows)
 
 explain (costs off) select * from mc3p where a < 10;
-           QUERY PLAN           
---------------------------------
+              QUERY PLAN               
+---------------------------------------
  Append
-   ->  Seq Scan on mc3p0
+   ->  Seq Scan on mc3p0 mc3p
          Filter: (a < 10)
-   ->  Seq Scan on mc3p1
+   ->  Seq Scan on mc3p1 mc3p_1
          Filter: (a < 10)
-   ->  Seq Scan on mc3p_default
+   ->  Seq Scan on mc3p_default mc3p_2
          Filter: (a < 10)
 (7 rows)
 
@@ -794,51 +794,51 @@ explain (costs off) select * from mc3p where a <= 10 and abs(b) < 10;
                   QUERY PLAN                   
 -----------------------------------------------
  Append
-   ->  Seq Scan on mc3p0
+   ->  Seq Scan on mc3p0 mc3p
          Filter: ((a <= 10) AND (abs(b) < 10))
-   ->  Seq Scan on mc3p1
+   ->  Seq Scan on mc3p1 mc3p_1
          Filter: ((a <= 10) AND (abs(b) < 10))
-   ->  Seq Scan on mc3p2
+   ->  Seq Scan on mc3p2 mc3p_2
          Filter: ((a <= 10) AND (abs(b) < 10))
-   ->  Seq Scan on mc3p_default
+   ->  Seq Scan on mc3p_default mc3p_3
          Filter: ((a <= 10) AND (abs(b) < 10))
 (9 rows)
 
 explain (costs off) select * from mc3p where a = 11 and abs(b) = 0;
               QUERY PLAN               
 ---------------------------------------
- Seq Scan on mc3p_default
+ Seq Scan on mc3p_default mc3p
    Filter: ((a = 11) AND (abs(b) = 0))
 (2 rows)
 
 explain (costs off) select * from mc3p where a = 20 and abs(b) = 10 and c = 100;
                       QUERY PLAN                      
 ------------------------------------------------------
- Seq Scan on mc3p6
+ Seq Scan on mc3p6 mc3p
    Filter: ((a = 20) AND (c = 100) AND (abs(b) = 10))
 (2 rows)
 
 explain (costs off) select * from mc3p where a > 20;
-           QUERY PLAN           
---------------------------------
+              QUERY PLAN               
+---------------------------------------
  Append
-   ->  Seq Scan on mc3p7
+   ->  Seq Scan on mc3p7 mc3p
          Filter: (a > 20)
-   ->  Seq Scan on mc3p_default
+   ->  Seq Scan on mc3p_default mc3p_1
          Filter: (a > 20)
 (5 rows)
 
 explain (costs off) select * from mc3p where a >= 20;
-           QUERY PLAN           
---------------------------------
+              QUERY PLAN               
+---------------------------------------
  Append
-   ->  Seq Scan on mc3p5
+   ->  Seq Scan on mc3p5 mc3p
          Filter: (a >= 20)
-   ->  Seq Scan on mc3p6
+   ->  Seq Scan on mc3p6 mc3p_1
          Filter: (a >= 20)
-   ->  Seq Scan on mc3p7
+   ->  Seq Scan on mc3p7 mc3p_2
          Filter: (a >= 20)
-   ->  Seq Scan on mc3p_default
+   ->  Seq Scan on mc3p_default mc3p_3
          Filter: (a >= 20)
 (9 rows)
 
@@ -846,13 +846,13 @@ explain (costs off) select * from mc3p where (a = 1 and abs(b) = 1 and c = 1) or
                                                            QUERY PLAN                                                            
 ---------------------------------------------------------------------------------------------------------------------------------
  Append
-   ->  Seq Scan on mc3p1
+   ->  Seq Scan on mc3p1 mc3p
          Filter: (((a = 1) AND (abs(b) = 1) AND (c = 1)) OR ((a = 10) AND (abs(b) = 5) AND (c = 10)) OR ((a > 11) AND (a < 20)))
-   ->  Seq Scan on mc3p2
+   ->  Seq Scan on mc3p2 mc3p_1
          Filter: (((a = 1) AND (abs(b) = 1) AND (c = 1)) OR ((a = 10) AND (abs(b) = 5) AND (c = 10)) OR ((a > 11) AND (a < 20)))
-   ->  Seq Scan on mc3p5
+   ->  Seq Scan on mc3p5 mc3p_2
          Filter: (((a = 1) AND (abs(b) = 1) AND (c = 1)) OR ((a = 10) AND (abs(b) = 5) AND (c = 10)) OR ((a > 11) AND (a < 20)))
-   ->  Seq Scan on mc3p_default
+   ->  Seq Scan on mc3p_default mc3p_3
          Filter: (((a = 1) AND (abs(b) = 1) AND (c = 1)) OR ((a = 10) AND (abs(b) = 5) AND (c = 10)) OR ((a > 11) AND (a < 20)))
 (9 rows)
 
@@ -860,15 +860,15 @@ explain (costs off) select * from mc3p where (a = 1 and abs(b) = 1 and c = 1) or
                                                                  QUERY PLAN                                                                 
 --------------------------------------------------------------------------------------------------------------------------------------------
  Append
-   ->  Seq Scan on mc3p0
+   ->  Seq Scan on mc3p0 mc3p
          Filter: (((a = 1) AND (abs(b) = 1) AND (c = 1)) OR ((a = 10) AND (abs(b) = 5) AND (c = 10)) OR ((a > 11) AND (a < 20)) OR (a < 1))
-   ->  Seq Scan on mc3p1
+   ->  Seq Scan on mc3p1 mc3p_1
          Filter: (((a = 1) AND (abs(b) = 1) AND (c = 1)) OR ((a = 10) AND (abs(b) = 5) AND (c = 10)) OR ((a > 11) AND (a < 20)) OR (a < 1))
-   ->  Seq Scan on mc3p2
+   ->  Seq Scan on mc3p2 mc3p_2
          Filter: (((a = 1) AND (abs(b) = 1) AND (c = 1)) OR ((a = 10) AND (abs(b) = 5) AND (c = 10)) OR ((a > 11) AND (a < 20)) OR (a < 1))
-   ->  Seq Scan on mc3p5
+   ->  Seq Scan on mc3p5 mc3p_3
          Filter: (((a = 1) AND (abs(b) = 1) AND (c = 1)) OR ((a = 10) AND (abs(b) = 5) AND (c = 10)) OR ((a > 11) AND (a < 20)) OR (a < 1))
-   ->  Seq Scan on mc3p_default
+   ->  Seq Scan on mc3p_default mc3p_4
          Filter: (((a = 1) AND (abs(b) = 1) AND (c = 1)) OR ((a = 10) AND (abs(b) = 5) AND (c = 10)) OR ((a > 11) AND (a < 20)) OR (a < 1))
 (11 rows)
 
@@ -876,15 +876,15 @@ explain (costs off) select * from mc3p where (a = 1 and abs(b) = 1 and c = 1) or
                                                                       QUERY PLAN                                                                       
 -------------------------------------------------------------------------------------------------------------------------------------------------------
  Append
-   ->  Seq Scan on mc3p0
+   ->  Seq Scan on mc3p0 mc3p
          Filter: (((a = 1) AND (abs(b) = 1) AND (c = 1)) OR ((a = 10) AND (abs(b) = 5) AND (c = 10)) OR ((a > 11) AND (a < 20)) OR (a < 1) OR (a = 1))
-   ->  Seq Scan on mc3p1
+   ->  Seq Scan on mc3p1 mc3p_1
          Filter: (((a = 1) AND (abs(b) = 1) AND (c = 1)) OR ((a = 10) AND (abs(b) = 5) AND (c = 10)) OR ((a > 11) AND (a < 20)) OR (a < 1) OR (a = 1))
-   ->  Seq Scan on mc3p2
+   ->  Seq Scan on mc3p2 mc3p_2
          Filter: (((a = 1) AND (abs(b) = 1) AND (c = 1)) OR ((a = 10) AND (abs(b) = 5) AND (c = 10)) OR ((a > 11) AND (a < 20)) OR (a < 1) OR (a = 1))
-   ->  Seq Scan on mc3p5
+   ->  Seq Scan on mc3p5 mc3p_3
          Filter: (((a = 1) AND (abs(b) = 1) AND (c = 1)) OR ((a = 10) AND (abs(b) = 5) AND (c = 10)) OR ((a > 11) AND (a < 20)) OR (a < 1) OR (a = 1))
-   ->  Seq Scan on mc3p_default
+   ->  Seq Scan on mc3p_default mc3p_4
          Filter: (((a = 1) AND (abs(b) = 1) AND (c = 1)) OR ((a = 10) AND (abs(b) = 5) AND (c = 10)) OR ((a > 11) AND (a < 20)) OR (a < 1) OR (a = 1))
 (11 rows)
 
@@ -892,23 +892,23 @@ explain (costs off) select * from mc3p where a = 1 or abs(b) = 1 or c = 1;
                       QUERY PLAN                      
 ------------------------------------------------------
  Append
-   ->  Seq Scan on mc3p0
+   ->  Seq Scan on mc3p0 mc3p
          Filter: ((a = 1) OR (abs(b) = 1) OR (c = 1))
-   ->  Seq Scan on mc3p1
+   ->  Seq Scan on mc3p1 mc3p_1
          Filter: ((a = 1) OR (abs(b) = 1) OR (c = 1))
-   ->  Seq Scan on mc3p2
+   ->  Seq Scan on mc3p2 mc3p_2
          Filter: ((a = 1) OR (abs(b) = 1) OR (c = 1))
-   ->  Seq Scan on mc3p3
+   ->  Seq Scan on mc3p3 mc3p_3
          Filter: ((a = 1) OR (abs(b) = 1) OR (c = 1))
-   ->  Seq Scan on mc3p4
+   ->  Seq Scan on mc3p4 mc3p_4
          Filter: ((a = 1) OR (abs(b) = 1) OR (c = 1))
-   ->  Seq Scan on mc3p5
+   ->  Seq Scan on mc3p5 mc3p_5
          Filter: ((a = 1) OR (abs(b) = 1) OR (c = 1))
-   ->  Seq Scan on mc3p6
+   ->  Seq Scan on mc3p6 mc3p_6
          Filter: ((a = 1) OR (abs(b) = 1) OR (c = 1))
-   ->  Seq Scan on mc3p7
+   ->  Seq Scan on mc3p7 mc3p_7
          Filter: ((a = 1) OR (abs(b) = 1) OR (c = 1))
-   ->  Seq Scan on mc3p_default
+   ->  Seq Scan on mc3p_default mc3p_8
          Filter: ((a = 1) OR (abs(b) = 1) OR (c = 1))
 (19 rows)
 
@@ -916,17 +916,17 @@ explain (costs off) select * from mc3p where (a = 1 and abs(b) = 1) or (a = 10 a
                                   QUERY PLAN                                  
 ------------------------------------------------------------------------------
  Append
-   ->  Seq Scan on mc3p0
+   ->  Seq Scan on mc3p0 mc3p
          Filter: (((a = 1) AND (abs(b) = 1)) OR ((a = 10) AND (abs(b) = 10)))
-   ->  Seq Scan on mc3p1
+   ->  Seq Scan on mc3p1 mc3p_1
          Filter: (((a = 1) AND (abs(b) = 1)) OR ((a = 10) AND (abs(b) = 10)))
-   ->  Seq Scan on mc3p2
+   ->  Seq Scan on mc3p2 mc3p_2
          Filter: (((a = 1) AND (abs(b) = 1)) OR ((a = 10) AND (abs(b) = 10)))
-   ->  Seq Scan on mc3p3
+   ->  Seq Scan on mc3p3 mc3p_3
          Filter: (((a = 1) AND (abs(b) = 1)) OR ((a = 10) AND (abs(b) = 10)))
-   ->  Seq Scan on mc3p4
+   ->  Seq Scan on mc3p4 mc3p_4
          Filter: (((a = 1) AND (abs(b) = 1)) OR ((a = 10) AND (abs(b) = 10)))
-   ->  Seq Scan on mc3p_default
+   ->  Seq Scan on mc3p_default mc3p_5
          Filter: (((a = 1) AND (abs(b) = 1)) OR ((a = 10) AND (abs(b) = 10)))
 (13 rows)
 
@@ -934,13 +934,13 @@ explain (costs off) select * from mc3p where (a = 1 and abs(b) = 1) or (a = 10 a
                                  QUERY PLAN                                  
 -----------------------------------------------------------------------------
  Append
-   ->  Seq Scan on mc3p0
+   ->  Seq Scan on mc3p0 mc3p
          Filter: (((a = 1) AND (abs(b) = 1)) OR ((a = 10) AND (abs(b) = 9)))
-   ->  Seq Scan on mc3p1
+   ->  Seq Scan on mc3p1 mc3p_1
          Filter: (((a = 1) AND (abs(b) = 1)) OR ((a = 10) AND (abs(b) = 9)))
-   ->  Seq Scan on mc3p2
+   ->  Seq Scan on mc3p2 mc3p_2
          Filter: (((a = 1) AND (abs(b) = 1)) OR ((a = 10) AND (abs(b) = 9)))
-   ->  Seq Scan on mc3p_default
+   ->  Seq Scan on mc3p_default mc3p_3
          Filter: (((a = 1) AND (abs(b) = 1)) OR ((a = 10) AND (abs(b) = 9)))
 (9 rows)
 
@@ -954,46 +954,46 @@ create table mc2p3 partition of mc2p for values from (2, minvalue) to (2, 1);
 create table mc2p4 partition of mc2p for values from (2, 1) to (2, maxvalue);
 create table mc2p5 partition of mc2p for values from (2, maxvalue) to (maxvalue, maxvalue);
 explain (costs off) select * from mc2p where a < 2;
-           QUERY PLAN           
---------------------------------
+              QUERY PLAN               
+---------------------------------------
  Append
-   ->  Seq Scan on mc2p0
+   ->  Seq Scan on mc2p0 mc2p
          Filter: (a < 2)
-   ->  Seq Scan on mc2p1
+   ->  Seq Scan on mc2p1 mc2p_1
          Filter: (a < 2)
-   ->  Seq Scan on mc2p2
+   ->  Seq Scan on mc2p2 mc2p_2
          Filter: (a < 2)
-   ->  Seq Scan on mc2p_default
+   ->  Seq Scan on mc2p_default mc2p_3
          Filter: (a < 2)
 (9 rows)
 
 explain (costs off) select * from mc2p where a = 2 and b < 1;
            QUERY PLAN            
 ---------------------------------
- Seq Scan on mc2p3
+ Seq Scan on mc2p3 mc2p
    Filter: ((b < 1) AND (a = 2))
 (2 rows)
 
 explain (costs off) select * from mc2p where a > 1;
-           QUERY PLAN           
---------------------------------
+              QUERY PLAN               
+---------------------------------------
  Append
-   ->  Seq Scan on mc2p2
+   ->  Seq Scan on mc2p2 mc2p
          Filter: (a > 1)
-   ->  Seq Scan on mc2p3
+   ->  Seq Scan on mc2p3 mc2p_1
          Filter: (a > 1)
-   ->  Seq Scan on mc2p4
+   ->  Seq Scan on mc2p4 mc2p_2
          Filter: (a > 1)
-   ->  Seq Scan on mc2p5
+   ->  Seq Scan on mc2p5 mc2p_3
          Filter: (a > 1)
-   ->  Seq Scan on mc2p_default
+   ->  Seq Scan on mc2p_default mc2p_4
          Filter: (a > 1)
 (11 rows)
 
 explain (costs off) select * from mc2p where a = 1 and b > 1;
            QUERY PLAN            
 ---------------------------------
- Seq Scan on mc2p2
+ Seq Scan on mc2p2 mc2p
    Filter: ((b > 1) AND (a = 1))
 (2 rows)
 
@@ -1001,35 +1001,35 @@ explain (costs off) select * from mc2p where a = 1 and b > 1;
 explain (costs off) select * from mc2p where a = 1 and b is null;
              QUERY PLAN              
 -------------------------------------
- Seq Scan on mc2p_default
+ Seq Scan on mc2p_default mc2p
    Filter: ((b IS NULL) AND (a = 1))
 (2 rows)
 
 explain (costs off) select * from mc2p where a is null and b is null;
                QUERY PLAN                
 -----------------------------------------
- Seq Scan on mc2p_default
+ Seq Scan on mc2p_default mc2p
    Filter: ((a IS NULL) AND (b IS NULL))
 (2 rows)
 
 explain (costs off) select * from mc2p where a is null and b = 1;
              QUERY PLAN              
 -------------------------------------
- Seq Scan on mc2p_default
+ Seq Scan on mc2p_default mc2p
    Filter: ((a IS NULL) AND (b = 1))
 (2 rows)
 
 explain (costs off) select * from mc2p where a is null;
-        QUERY PLAN        
---------------------------
- Seq Scan on mc2p_default
+          QUERY PLAN           
+-------------------------------
+ Seq Scan on mc2p_default mc2p
    Filter: (a IS NULL)
 (2 rows)
 
 explain (costs off) select * from mc2p where b is null;
-        QUERY PLAN        
---------------------------
- Seq Scan on mc2p_default
+          QUERY PLAN           
+-------------------------------
+ Seq Scan on mc2p_default mc2p
    Filter: (b IS NULL)
 (2 rows)
 
@@ -1042,23 +1042,23 @@ explain (costs off) select * from boolpart where a in (true, false);
                    QUERY PLAN                   
 ------------------------------------------------
  Append
-   ->  Seq Scan on boolpart_f
+   ->  Seq Scan on boolpart_f boolpart
          Filter: (a = ANY ('{t,f}'::boolean[]))
-   ->  Seq Scan on boolpart_t
+   ->  Seq Scan on boolpart_t boolpart_1
          Filter: (a = ANY ('{t,f}'::boolean[]))
 (5 rows)
 
 explain (costs off) select * from boolpart where a = false;
-       QUERY PLAN       
-------------------------
- Seq Scan on boolpart_f
+           QUERY PLAN            
+---------------------------------
+ Seq Scan on boolpart_f boolpart
    Filter: (NOT a)
 (2 rows)
 
 explain (costs off) select * from boolpart where not a = false;
-       QUERY PLAN       
-------------------------
- Seq Scan on boolpart_t
+           QUERY PLAN            
+---------------------------------
+ Seq Scan on boolpart_t boolpart
    Filter: a
 (2 rows)
 
@@ -1066,16 +1066,16 @@ explain (costs off) select * from boolpart where a is true or a is not true;
                     QUERY PLAN                    
 --------------------------------------------------
  Append
-   ->  Seq Scan on boolpart_f
+   ->  Seq Scan on boolpart_f boolpart
          Filter: ((a IS TRUE) OR (a IS NOT TRUE))
-   ->  Seq Scan on boolpart_t
+   ->  Seq Scan on boolpart_t boolpart_1
          Filter: ((a IS TRUE) OR (a IS NOT TRUE))
 (5 rows)
 
 explain (costs off) select * from boolpart where a is not true;
-        QUERY PLAN         
----------------------------
- Seq Scan on boolpart_f
+           QUERY PLAN            
+---------------------------------
+ Seq Scan on boolpart_f boolpart
    Filter: (a IS NOT TRUE)
 (2 rows)
 
@@ -1087,26 +1087,26 @@ explain (costs off) select * from boolpart where a is not true and a is not fals
 (2 rows)
 
 explain (costs off) select * from boolpart where a is unknown;
-             QUERY PLAN             
-------------------------------------
+                  QUERY PLAN                   
+-----------------------------------------------
  Append
-   ->  Seq Scan on boolpart_f
+   ->  Seq Scan on boolpart_f boolpart
          Filter: (a IS UNKNOWN)
-   ->  Seq Scan on boolpart_t
+   ->  Seq Scan on boolpart_t boolpart_1
          Filter: (a IS UNKNOWN)
-   ->  Seq Scan on boolpart_default
+   ->  Seq Scan on boolpart_default boolpart_2
          Filter: (a IS UNKNOWN)
 (7 rows)
 
 explain (costs off) select * from boolpart where a is not unknown;
-             QUERY PLAN             
-------------------------------------
+                  QUERY PLAN                   
+-----------------------------------------------
  Append
-   ->  Seq Scan on boolpart_f
+   ->  Seq Scan on boolpart_f boolpart
          Filter: (a IS NOT UNKNOWN)
-   ->  Seq Scan on boolpart_t
+   ->  Seq Scan on boolpart_t boolpart_1
          Filter: (a IS NOT UNKNOWN)
-   ->  Seq Scan on boolpart_default
+   ->  Seq Scan on boolpart_default boolpart_2
          Filter: (a IS NOT UNKNOWN)
 (7 rows)
 
@@ -1119,7 +1119,7 @@ create table boolrangep_ff2 partition of boolrangep for values from ('false', 'f
 explain (costs off)  select * from boolrangep where not a and not b and c = 25;
                   QUERY PLAN                  
 ----------------------------------------------
- Seq Scan on boolrangep_ff1
+ Seq Scan on boolrangep_ff1 boolrangep
    Filter: ((NOT a) AND (NOT b) AND (c = 25))
 (2 rows)
 
@@ -1132,11 +1132,11 @@ explain (costs off) select * from coercepart where a in ('ab', to_char(125, '999
                                                           QUERY PLAN                                                          
 ------------------------------------------------------------------------------------------------------------------------------
  Append
-   ->  Seq Scan on coercepart_ab
+   ->  Seq Scan on coercepart_ab coercepart
          Filter: ((a)::text = ANY ((ARRAY['ab'::character varying, (to_char(125, '999'::text))::character varying])::text[]))
-   ->  Seq Scan on coercepart_bc
+   ->  Seq Scan on coercepart_bc coercepart_1
          Filter: ((a)::text = ANY ((ARRAY['ab'::character varying, (to_char(125, '999'::text))::character varying])::text[]))
-   ->  Seq Scan on coercepart_cd
+   ->  Seq Scan on coercepart_cd coercepart_2
          Filter: ((a)::text = ANY ((ARRAY['ab'::character varying, (to_char(125, '999'::text))::character varying])::text[]))
 (7 rows)
 
@@ -1144,11 +1144,11 @@ explain (costs off) select * from coercepart where a ~ any ('{ab}');
                      QUERY PLAN                     
 ----------------------------------------------------
  Append
-   ->  Seq Scan on coercepart_ab
+   ->  Seq Scan on coercepart_ab coercepart
          Filter: ((a)::text ~ ANY ('{ab}'::text[]))
-   ->  Seq Scan on coercepart_bc
+   ->  Seq Scan on coercepart_bc coercepart_1
          Filter: ((a)::text ~ ANY ('{ab}'::text[]))
-   ->  Seq Scan on coercepart_cd
+   ->  Seq Scan on coercepart_cd coercepart_2
          Filter: ((a)::text ~ ANY ('{ab}'::text[]))
 (7 rows)
 
@@ -1156,11 +1156,11 @@ explain (costs off) select * from coercepart where a !~ all ('{ab}');
                      QUERY PLAN                      
 -----------------------------------------------------
  Append
-   ->  Seq Scan on coercepart_ab
+   ->  Seq Scan on coercepart_ab coercepart
          Filter: ((a)::text !~ ALL ('{ab}'::text[]))
-   ->  Seq Scan on coercepart_bc
+   ->  Seq Scan on coercepart_bc coercepart_1
          Filter: ((a)::text !~ ALL ('{ab}'::text[]))
-   ->  Seq Scan on coercepart_cd
+   ->  Seq Scan on coercepart_cd coercepart_2
          Filter: ((a)::text !~ ALL ('{ab}'::text[]))
 (7 rows)
 
@@ -1168,11 +1168,11 @@ explain (costs off) select * from coercepart where a ~ any ('{ab,bc}');
                       QUERY PLAN                       
 -------------------------------------------------------
  Append
-   ->  Seq Scan on coercepart_ab
+   ->  Seq Scan on coercepart_ab coercepart
          Filter: ((a)::text ~ ANY ('{ab,bc}'::text[]))
-   ->  Seq Scan on coercepart_bc
+   ->  Seq Scan on coercepart_bc coercepart_1
          Filter: ((a)::text ~ ANY ('{ab,bc}'::text[]))
-   ->  Seq Scan on coercepart_cd
+   ->  Seq Scan on coercepart_cd coercepart_2
          Filter: ((a)::text ~ ANY ('{ab,bc}'::text[]))
 (7 rows)
 
@@ -1180,11 +1180,11 @@ explain (costs off) select * from coercepart where a !~ all ('{ab,bc}');
                        QUERY PLAN                       
 --------------------------------------------------------
  Append
-   ->  Seq Scan on coercepart_ab
+   ->  Seq Scan on coercepart_ab coercepart
          Filter: ((a)::text !~ ALL ('{ab,bc}'::text[]))
-   ->  Seq Scan on coercepart_bc
+   ->  Seq Scan on coercepart_bc coercepart_1
          Filter: ((a)::text !~ ALL ('{ab,bc}'::text[]))
-   ->  Seq Scan on coercepart_cd
+   ->  Seq Scan on coercepart_cd coercepart_2
          Filter: ((a)::text !~ ALL ('{ab,bc}'::text[]))
 (7 rows)
 
@@ -1192,16 +1192,16 @@ explain (costs off) select * from coercepart where a = any ('{ab,bc}');
                       QUERY PLAN                       
 -------------------------------------------------------
  Append
-   ->  Seq Scan on coercepart_ab
+   ->  Seq Scan on coercepart_ab coercepart
          Filter: ((a)::text = ANY ('{ab,bc}'::text[]))
-   ->  Seq Scan on coercepart_bc
+   ->  Seq Scan on coercepart_bc coercepart_1
          Filter: ((a)::text = ANY ('{ab,bc}'::text[]))
 (5 rows)
 
 explain (costs off) select * from coercepart where a = any ('{ab,null}');
                     QUERY PLAN                     
 ---------------------------------------------------
- Seq Scan on coercepart_ab
+ Seq Scan on coercepart_ab coercepart
    Filter: ((a)::text = ANY ('{ab,NULL}'::text[]))
 (2 rows)
 
@@ -1215,7 +1215,7 @@ explain (costs off) select * from coercepart where a = any (null::text[]);
 explain (costs off) select * from coercepart where a = all ('{ab}');
                   QUERY PLAN                  
 ----------------------------------------------
- Seq Scan on coercepart_ab
+ Seq Scan on coercepart_ab coercepart
    Filter: ((a)::text = ALL ('{ab}'::text[]))
 (2 rows)
 
@@ -1245,16 +1245,37 @@ CREATE TABLE part (a INT, b INT) PARTITION BY LIST (a);
 CREATE TABLE part_p1 PARTITION OF part FOR VALUES IN (-2,-1,0,1,2);
 CREATE TABLE part_p2 PARTITION OF part DEFAULT PARTITION BY RANGE(a);
 CREATE TABLE part_p2_p1 PARTITION OF part_p2 DEFAULT;
+CREATE TABLE part_rev (b INT, c INT, a INT);
+ALTER TABLE part ATTACH PARTITION part_rev FOR VALUES IN (3);  -- fail
+ERROR:  table "part_rev" contains column "c" not found in parent "part"
+DETAIL:  The new partition may contain only the columns present in parent.
+ALTER TABLE part_rev DROP COLUMN c;
+ALTER TABLE part ATTACH PARTITION part_rev FOR VALUES IN (3);  -- now it's ok
 INSERT INTO part VALUES (-1,-1), (1,1), (2,NULL), (NULL,-2),(NULL,NULL);
 EXPLAIN (COSTS OFF) SELECT tableoid::regclass as part, a, b FROM part WHERE a IS NULL ORDER BY 1, 2, 3;
-                                QUERY PLAN                                 
----------------------------------------------------------------------------
+                       QUERY PLAN                        
+---------------------------------------------------------
  Sort
-   Sort Key: ((part_p2_p1.tableoid)::regclass), part_p2_p1.a, part_p2_p1.b
-   ->  Seq Scan on part_p2_p1
+   Sort Key: ((part.tableoid)::regclass), part.a, part.b
+   ->  Seq Scan on part_p2_p1 part
          Filter: (a IS NULL)
 (4 rows)
 
+EXPLAIN (VERBOSE, COSTS OFF) SELECT * FROM part p(x) ORDER BY x;
+                  QUERY PLAN                   
+-----------------------------------------------
+ Sort
+   Output: p.x, p.b
+   Sort Key: p.x
+   ->  Append
+         ->  Seq Scan on public.part_p1 p
+               Output: p.x, p.b
+         ->  Seq Scan on public.part_rev p_1
+               Output: p_1.x, p_1.b
+         ->  Seq Scan on public.part_p2_p1 p_2
+               Output: p_2.x, p_2.b
+(10 rows)
+
 --
 -- some more cases
 --
@@ -1344,14 +1365,14 @@ create table rp0 partition of rp for values from (minvalue) to (1);
 create table rp1 partition of rp for values from (1) to (2);
 create table rp2 partition of rp for values from (2) to (maxvalue);
 explain (costs off) select * from rp where a <> 1;
-        QUERY PLAN        
---------------------------
+         QUERY PLAN         
+----------------------------
  Append
-   ->  Seq Scan on rp0
+   ->  Seq Scan on rp0 rp
          Filter: (a <> 1)
-   ->  Seq Scan on rp1
+   ->  Seq Scan on rp1 rp_1
          Filter: (a <> 1)
-   ->  Seq Scan on rp2
+   ->  Seq Scan on rp2 rp_2
          Filter: (a <> 1)
 (7 rows)
 
@@ -1359,11 +1380,11 @@ explain (costs off) select * from rp where a <> 1 and a <> 2;
                QUERY PLAN                
 -----------------------------------------
  Append
-   ->  Seq Scan on rp0
+   ->  Seq Scan on rp0 rp
          Filter: ((a <> 1) AND (a <> 2))
-   ->  Seq Scan on rp1
+   ->  Seq Scan on rp1 rp_1
          Filter: ((a <> 1) AND (a <> 2))
-   ->  Seq Scan on rp2
+   ->  Seq Scan on rp2 rp_2
          Filter: ((a <> 1) AND (a <> 2))
 (7 rows)
 
@@ -1372,15 +1393,15 @@ explain (costs off) select * from lp where a <> 'a';
              QUERY PLAN             
 ------------------------------------
  Append
-   ->  Seq Scan on lp_ad
+   ->  Seq Scan on lp_ad lp
          Filter: (a <> 'a'::bpchar)
-   ->  Seq Scan on lp_bc
+   ->  Seq Scan on lp_bc lp_1
          Filter: (a <> 'a'::bpchar)
-   ->  Seq Scan on lp_ef
+   ->  Seq Scan on lp_ef lp_2
          Filter: (a <> 'a'::bpchar)
-   ->  Seq Scan on lp_g
+   ->  Seq Scan on lp_g lp_3
          Filter: (a <> 'a'::bpchar)
-   ->  Seq Scan on lp_default
+   ->  Seq Scan on lp_default lp_4
          Filter: (a <> 'a'::bpchar)
 (11 rows)
 
@@ -1396,15 +1417,15 @@ explain (costs off) select * from lp where (a <> 'a' and a <> 'd') or a is null;
                                   QUERY PLAN                                  
 ------------------------------------------------------------------------------
  Append
-   ->  Seq Scan on lp_bc
+   ->  Seq Scan on lp_bc lp
          Filter: (((a <> 'a'::bpchar) AND (a <> 'd'::bpchar)) OR (a IS NULL))
-   ->  Seq Scan on lp_ef
+   ->  Seq Scan on lp_ef lp_1
          Filter: (((a <> 'a'::bpchar) AND (a <> 'd'::bpchar)) OR (a IS NULL))
-   ->  Seq Scan on lp_g
+   ->  Seq Scan on lp_g lp_2
          Filter: (((a <> 'a'::bpchar) AND (a <> 'd'::bpchar)) OR (a IS NULL))
-   ->  Seq Scan on lp_null
+   ->  Seq Scan on lp_null lp_3
          Filter: (((a <> 'a'::bpchar) AND (a <> 'd'::bpchar)) OR (a IS NULL))
-   ->  Seq Scan on lp_default
+   ->  Seq Scan on lp_default lp_4
          Filter: (((a <> 'a'::bpchar) AND (a <> 'd'::bpchar)) OR (a IS NULL))
 (11 rows)
 
@@ -1415,9 +1436,9 @@ explain (costs off) select * from rlp where a = 15 and b <> 'ab' and b <> 'cd' a
                                                                 QUERY PLAN                                                                
 ------------------------------------------------------------------------------------------------------------------------------------------
  Append
-   ->  Seq Scan on rlp3efgh
+   ->  Seq Scan on rlp3efgh rlp
          Filter: ((b IS NOT NULL) AND ((b)::text <> 'ab'::text) AND ((b)::text <> 'cd'::text) AND ((b)::text <> 'xy'::text) AND (a = 15))
-   ->  Seq Scan on rlp3_default
+   ->  Seq Scan on rlp3_default rlp_1
          Filter: ((b IS NOT NULL) AND ((b)::text <> 'ab'::text) AND ((b)::text <> 'cd'::text) AND ((b)::text <> 'xy'::text) AND (a = 15))
 (5 rows)
 
@@ -1430,14 +1451,14 @@ create table coll_pruning_multi2 partition of coll_pruning_multi for values from
 create table coll_pruning_multi3 partition of coll_pruning_multi for values from ('b', 'a') to ('b', 'e');
 -- no pruning, because no value for the leading key
 explain (costs off) select * from coll_pruning_multi where substr(a, 1) = 'e' collate "C";
-                       QUERY PLAN                       
---------------------------------------------------------
+                         QUERY PLAN                         
+------------------------------------------------------------
  Append
-   ->  Seq Scan on coll_pruning_multi1
+   ->  Seq Scan on coll_pruning_multi1 coll_pruning_multi
          Filter: (substr(a, 1) = 'e'::text COLLATE "C")
-   ->  Seq Scan on coll_pruning_multi2
+   ->  Seq Scan on coll_pruning_multi2 coll_pruning_multi_1
          Filter: (substr(a, 1) = 'e'::text COLLATE "C")
-   ->  Seq Scan on coll_pruning_multi3
+   ->  Seq Scan on coll_pruning_multi3 coll_pruning_multi_2
          Filter: (substr(a, 1) = 'e'::text COLLATE "C")
 (7 rows)
 
@@ -1446,9 +1467,9 @@ explain (costs off) select * from coll_pruning_multi where substr(a, 1) = 'a' co
                          QUERY PLAN                         
 ------------------------------------------------------------
  Append
-   ->  Seq Scan on coll_pruning_multi1
+   ->  Seq Scan on coll_pruning_multi1 coll_pruning_multi
          Filter: (substr(a, 1) = 'a'::text COLLATE "POSIX")
-   ->  Seq Scan on coll_pruning_multi2
+   ->  Seq Scan on coll_pruning_multi2 coll_pruning_multi_1
          Filter: (substr(a, 1) = 'a'::text COLLATE "POSIX")
 (5 rows)
 
@@ -1456,7 +1477,7 @@ explain (costs off) select * from coll_pruning_multi where substr(a, 1) = 'a' co
 explain (costs off) select * from coll_pruning_multi where substr(a, 1) = 'e' collate "C" and substr(a, 1) = 'a' collate "POSIX";
                                             QUERY PLAN                                             
 ---------------------------------------------------------------------------------------------------
- Seq Scan on coll_pruning_multi2
+ Seq Scan on coll_pruning_multi2 coll_pruning_multi
    Filter: ((substr(a, 1) = 'e'::text COLLATE "C") AND (substr(a, 1) = 'a'::text COLLATE "POSIX"))
 (2 rows)
 
@@ -1467,12 +1488,12 @@ create table like_op_noprune (a text) partition by list (a);
 create table like_op_noprune1 partition of like_op_noprune for values in ('ABC');
 create table like_op_noprune2 partition of like_op_noprune for values in ('BCD');
 explain (costs off) select * from like_op_noprune where a like '%BC';
-             QUERY PLAN             
-------------------------------------
+                      QUERY PLAN                      
+------------------------------------------------------
  Append
-   ->  Seq Scan on like_op_noprune1
+   ->  Seq Scan on like_op_noprune1 like_op_noprune
          Filter: (a ~~ '%BC'::text)
-   ->  Seq Scan on like_op_noprune2
+   ->  Seq Scan on like_op_noprune2 like_op_noprune_1
          Filter: (a ~~ '%BC'::text)
 (5 rows)
 
@@ -1503,9 +1524,9 @@ explain (costs off) select * from rparted_by_int2 where a > 100000000000000;
 create table rparted_by_int2_maxvalue partition of rparted_by_int2 for values from (16384) to (maxvalue);
 -- all partitions but rparted_by_int2_maxvalue pruned
 explain (costs off) select * from rparted_by_int2 where a > 100000000000000;
-                QUERY PLAN                 
--------------------------------------------
- Seq Scan on rparted_by_int2_maxvalue
+                      QUERY PLAN                      
+------------------------------------------------------
+ Seq Scan on rparted_by_int2_maxvalue rparted_by_int2
    Filter: (a > '100000000000000'::bigint)
 (2 rows)
 
@@ -1541,16 +1562,16 @@ select tableoid::regclass, * from hp order by 1;
 
 -- partial keys won't prune, nor would non-equality conditions
 explain (costs off) select * from hp where a = 1;
-       QUERY PLAN        
--------------------------
+         QUERY PLAN         
+----------------------------
  Append
-   ->  Seq Scan on hp0
+   ->  Seq Scan on hp0 hp
          Filter: (a = 1)
-   ->  Seq Scan on hp1
+   ->  Seq Scan on hp1 hp_1
          Filter: (a = 1)
-   ->  Seq Scan on hp2
+   ->  Seq Scan on hp2 hp_2
          Filter: (a = 1)
-   ->  Seq Scan on hp3
+   ->  Seq Scan on hp3 hp_3
          Filter: (a = 1)
 (9 rows)
 
@@ -1558,13 +1579,13 @@ explain (costs off) select * from hp where b = 'xxx';
             QUERY PLAN             
 -----------------------------------
  Append
-   ->  Seq Scan on hp0
+   ->  Seq Scan on hp0 hp
          Filter: (b = 'xxx'::text)
-   ->  Seq Scan on hp1
+   ->  Seq Scan on hp1 hp_1
          Filter: (b = 'xxx'::text)
-   ->  Seq Scan on hp2
+   ->  Seq Scan on hp2 hp_2
          Filter: (b = 'xxx'::text)
-   ->  Seq Scan on hp3
+   ->  Seq Scan on hp3 hp_3
          Filter: (b = 'xxx'::text)
 (9 rows)
 
@@ -1572,13 +1593,13 @@ explain (costs off) select * from hp where a is null;
          QUERY PLAN          
 -----------------------------
  Append
-   ->  Seq Scan on hp0
+   ->  Seq Scan on hp0 hp
          Filter: (a IS NULL)
-   ->  Seq Scan on hp1
+   ->  Seq Scan on hp1 hp_1
          Filter: (a IS NULL)
-   ->  Seq Scan on hp2
+   ->  Seq Scan on hp2 hp_2
          Filter: (a IS NULL)
-   ->  Seq Scan on hp3
+   ->  Seq Scan on hp3 hp_3
          Filter: (a IS NULL)
 (9 rows)
 
@@ -1586,13 +1607,13 @@ explain (costs off) select * from hp where b is null;
          QUERY PLAN          
 -----------------------------
  Append
-   ->  Seq Scan on hp0
+   ->  Seq Scan on hp0 hp
          Filter: (b IS NULL)
-   ->  Seq Scan on hp1
+   ->  Seq Scan on hp1 hp_1
          Filter: (b IS NULL)
-   ->  Seq Scan on hp2
+   ->  Seq Scan on hp2 hp_2
          Filter: (b IS NULL)
-   ->  Seq Scan on hp3
+   ->  Seq Scan on hp3 hp_3
          Filter: (b IS NULL)
 (9 rows)
 
@@ -1600,13 +1621,13 @@ explain (costs off) select * from hp where a < 1 and b = 'xxx';
                    QUERY PLAN                    
 -------------------------------------------------
  Append
-   ->  Seq Scan on hp0
+   ->  Seq Scan on hp0 hp
          Filter: ((a < 1) AND (b = 'xxx'::text))
-   ->  Seq Scan on hp1
+   ->  Seq Scan on hp1 hp_1
          Filter: ((a < 1) AND (b = 'xxx'::text))
-   ->  Seq Scan on hp2
+   ->  Seq Scan on hp2 hp_2
          Filter: ((a < 1) AND (b = 'xxx'::text))
-   ->  Seq Scan on hp3
+   ->  Seq Scan on hp3 hp_3
          Filter: ((a < 1) AND (b = 'xxx'::text))
 (9 rows)
 
@@ -1614,13 +1635,13 @@ explain (costs off) select * from hp where a <> 1 and b = 'yyy';
                     QUERY PLAN                    
 --------------------------------------------------
  Append
-   ->  Seq Scan on hp0
+   ->  Seq Scan on hp0 hp
          Filter: ((a <> 1) AND (b = 'yyy'::text))
-   ->  Seq Scan on hp1
+   ->  Seq Scan on hp1 hp_1
          Filter: ((a <> 1) AND (b = 'yyy'::text))
-   ->  Seq Scan on hp2
+   ->  Seq Scan on hp2 hp_2
          Filter: ((a <> 1) AND (b = 'yyy'::text))
-   ->  Seq Scan on hp3
+   ->  Seq Scan on hp3 hp_3
          Filter: ((a <> 1) AND (b = 'yyy'::text))
 (9 rows)
 
@@ -1628,13 +1649,13 @@ explain (costs off) select * from hp where a <> 1 and b <> 'xxx';
                     QUERY PLAN                     
 ---------------------------------------------------
  Append
-   ->  Seq Scan on hp0
+   ->  Seq Scan on hp0 hp
          Filter: ((a <> 1) AND (b <> 'xxx'::text))
-   ->  Seq Scan on hp1
+   ->  Seq Scan on hp1 hp_1
          Filter: ((a <> 1) AND (b <> 'xxx'::text))
-   ->  Seq Scan on hp2
+   ->  Seq Scan on hp2 hp_2
          Filter: ((a <> 1) AND (b <> 'xxx'::text))
-   ->  Seq Scan on hp3
+   ->  Seq Scan on hp3 hp_3
          Filter: ((a <> 1) AND (b <> 'xxx'::text))
 (9 rows)
 
@@ -1643,42 +1664,42 @@ explain (costs off) select * from hp where a <> 1 and b <> 'xxx';
 explain (costs off) select * from hp where a is null and b is null;
                QUERY PLAN                
 -----------------------------------------
- Seq Scan on hp0
+ Seq Scan on hp0 hp
    Filter: ((a IS NULL) AND (b IS NULL))
 (2 rows)
 
 explain (costs off) select * from hp where a = 1 and b is null;
              QUERY PLAN              
 -------------------------------------
- Seq Scan on hp1
+ Seq Scan on hp1 hp
    Filter: ((b IS NULL) AND (a = 1))
 (2 rows)
 
 explain (costs off) select * from hp where a = 1 and b = 'xxx';
                 QUERY PLAN                 
 -------------------------------------------
- Seq Scan on hp0
+ Seq Scan on hp0 hp
    Filter: ((a = 1) AND (b = 'xxx'::text))
 (2 rows)
 
 explain (costs off) select * from hp where a is null and b = 'xxx';
                   QUERY PLAN                   
 -----------------------------------------------
- Seq Scan on hp2
+ Seq Scan on hp2 hp
    Filter: ((a IS NULL) AND (b = 'xxx'::text))
 (2 rows)
 
 explain (costs off) select * from hp where a = 2 and b = 'xxx';
                 QUERY PLAN                 
 -------------------------------------------
- Seq Scan on hp3
+ Seq Scan on hp3 hp
    Filter: ((a = 2) AND (b = 'xxx'::text))
 (2 rows)
 
 explain (costs off) select * from hp where a = 1 and b = 'abcde';
                  QUERY PLAN                  
 ---------------------------------------------
- Seq Scan on hp2
+ Seq Scan on hp2 hp
    Filter: ((a = 1) AND (b = 'abcde'::text))
 (2 rows)
 
@@ -1686,11 +1707,11 @@ explain (costs off) select * from hp where (a = 1 and b = 'abcde') or (a = 2 and
                                                        QUERY PLAN                                                        
 -------------------------------------------------------------------------------------------------------------------------
  Append
-   ->  Seq Scan on hp0
+   ->  Seq Scan on hp0 hp
          Filter: (((a = 1) AND (b = 'abcde'::text)) OR ((a = 2) AND (b = 'xxx'::text)) OR ((a IS NULL) AND (b IS NULL)))
-   ->  Seq Scan on hp2
+   ->  Seq Scan on hp2 hp_1
          Filter: (((a = 1) AND (b = 'abcde'::text)) OR ((a = 2) AND (b = 'xxx'::text)) OR ((a IS NULL) AND (b IS NULL)))
-   ->  Seq Scan on hp3
+   ->  Seq Scan on hp3 hp_2
          Filter: (((a = 1) AND (b = 'abcde'::text)) OR ((a = 2) AND (b = 'xxx'::text)) OR ((a IS NULL) AND (b IS NULL)))
 (7 rows)
 
@@ -1722,11 +1743,11 @@ explain (analyze, costs off, summary off, timing off) execute ab_q1 (2, 2, 3);
 ---------------------------------------------------------
  Append (actual rows=0 loops=1)
    Subplans Removed: 6
-   ->  Seq Scan on ab_a2_b1 (actual rows=0 loops=1)
+   ->  Seq Scan on ab_a2_b1 ab (actual rows=0 loops=1)
          Filter: ((a >= $1) AND (a <= $2) AND (b <= $3))
-   ->  Seq Scan on ab_a2_b2 (actual rows=0 loops=1)
+   ->  Seq Scan on ab_a2_b2 ab_1 (actual rows=0 loops=1)
          Filter: ((a >= $1) AND (a <= $2) AND (b <= $3))
-   ->  Seq Scan on ab_a2_b3 (actual rows=0 loops=1)
+   ->  Seq Scan on ab_a2_b3 ab_2 (actual rows=0 loops=1)
          Filter: ((a >= $1) AND (a <= $2) AND (b <= $3))
 (8 rows)
 
@@ -1735,17 +1756,17 @@ explain (analyze, costs off, summary off, timing off) execute ab_q1 (1, 2, 3);
 ---------------------------------------------------------
  Append (actual rows=0 loops=1)
    Subplans Removed: 3
-   ->  Seq Scan on ab_a1_b1 (actual rows=0 loops=1)
+   ->  Seq Scan on ab_a1_b1 ab (actual rows=0 loops=1)
          Filter: ((a >= $1) AND (a <= $2) AND (b <= $3))
-   ->  Seq Scan on ab_a1_b2 (actual rows=0 loops=1)
+   ->  Seq Scan on ab_a1_b2 ab_1 (actual rows=0 loops=1)
          Filter: ((a >= $1) AND (a <= $2) AND (b <= $3))
-   ->  Seq Scan on ab_a1_b3 (actual rows=0 loops=1)
+   ->  Seq Scan on ab_a1_b3 ab_2 (actual rows=0 loops=1)
          Filter: ((a >= $1) AND (a <= $2) AND (b <= $3))
-   ->  Seq Scan on ab_a2_b1 (actual rows=0 loops=1)
+   ->  Seq Scan on ab_a2_b1 ab_3 (actual rows=0 loops=1)
          Filter: ((a >= $1) AND (a <= $2) AND (b <= $3))
-   ->  Seq Scan on ab_a2_b2 (actual rows=0 loops=1)
+   ->  Seq Scan on ab_a2_b2 ab_4 (actual rows=0 loops=1)
          Filter: ((a >= $1) AND (a <= $2) AND (b <= $3))
-   ->  Seq Scan on ab_a2_b3 (actual rows=0 loops=1)
+   ->  Seq Scan on ab_a2_b3 ab_5 (actual rows=0 loops=1)
          Filter: ((a >= $1) AND (a <= $2) AND (b <= $3))
 (14 rows)
 
@@ -1754,28 +1775,28 @@ deallocate ab_q1;
 prepare ab_q1 (int, int) as
 select a from ab where a between $1 and $2 and b < 3;
 explain (analyze, costs off, summary off, timing off) execute ab_q1 (2, 2);
-                      QUERY PLAN                       
--------------------------------------------------------
+                       QUERY PLAN                        
+---------------------------------------------------------
  Append (actual rows=0 loops=1)
    Subplans Removed: 4
-   ->  Seq Scan on ab_a2_b1 (actual rows=0 loops=1)
+   ->  Seq Scan on ab_a2_b1 ab (actual rows=0 loops=1)
          Filter: ((a >= $1) AND (a <= $2) AND (b < 3))
-   ->  Seq Scan on ab_a2_b2 (actual rows=0 loops=1)
+   ->  Seq Scan on ab_a2_b2 ab_1 (actual rows=0 loops=1)
          Filter: ((a >= $1) AND (a <= $2) AND (b < 3))
 (6 rows)
 
 explain (analyze, costs off, summary off, timing off) execute ab_q1 (2, 4);
-                      QUERY PLAN                       
--------------------------------------------------------
+                       QUERY PLAN                        
+---------------------------------------------------------
  Append (actual rows=0 loops=1)
    Subplans Removed: 2
-   ->  Seq Scan on ab_a2_b1 (actual rows=0 loops=1)
+   ->  Seq Scan on ab_a2_b1 ab (actual rows=0 loops=1)
          Filter: ((a >= $1) AND (a <= $2) AND (b < 3))
-   ->  Seq Scan on ab_a2_b2 (actual rows=0 loops=1)
+   ->  Seq Scan on ab_a2_b2 ab_1 (actual rows=0 loops=1)
          Filter: ((a >= $1) AND (a <= $2) AND (b < 3))
-   ->  Seq Scan on ab_a3_b1 (actual rows=0 loops=1)
+   ->  Seq Scan on ab_a3_b1 ab_2 (actual rows=0 loops=1)
          Filter: ((a >= $1) AND (a <= $2) AND (b < 3))
-   ->  Seq Scan on ab_a3_b2 (actual rows=0 loops=1)
+   ->  Seq Scan on ab_a3_b2 ab_3 (actual rows=0 loops=1)
          Filter: ((a >= $1) AND (a <= $2) AND (b < 3))
 (10 rows)
 
@@ -1784,17 +1805,17 @@ explain (analyze, costs off, summary off, timing off) execute ab_q1 (2, 4);
 prepare ab_q2 (int, int) as
 select a from ab where a between $1 and $2 and b < (select 3);
 explain (analyze, costs off, summary off, timing off) execute ab_q2 (2, 2);
-                       QUERY PLAN                       
---------------------------------------------------------
+                       QUERY PLAN                        
+---------------------------------------------------------
  Append (actual rows=0 loops=1)
    InitPlan 1 (returns $0)
      ->  Result (actual rows=1 loops=1)
    Subplans Removed: 6
-   ->  Seq Scan on ab_a2_b1 (actual rows=0 loops=1)
+   ->  Seq Scan on ab_a2_b1 ab (actual rows=0 loops=1)
          Filter: ((a >= $1) AND (a <= $2) AND (b < $0))
-   ->  Seq Scan on ab_a2_b2 (actual rows=0 loops=1)
+   ->  Seq Scan on ab_a2_b2 ab_1 (actual rows=0 loops=1)
          Filter: ((a >= $1) AND (a <= $2) AND (b < $0))
-   ->  Seq Scan on ab_a2_b3 (never executed)
+   ->  Seq Scan on ab_a2_b3 ab_2 (never executed)
          Filter: ((a >= $1) AND (a <= $2) AND (b < $0))
 (10 rows)
 
@@ -1802,17 +1823,17 @@ explain (analyze, costs off, summary off, timing off) execute ab_q2 (2, 2);
 prepare ab_q3 (int, int) as
 select a from ab where b between $1 and $2 and a < (select 3);
 explain (analyze, costs off, summary off, timing off) execute ab_q3 (2, 2);
-                       QUERY PLAN                       
---------------------------------------------------------
+                       QUERY PLAN                        
+---------------------------------------------------------
  Append (actual rows=0 loops=1)
    InitPlan 1 (returns $0)
      ->  Result (actual rows=1 loops=1)
    Subplans Removed: 6
-   ->  Seq Scan on ab_a1_b2 (actual rows=0 loops=1)
+   ->  Seq Scan on ab_a1_b2 ab (actual rows=0 loops=1)
          Filter: ((b >= $1) AND (b <= $2) AND (a < $0))
-   ->  Seq Scan on ab_a2_b2 (actual rows=0 loops=1)
+   ->  Seq Scan on ab_a2_b2 ab_1 (actual rows=0 loops=1)
          Filter: ((b >= $1) AND (b <= $2) AND (a < $0))
-   ->  Seq Scan on ab_a3_b2 (never executed)
+   ->  Seq Scan on ab_a3_b2 ab_2 (never executed)
          Filter: ((b >= $1) AND (b <= $2) AND (a < $0))
 (10 rows)
 
@@ -1843,44 +1864,44 @@ begin;
 create function list_part_fn(int) returns int as $$ begin return $1; end;$$ language plpgsql stable;
 -- Ensure pruning works using a stable function containing no Vars
 explain (analyze, costs off, summary off, timing off) select * from list_part where a = list_part_fn(1);
-                      QUERY PLAN                      
-------------------------------------------------------
+                           QUERY PLAN                           
+----------------------------------------------------------------
  Append (actual rows=1 loops=1)
    Subplans Removed: 3
-   ->  Seq Scan on list_part1 (actual rows=1 loops=1)
+   ->  Seq Scan on list_part1 list_part (actual rows=1 loops=1)
          Filter: (a = list_part_fn(1))
 (4 rows)
 
 -- Ensure pruning does not take place when the function has a Var parameter
 explain (analyze, costs off, summary off, timing off) select * from list_part where a = list_part_fn(a);
-                      QUERY PLAN                      
-------------------------------------------------------
+                            QUERY PLAN                            
+------------------------------------------------------------------
  Append (actual rows=4 loops=1)
-   ->  Seq Scan on list_part1 (actual rows=1 loops=1)
+   ->  Seq Scan on list_part1 list_part (actual rows=1 loops=1)
          Filter: (a = list_part_fn(a))
-   ->  Seq Scan on list_part2 (actual rows=1 loops=1)
+   ->  Seq Scan on list_part2 list_part_1 (actual rows=1 loops=1)
          Filter: (a = list_part_fn(a))
-   ->  Seq Scan on list_part3 (actual rows=1 loops=1)
+   ->  Seq Scan on list_part3 list_part_2 (actual rows=1 loops=1)
          Filter: (a = list_part_fn(a))
-   ->  Seq Scan on list_part4 (actual rows=1 loops=1)
+   ->  Seq Scan on list_part4 list_part_3 (actual rows=1 loops=1)
          Filter: (a = list_part_fn(a))
 (9 rows)
 
 -- Ensure pruning does not take place when the expression contains a Var.
 explain (analyze, costs off, summary off, timing off) select * from list_part where a = list_part_fn(1) + a;
-                      QUERY PLAN                      
-------------------------------------------------------
+                            QUERY PLAN                            
+------------------------------------------------------------------
  Append (actual rows=0 loops=1)
-   ->  Seq Scan on list_part1 (actual rows=0 loops=1)
+   ->  Seq Scan on list_part1 list_part (actual rows=0 loops=1)
          Filter: (a = (list_part_fn(1) + a))
          Rows Removed by Filter: 1
-   ->  Seq Scan on list_part2 (actual rows=0 loops=1)
+   ->  Seq Scan on list_part2 list_part_1 (actual rows=0 loops=1)
          Filter: (a = (list_part_fn(1) + a))
          Rows Removed by Filter: 1
-   ->  Seq Scan on list_part3 (actual rows=0 loops=1)
+   ->  Seq Scan on list_part3 list_part_2 (actual rows=0 loops=1)
          Filter: (a = (list_part_fn(1) + a))
          Rows Removed by Filter: 1
-   ->  Seq Scan on list_part4 (actual rows=0 loops=1)
+   ->  Seq Scan on list_part4 list_part_3 (actual rows=0 loops=1)
          Filter: (a = (list_part_fn(1) + a))
          Rows Removed by Filter: 1
 (13 rows)
@@ -1921,8 +1942,8 @@ set parallel_tuple_cost = 0;
 set min_parallel_table_scan_size = 0;
 set max_parallel_workers_per_gather = 2;
 select explain_parallel_append('execute ab_q4 (2, 2)');
-                            explain_parallel_append                            
--------------------------------------------------------------------------------
+                              explain_parallel_append                               
+------------------------------------------------------------------------------------
  Finalize Aggregate (actual rows=N loops=N)
    ->  Gather (actual rows=N loops=N)
          Workers Planned: 2
@@ -1930,11 +1951,11 @@ select explain_parallel_append('execute ab_q4 (2, 2)');
          ->  Partial Aggregate (actual rows=N loops=N)
                ->  Parallel Append (actual rows=N loops=N)
                      Subplans Removed: 6
-                     ->  Parallel Seq Scan on ab_a2_b1 (actual rows=N loops=N)
+                     ->  Parallel Seq Scan on ab_a2_b1 ab (actual rows=N loops=N)
                            Filter: ((a >= $1) AND (a <= $2) AND (b < 4))
-                     ->  Parallel Seq Scan on ab_a2_b2 (actual rows=N loops=N)
+                     ->  Parallel Seq Scan on ab_a2_b2 ab_1 (actual rows=N loops=N)
                            Filter: ((a >= $1) AND (a <= $2) AND (b < 4))
-                     ->  Parallel Seq Scan on ab_a2_b3 (actual rows=N loops=N)
+                     ->  Parallel Seq Scan on ab_a2_b3 ab_2 (actual rows=N loops=N)
                            Filter: ((a >= $1) AND (a <= $2) AND (b < 4))
 (13 rows)
 
@@ -1942,8 +1963,8 @@ select explain_parallel_append('execute ab_q4 (2, 2)');
 prepare ab_q5 (int, int, int) as
 select avg(a) from ab where a in($1,$2,$3) and b < 4;
 select explain_parallel_append('execute ab_q5 (1, 1, 1)');
-                            explain_parallel_append                            
--------------------------------------------------------------------------------
+                              explain_parallel_append                               
+------------------------------------------------------------------------------------
  Finalize Aggregate (actual rows=N loops=N)
    ->  Gather (actual rows=N loops=N)
          Workers Planned: 2
@@ -1951,17 +1972,17 @@ select explain_parallel_append('execute ab_q5 (1, 1, 1)');
          ->  Partial Aggregate (actual rows=N loops=N)
                ->  Parallel Append (actual rows=N loops=N)
                      Subplans Removed: 6
-                     ->  Parallel Seq Scan on ab_a1_b1 (actual rows=N loops=N)
+                     ->  Parallel Seq Scan on ab_a1_b1 ab (actual rows=N loops=N)
                            Filter: ((b < 4) AND (a = ANY (ARRAY[$1, $2, $3])))
-                     ->  Parallel Seq Scan on ab_a1_b2 (actual rows=N loops=N)
+                     ->  Parallel Seq Scan on ab_a1_b2 ab_1 (actual rows=N loops=N)
                            Filter: ((b < 4) AND (a = ANY (ARRAY[$1, $2, $3])))
-                     ->  Parallel Seq Scan on ab_a1_b3 (actual rows=N loops=N)
+                     ->  Parallel Seq Scan on ab_a1_b3 ab_2 (actual rows=N loops=N)
                            Filter: ((b < 4) AND (a = ANY (ARRAY[$1, $2, $3])))
 (13 rows)
 
 select explain_parallel_append('execute ab_q5 (2, 3, 3)');
-                            explain_parallel_append                            
--------------------------------------------------------------------------------
+                              explain_parallel_append                               
+------------------------------------------------------------------------------------
  Finalize Aggregate (actual rows=N loops=N)
    ->  Gather (actual rows=N loops=N)
          Workers Planned: 2
@@ -1969,17 +1990,17 @@ select explain_parallel_append('execute ab_q5 (2, 3, 3)');
          ->  Partial Aggregate (actual rows=N loops=N)
                ->  Parallel Append (actual rows=N loops=N)
                      Subplans Removed: 3
-                     ->  Parallel Seq Scan on ab_a2_b1 (actual rows=N loops=N)
+                     ->  Parallel Seq Scan on ab_a2_b1 ab (actual rows=N loops=N)
                            Filter: ((b < 4) AND (a = ANY (ARRAY[$1, $2, $3])))
-                     ->  Parallel Seq Scan on ab_a2_b2 (actual rows=N loops=N)
+                     ->  Parallel Seq Scan on ab_a2_b2 ab_1 (actual rows=N loops=N)
                            Filter: ((b < 4) AND (a = ANY (ARRAY[$1, $2, $3])))
-                     ->  Parallel Seq Scan on ab_a2_b3 (actual rows=N loops=N)
+                     ->  Parallel Seq Scan on ab_a2_b3 ab_2 (actual rows=N loops=N)
                            Filter: ((b < 4) AND (a = ANY (ARRAY[$1, $2, $3])))
-                     ->  Parallel Seq Scan on ab_a3_b1 (actual rows=N loops=N)
+                     ->  Parallel Seq Scan on ab_a3_b1 ab_3 (actual rows=N loops=N)
                            Filter: ((b < 4) AND (a = ANY (ARRAY[$1, $2, $3])))
-                     ->  Parallel Seq Scan on ab_a3_b2 (actual rows=N loops=N)
+                     ->  Parallel Seq Scan on ab_a3_b2 ab_4 (actual rows=N loops=N)
                            Filter: ((b < 4) AND (a = ANY (ARRAY[$1, $2, $3])))
-                     ->  Parallel Seq Scan on ab_a3_b3 (actual rows=N loops=N)
+                     ->  Parallel Seq Scan on ab_a3_b3 ab_5 (actual rows=N loops=N)
                            Filter: ((b < 4) AND (a = ANY (ARRAY[$1, $2, $3])))
 (19 rows)
 
@@ -1995,14 +2016,14 @@ select explain_parallel_append('execute ab_q5 (33, 44, 55)');
          ->  Partial Aggregate (actual rows=N loops=N)
                ->  Parallel Append (actual rows=N loops=N)
                      Subplans Removed: 8
-                     ->  Parallel Seq Scan on ab_a1_b1 (never executed)
+                     ->  Parallel Seq Scan on ab_a1_b1 ab (never executed)
                            Filter: ((b < 4) AND (a = ANY (ARRAY[$1, $2, $3])))
 (9 rows)
 
 -- Test Parallel Append with PARAM_EXEC Params
 select explain_parallel_append('select count(*) from ab where (a = (select 1) or a = (select 3)) and b = 2');
-                         explain_parallel_append                         
--------------------------------------------------------------------------
+                           explain_parallel_append                            
+------------------------------------------------------------------------------
  Aggregate (actual rows=N loops=N)
    InitPlan 1 (returns $0)
      ->  Result (actual rows=N loops=N)
@@ -2013,11 +2034,11 @@ select explain_parallel_append('select count(*) from ab where (a = (select 1) or
          Params Evaluated: $0, $1
          Workers Launched: N
          ->  Parallel Append (actual rows=N loops=N)
-               ->  Parallel Seq Scan on ab_a1_b2 (actual rows=N loops=N)
+               ->  Parallel Seq Scan on ab_a1_b2 ab (actual rows=N loops=N)
                      Filter: ((b = 2) AND ((a = $0) OR (a = $1)))
-               ->  Parallel Seq Scan on ab_a2_b2 (never executed)
+               ->  Parallel Seq Scan on ab_a2_b2 ab_1 (never executed)
                      Filter: ((b = 2) AND ((a = $0) OR (a = $1)))
-               ->  Parallel Seq Scan on ab_a3_b2 (actual rows=N loops=N)
+               ->  Parallel Seq Scan on ab_a3_b2 ab_2 (actual rows=N loops=N)
                      Filter: ((b = 2) AND ((a = $0) OR (a = $1)))
 (16 rows)
 
@@ -2040,8 +2061,8 @@ create index ab_a3_b3_a_idx on ab_a3_b3 (a);
 set enable_hashjoin = 0;
 set enable_mergejoin = 0;
 select explain_parallel_append('select avg(ab.a) from ab inner join lprt_a a on ab.a = a.a where a.a in(0, 0, 1)');
-                                      explain_parallel_append                                      
----------------------------------------------------------------------------------------------------
+                                        explain_parallel_append                                         
+--------------------------------------------------------------------------------------------------------
  Finalize Aggregate (actual rows=N loops=N)
    ->  Gather (actual rows=N loops=N)
          Workers Planned: 1
@@ -2051,31 +2072,31 @@ select explain_parallel_append('select avg(ab.a) from ab inner join lprt_a a on
                      ->  Parallel Seq Scan on lprt_a a (actual rows=N loops=N)
                            Filter: (a = ANY ('{0,0,1}'::integer[]))
                      ->  Append (actual rows=N loops=N)
-                           ->  Index Scan using ab_a1_b1_a_idx on ab_a1_b1 (actual rows=N loops=N)
+                           ->  Index Scan using ab_a1_b1_a_idx on ab_a1_b1 ab (actual rows=N loops=N)
                                  Index Cond: (a = a.a)
-                           ->  Index Scan using ab_a1_b2_a_idx on ab_a1_b2 (actual rows=N loops=N)
+                           ->  Index Scan using ab_a1_b2_a_idx on ab_a1_b2 ab_1 (actual rows=N loops=N)
                                  Index Cond: (a = a.a)
-                           ->  Index Scan using ab_a1_b3_a_idx on ab_a1_b3 (actual rows=N loops=N)
+                           ->  Index Scan using ab_a1_b3_a_idx on ab_a1_b3 ab_2 (actual rows=N loops=N)
                                  Index Cond: (a = a.a)
-                           ->  Index Scan using ab_a2_b1_a_idx on ab_a2_b1 (never executed)
+                           ->  Index Scan using ab_a2_b1_a_idx on ab_a2_b1 ab_3 (never executed)
                                  Index Cond: (a = a.a)
-                           ->  Index Scan using ab_a2_b2_a_idx on ab_a2_b2 (never executed)
+                           ->  Index Scan using ab_a2_b2_a_idx on ab_a2_b2 ab_4 (never executed)
                                  Index Cond: (a = a.a)
-                           ->  Index Scan using ab_a2_b3_a_idx on ab_a2_b3 (never executed)
+                           ->  Index Scan using ab_a2_b3_a_idx on ab_a2_b3 ab_5 (never executed)
                                  Index Cond: (a = a.a)
-                           ->  Index Scan using ab_a3_b1_a_idx on ab_a3_b1 (never executed)
+                           ->  Index Scan using ab_a3_b1_a_idx on ab_a3_b1 ab_6 (never executed)
                                  Index Cond: (a = a.a)
-                           ->  Index Scan using ab_a3_b2_a_idx on ab_a3_b2 (never executed)
+                           ->  Index Scan using ab_a3_b2_a_idx on ab_a3_b2 ab_7 (never executed)
                                  Index Cond: (a = a.a)
-                           ->  Index Scan using ab_a3_b3_a_idx on ab_a3_b3 (never executed)
+                           ->  Index Scan using ab_a3_b3_a_idx on ab_a3_b3 ab_8 (never executed)
                                  Index Cond: (a = a.a)
 (27 rows)
 
 -- Ensure the same partitions are pruned when we make the nested loop
 -- parameter an Expr rather than a plain Param.
 select explain_parallel_append('select avg(ab.a) from ab inner join lprt_a a on ab.a = a.a + 0 where a.a in(0, 0, 1)');
-                                      explain_parallel_append                                      
----------------------------------------------------------------------------------------------------
+                                        explain_parallel_append                                         
+--------------------------------------------------------------------------------------------------------
  Finalize Aggregate (actual rows=N loops=N)
    ->  Gather (actual rows=N loops=N)
          Workers Planned: 1
@@ -2085,30 +2106,30 @@ select explain_parallel_append('select avg(ab.a) from ab inner join lprt_a a on
                      ->  Parallel Seq Scan on lprt_a a (actual rows=N loops=N)
                            Filter: (a = ANY ('{0,0,1}'::integer[]))
                      ->  Append (actual rows=N loops=N)
-                           ->  Index Scan using ab_a1_b1_a_idx on ab_a1_b1 (actual rows=N loops=N)
+                           ->  Index Scan using ab_a1_b1_a_idx on ab_a1_b1 ab (actual rows=N loops=N)
                                  Index Cond: (a = (a.a + 0))
-                           ->  Index Scan using ab_a1_b2_a_idx on ab_a1_b2 (actual rows=N loops=N)
+                           ->  Index Scan using ab_a1_b2_a_idx on ab_a1_b2 ab_1 (actual rows=N loops=N)
                                  Index Cond: (a = (a.a + 0))
-                           ->  Index Scan using ab_a1_b3_a_idx on ab_a1_b3 (actual rows=N loops=N)
+                           ->  Index Scan using ab_a1_b3_a_idx on ab_a1_b3 ab_2 (actual rows=N loops=N)
                                  Index Cond: (a = (a.a + 0))
-                           ->  Index Scan using ab_a2_b1_a_idx on ab_a2_b1 (never executed)
+                           ->  Index Scan using ab_a2_b1_a_idx on ab_a2_b1 ab_3 (never executed)
                                  Index Cond: (a = (a.a + 0))
-                           ->  Index Scan using ab_a2_b2_a_idx on ab_a2_b2 (never executed)
+                           ->  Index Scan using ab_a2_b2_a_idx on ab_a2_b2 ab_4 (never executed)
                                  Index Cond: (a = (a.a + 0))
-                           ->  Index Scan using ab_a2_b3_a_idx on ab_a2_b3 (never executed)
+                           ->  Index Scan using ab_a2_b3_a_idx on ab_a2_b3 ab_5 (never executed)
                                  Index Cond: (a = (a.a + 0))
-                           ->  Index Scan using ab_a3_b1_a_idx on ab_a3_b1 (never executed)
+                           ->  Index Scan using ab_a3_b1_a_idx on ab_a3_b1 ab_6 (never executed)
                                  Index Cond: (a = (a.a + 0))
-                           ->  Index Scan using ab_a3_b2_a_idx on ab_a3_b2 (never executed)
+                           ->  Index Scan using ab_a3_b2_a_idx on ab_a3_b2 ab_7 (never executed)
                                  Index Cond: (a = (a.a + 0))
-                           ->  Index Scan using ab_a3_b3_a_idx on ab_a3_b3 (never executed)
+                           ->  Index Scan using ab_a3_b3_a_idx on ab_a3_b3 ab_8 (never executed)
                                  Index Cond: (a = (a.a + 0))
 (27 rows)
 
 insert into lprt_a values(3),(3);
 select explain_parallel_append('select avg(ab.a) from ab inner join lprt_a a on ab.a = a.a where a.a in(1, 0, 3)');
-                                      explain_parallel_append                                      
----------------------------------------------------------------------------------------------------
+                                        explain_parallel_append                                         
+--------------------------------------------------------------------------------------------------------
  Finalize Aggregate (actual rows=N loops=N)
    ->  Gather (actual rows=N loops=N)
          Workers Planned: 1
@@ -2118,29 +2139,29 @@ select explain_parallel_append('select avg(ab.a) from ab inner join lprt_a a on
                      ->  Parallel Seq Scan on lprt_a a (actual rows=N loops=N)
                            Filter: (a = ANY ('{1,0,3}'::integer[]))
                      ->  Append (actual rows=N loops=N)
-                           ->  Index Scan using ab_a1_b1_a_idx on ab_a1_b1 (actual rows=N loops=N)
+                           ->  Index Scan using ab_a1_b1_a_idx on ab_a1_b1 ab (actual rows=N loops=N)
                                  Index Cond: (a = a.a)
-                           ->  Index Scan using ab_a1_b2_a_idx on ab_a1_b2 (actual rows=N loops=N)
+                           ->  Index Scan using ab_a1_b2_a_idx on ab_a1_b2 ab_1 (actual rows=N loops=N)
                                  Index Cond: (a = a.a)
-                           ->  Index Scan using ab_a1_b3_a_idx on ab_a1_b3 (actual rows=N loops=N)
+                           ->  Index Scan using ab_a1_b3_a_idx on ab_a1_b3 ab_2 (actual rows=N loops=N)
                                  Index Cond: (a = a.a)
-                           ->  Index Scan using ab_a2_b1_a_idx on ab_a2_b1 (never executed)
+                           ->  Index Scan using ab_a2_b1_a_idx on ab_a2_b1 ab_3 (never executed)
                                  Index Cond: (a = a.a)
-                           ->  Index Scan using ab_a2_b2_a_idx on ab_a2_b2 (never executed)
+                           ->  Index Scan using ab_a2_b2_a_idx on ab_a2_b2 ab_4 (never executed)
                                  Index Cond: (a = a.a)
-                           ->  Index Scan using ab_a2_b3_a_idx on ab_a2_b3 (never executed)
+                           ->  Index Scan using ab_a2_b3_a_idx on ab_a2_b3 ab_5 (never executed)
                                  Index Cond: (a = a.a)
-                           ->  Index Scan using ab_a3_b1_a_idx on ab_a3_b1 (actual rows=N loops=N)
+                           ->  Index Scan using ab_a3_b1_a_idx on ab_a3_b1 ab_6 (actual rows=N loops=N)
                                  Index Cond: (a = a.a)
-                           ->  Index Scan using ab_a3_b2_a_idx on ab_a3_b2 (actual rows=N loops=N)
+                           ->  Index Scan using ab_a3_b2_a_idx on ab_a3_b2 ab_7 (actual rows=N loops=N)
                                  Index Cond: (a = a.a)
-                           ->  Index Scan using ab_a3_b3_a_idx on ab_a3_b3 (actual rows=N loops=N)
+                           ->  Index Scan using ab_a3_b3_a_idx on ab_a3_b3 ab_8 (actual rows=N loops=N)
                                  Index Cond: (a = a.a)
 (27 rows)
 
 select explain_parallel_append('select avg(ab.a) from ab inner join lprt_a a on ab.a = a.a where a.a in(1, 0, 0)');
-                                      explain_parallel_append                                      
----------------------------------------------------------------------------------------------------
+                                        explain_parallel_append                                         
+--------------------------------------------------------------------------------------------------------
  Finalize Aggregate (actual rows=N loops=N)
    ->  Gather (actual rows=N loops=N)
          Workers Planned: 1
@@ -2151,30 +2172,30 @@ select explain_parallel_append('select avg(ab.a) from ab inner join lprt_a a on
                            Filter: (a = ANY ('{1,0,0}'::integer[]))
                            Rows Removed by Filter: N
                      ->  Append (actual rows=N loops=N)
-                           ->  Index Scan using ab_a1_b1_a_idx on ab_a1_b1 (actual rows=N loops=N)
+                           ->  Index Scan using ab_a1_b1_a_idx on ab_a1_b1 ab (actual rows=N loops=N)
                                  Index Cond: (a = a.a)
-                           ->  Index Scan using ab_a1_b2_a_idx on ab_a1_b2 (actual rows=N loops=N)
+                           ->  Index Scan using ab_a1_b2_a_idx on ab_a1_b2 ab_1 (actual rows=N loops=N)
                                  Index Cond: (a = a.a)
-                           ->  Index Scan using ab_a1_b3_a_idx on ab_a1_b3 (actual rows=N loops=N)
+                           ->  Index Scan using ab_a1_b3_a_idx on ab_a1_b3 ab_2 (actual rows=N loops=N)
                                  Index Cond: (a = a.a)
-                           ->  Index Scan using ab_a2_b1_a_idx on ab_a2_b1 (never executed)
+                           ->  Index Scan using ab_a2_b1_a_idx on ab_a2_b1 ab_3 (never executed)
                                  Index Cond: (a = a.a)
-                           ->  Index Scan using ab_a2_b2_a_idx on ab_a2_b2 (never executed)
+                           ->  Index Scan using ab_a2_b2_a_idx on ab_a2_b2 ab_4 (never executed)
                                  Index Cond: (a = a.a)
-                           ->  Index Scan using ab_a2_b3_a_idx on ab_a2_b3 (never executed)
+                           ->  Index Scan using ab_a2_b3_a_idx on ab_a2_b3 ab_5 (never executed)
                                  Index Cond: (a = a.a)
-                           ->  Index Scan using ab_a3_b1_a_idx on ab_a3_b1 (never executed)
+                           ->  Index Scan using ab_a3_b1_a_idx on ab_a3_b1 ab_6 (never executed)
                                  Index Cond: (a = a.a)
-                           ->  Index Scan using ab_a3_b2_a_idx on ab_a3_b2 (never executed)
+                           ->  Index Scan using ab_a3_b2_a_idx on ab_a3_b2 ab_7 (never executed)
                                  Index Cond: (a = a.a)
-                           ->  Index Scan using ab_a3_b3_a_idx on ab_a3_b3 (never executed)
+                           ->  Index Scan using ab_a3_b3_a_idx on ab_a3_b3 ab_8 (never executed)
                                  Index Cond: (a = a.a)
 (28 rows)
 
 delete from lprt_a where a = 1;
 select explain_parallel_append('select avg(ab.a) from ab inner join lprt_a a on ab.a = a.a where a.a in(1, 0, 0)');
-                                  explain_parallel_append                                   
---------------------------------------------------------------------------------------------
+                                     explain_parallel_append                                     
+-------------------------------------------------------------------------------------------------
  Finalize Aggregate (actual rows=N loops=N)
    ->  Gather (actual rows=N loops=N)
          Workers Planned: 1
@@ -2185,23 +2206,23 @@ select explain_parallel_append('select avg(ab.a) from ab inner join lprt_a a on
                            Filter: (a = ANY ('{1,0,0}'::integer[]))
                            Rows Removed by Filter: N
                      ->  Append (actual rows=N loops=N)
-                           ->  Index Scan using ab_a1_b1_a_idx on ab_a1_b1 (never executed)
+                           ->  Index Scan using ab_a1_b1_a_idx on ab_a1_b1 ab (never executed)
                                  Index Cond: (a = a.a)
-                           ->  Index Scan using ab_a1_b2_a_idx on ab_a1_b2 (never executed)
+                           ->  Index Scan using ab_a1_b2_a_idx on ab_a1_b2 ab_1 (never executed)
                                  Index Cond: (a = a.a)
-                           ->  Index Scan using ab_a1_b3_a_idx on ab_a1_b3 (never executed)
+                           ->  Index Scan using ab_a1_b3_a_idx on ab_a1_b3 ab_2 (never executed)
                                  Index Cond: (a = a.a)
-                           ->  Index Scan using ab_a2_b1_a_idx on ab_a2_b1 (never executed)
+                           ->  Index Scan using ab_a2_b1_a_idx on ab_a2_b1 ab_3 (never executed)
                                  Index Cond: (a = a.a)
-                           ->  Index Scan using ab_a2_b2_a_idx on ab_a2_b2 (never executed)
+                           ->  Index Scan using ab_a2_b2_a_idx on ab_a2_b2 ab_4 (never executed)
                                  Index Cond: (a = a.a)
-                           ->  Index Scan using ab_a2_b3_a_idx on ab_a2_b3 (never executed)
+                           ->  Index Scan using ab_a2_b3_a_idx on ab_a2_b3 ab_5 (never executed)
                                  Index Cond: (a = a.a)
-                           ->  Index Scan using ab_a3_b1_a_idx on ab_a3_b1 (never executed)
+                           ->  Index Scan using ab_a3_b1_a_idx on ab_a3_b1 ab_6 (never executed)
                                  Index Cond: (a = a.a)
-                           ->  Index Scan using ab_a3_b2_a_idx on ab_a3_b2 (never executed)
+                           ->  Index Scan using ab_a3_b2_a_idx on ab_a3_b2 ab_7 (never executed)
                                  Index Cond: (a = a.a)
-                           ->  Index Scan using ab_a3_b3_a_idx on ab_a3_b3 (never executed)
+                           ->  Index Scan using ab_a3_b3_a_idx on ab_a3_b3 ab_8 (never executed)
                                  Index Cond: (a = a.a)
 (28 rows)
 
@@ -2223,47 +2244,47 @@ select * from ab where a = (select max(a) from lprt_a) and b = (select max(a)-1
    InitPlan 2 (returns $1)
      ->  Aggregate (actual rows=1 loops=1)
            ->  Seq Scan on lprt_a lprt_a_1 (actual rows=102 loops=1)
-   ->  Bitmap Heap Scan on ab_a1_b1 (never executed)
+   ->  Bitmap Heap Scan on ab_a1_b1 ab (never executed)
          Recheck Cond: (a = $0)
          Filter: (b = $1)
          ->  Bitmap Index Scan on ab_a1_b1_a_idx (never executed)
                Index Cond: (a = $0)
-   ->  Bitmap Heap Scan on ab_a1_b2 (never executed)
+   ->  Bitmap Heap Scan on ab_a1_b2 ab_1 (never executed)
          Recheck Cond: (a = $0)
          Filter: (b = $1)
          ->  Bitmap Index Scan on ab_a1_b2_a_idx (never executed)
                Index Cond: (a = $0)
-   ->  Bitmap Heap Scan on ab_a1_b3 (never executed)
+   ->  Bitmap Heap Scan on ab_a1_b3 ab_2 (never executed)
          Recheck Cond: (a = $0)
          Filter: (b = $1)
          ->  Bitmap Index Scan on ab_a1_b3_a_idx (never executed)
                Index Cond: (a = $0)
-   ->  Bitmap Heap Scan on ab_a2_b1 (never executed)
+   ->  Bitmap Heap Scan on ab_a2_b1 ab_3 (never executed)
          Recheck Cond: (a = $0)
          Filter: (b = $1)
          ->  Bitmap Index Scan on ab_a2_b1_a_idx (never executed)
                Index Cond: (a = $0)
-   ->  Bitmap Heap Scan on ab_a2_b2 (never executed)
+   ->  Bitmap Heap Scan on ab_a2_b2 ab_4 (never executed)
          Recheck Cond: (a = $0)
          Filter: (b = $1)
          ->  Bitmap Index Scan on ab_a2_b2_a_idx (never executed)
                Index Cond: (a = $0)
-   ->  Bitmap Heap Scan on ab_a2_b3 (never executed)
+   ->  Bitmap Heap Scan on ab_a2_b3 ab_5 (never executed)
          Recheck Cond: (a = $0)
          Filter: (b = $1)
          ->  Bitmap Index Scan on ab_a2_b3_a_idx (never executed)
                Index Cond: (a = $0)
-   ->  Bitmap Heap Scan on ab_a3_b1 (never executed)
+   ->  Bitmap Heap Scan on ab_a3_b1 ab_6 (never executed)
          Recheck Cond: (a = $0)
          Filter: (b = $1)
          ->  Bitmap Index Scan on ab_a3_b1_a_idx (never executed)
                Index Cond: (a = $0)
-   ->  Bitmap Heap Scan on ab_a3_b2 (actual rows=0 loops=1)
+   ->  Bitmap Heap Scan on ab_a3_b2 ab_7 (actual rows=0 loops=1)
          Recheck Cond: (a = $0)
          Filter: (b = $1)
          ->  Bitmap Index Scan on ab_a3_b2_a_idx (actual rows=0 loops=1)
                Index Cond: (a = $0)
-   ->  Bitmap Heap Scan on ab_a3_b3 (never executed)
+   ->  Bitmap Heap Scan on ab_a3_b3 ab_8 (never executed)
          Recheck Cond: (a = $0)
          Filter: (b = $1)
          ->  Bitmap Index Scan on ab_a3_b3_a_idx (never executed)
@@ -2279,38 +2300,38 @@ select * from (select * from ab where a = 1 union all select * from ab) ab where
    InitPlan 1 (returns $0)
      ->  Result (actual rows=1 loops=1)
    ->  Append (actual rows=0 loops=1)
-         ->  Bitmap Heap Scan on ab_a1_b1 ab_a1_b1_1 (actual rows=0 loops=1)
+         ->  Bitmap Heap Scan on ab_a1_b1 ab_9 (actual rows=0 loops=1)
                Recheck Cond: (a = 1)
                Filter: (b = $0)
                ->  Bitmap Index Scan on ab_a1_b1_a_idx (actual rows=0 loops=1)
                      Index Cond: (a = 1)
-         ->  Bitmap Heap Scan on ab_a1_b2 ab_a1_b2_1 (never executed)
+         ->  Bitmap Heap Scan on ab_a1_b2 ab_10 (never executed)
                Recheck Cond: (a = 1)
                Filter: (b = $0)
                ->  Bitmap Index Scan on ab_a1_b2_a_idx (never executed)
                      Index Cond: (a = 1)
-         ->  Bitmap Heap Scan on ab_a1_b3 ab_a1_b3_1 (never executed)
+         ->  Bitmap Heap Scan on ab_a1_b3 ab_11 (never executed)
                Recheck Cond: (a = 1)
                Filter: (b = $0)
                ->  Bitmap Index Scan on ab_a1_b3_a_idx (never executed)
                      Index Cond: (a = 1)
-   ->  Seq Scan on ab_a1_b1 (actual rows=0 loops=1)
+   ->  Seq Scan on ab_a1_b1 ab (actual rows=0 loops=1)
          Filter: (b = $0)
-   ->  Seq Scan on ab_a1_b2 (never executed)
+   ->  Seq Scan on ab_a1_b2 ab_1 (never executed)
          Filter: (b = $0)
-   ->  Seq Scan on ab_a1_b3 (never executed)
+   ->  Seq Scan on ab_a1_b3 ab_2 (never executed)
          Filter: (b = $0)
-   ->  Seq Scan on ab_a2_b1 (actual rows=0 loops=1)
+   ->  Seq Scan on ab_a2_b1 ab_3 (actual rows=0 loops=1)
          Filter: (b = $0)
-   ->  Seq Scan on ab_a2_b2 (never executed)
+   ->  Seq Scan on ab_a2_b2 ab_4 (never executed)
          Filter: (b = $0)
-   ->  Seq Scan on ab_a2_b3 (never executed)
+   ->  Seq Scan on ab_a2_b3 ab_5 (never executed)
          Filter: (b = $0)
-   ->  Seq Scan on ab_a3_b1 (actual rows=0 loops=1)
+   ->  Seq Scan on ab_a3_b1 ab_6 (actual rows=0 loops=1)
          Filter: (b = $0)
-   ->  Seq Scan on ab_a3_b2 (never executed)
+   ->  Seq Scan on ab_a3_b2 ab_7 (never executed)
          Filter: (b = $0)
-   ->  Seq Scan on ab_a3_b3 (never executed)
+   ->  Seq Scan on ab_a3_b3 ab_8 (never executed)
          Filter: (b = $0)
 (37 rows)
 
@@ -2323,40 +2344,40 @@ select * from (select * from ab where a = 1 union all (values(10,5)) union all s
    InitPlan 1 (returns $0)
      ->  Result (actual rows=1 loops=1)
    ->  Append (actual rows=0 loops=1)
-         ->  Bitmap Heap Scan on ab_a1_b1 ab_a1_b1_1 (actual rows=0 loops=1)
+         ->  Bitmap Heap Scan on ab_a1_b1 ab_9 (actual rows=0 loops=1)
                Recheck Cond: (a = 1)
                Filter: (b = $0)
                ->  Bitmap Index Scan on ab_a1_b1_a_idx (actual rows=0 loops=1)
                      Index Cond: (a = 1)
-         ->  Bitmap Heap Scan on ab_a1_b2 ab_a1_b2_1 (never executed)
+         ->  Bitmap Heap Scan on ab_a1_b2 ab_10 (never executed)
                Recheck Cond: (a = 1)
                Filter: (b = $0)
                ->  Bitmap Index Scan on ab_a1_b2_a_idx (never executed)
                      Index Cond: (a = 1)
-         ->  Bitmap Heap Scan on ab_a1_b3 ab_a1_b3_1 (never executed)
+         ->  Bitmap Heap Scan on ab_a1_b3 ab_11 (never executed)
                Recheck Cond: (a = 1)
                Filter: (b = $0)
                ->  Bitmap Index Scan on ab_a1_b3_a_idx (never executed)
                      Index Cond: (a = 1)
    ->  Result (actual rows=0 loops=1)
          One-Time Filter: (5 = $0)
-   ->  Seq Scan on ab_a1_b1 (actual rows=0 loops=1)
+   ->  Seq Scan on ab_a1_b1 ab (actual rows=0 loops=1)
          Filter: (b = $0)
-   ->  Seq Scan on ab_a1_b2 (never executed)
+   ->  Seq Scan on ab_a1_b2 ab_1 (never executed)
          Filter: (b = $0)
-   ->  Seq Scan on ab_a1_b3 (never executed)
+   ->  Seq Scan on ab_a1_b3 ab_2 (never executed)
          Filter: (b = $0)
-   ->  Seq Scan on ab_a2_b1 (actual rows=0 loops=1)
+   ->  Seq Scan on ab_a2_b1 ab_3 (actual rows=0 loops=1)
          Filter: (b = $0)
-   ->  Seq Scan on ab_a2_b2 (never executed)
+   ->  Seq Scan on ab_a2_b2 ab_4 (never executed)
          Filter: (b = $0)
-   ->  Seq Scan on ab_a2_b3 (never executed)
+   ->  Seq Scan on ab_a2_b3 ab_5 (never executed)
          Filter: (b = $0)
-   ->  Seq Scan on ab_a3_b1 (actual rows=0 loops=1)
+   ->  Seq Scan on ab_a3_b1 ab_6 (actual rows=0 loops=1)
          Filter: (b = $0)
-   ->  Seq Scan on ab_a3_b2 (never executed)
+   ->  Seq Scan on ab_a3_b2 ab_7 (never executed)
          Filter: (b = $0)
-   ->  Seq Scan on ab_a3_b3 (never executed)
+   ->  Seq Scan on ab_a3_b3 ab_8 (never executed)
          Filter: (b = $0)
 (39 rows)
 
@@ -2375,26 +2396,26 @@ union all
 ) ab where a = $1 and b = (select -10);
 -- Ensure the xy_1 subplan is not pruned.
 explain (analyze, costs off, summary off, timing off) execute ab_q6(1);
-                       QUERY PLAN                       
---------------------------------------------------------
+                    QUERY PLAN                    
+--------------------------------------------------
  Append (actual rows=0 loops=1)
    InitPlan 1 (returns $0)
      ->  Result (actual rows=1 loops=1)
    Subplans Removed: 12
-   ->  Seq Scan on ab_a1_b1 (never executed)
+   ->  Seq Scan on ab_a1_b1 ab (never executed)
          Filter: ((a = $1) AND (b = $0))
-   ->  Seq Scan on ab_a1_b2 (never executed)
+   ->  Seq Scan on ab_a1_b2 ab_1 (never executed)
          Filter: ((a = $1) AND (b = $0))
-   ->  Seq Scan on ab_a1_b3 (never executed)
+   ->  Seq Scan on ab_a1_b3 ab_2 (never executed)
          Filter: ((a = $1) AND (b = $0))
    ->  Seq Scan on xy_1 (actual rows=0 loops=1)
          Filter: ((x = $1) AND (y = $0))
          Rows Removed by Filter: 1
-   ->  Seq Scan on ab_a1_b1 ab_a1_b1_1 (never executed)
+   ->  Seq Scan on ab_a1_b1 ab_3 (never executed)
          Filter: ((a = $1) AND (b = $0))
-   ->  Seq Scan on ab_a1_b2 ab_a1_b2_1 (never executed)
+   ->  Seq Scan on ab_a1_b2 ab_4 (never executed)
          Filter: ((a = $1) AND (b = $0))
-   ->  Seq Scan on ab_a1_b3 ab_a1_b3_1 (never executed)
+   ->  Seq Scan on ab_a1_b3 ab_5 (never executed)
          Filter: ((a = $1) AND (b = $0))
 (19 rows)
 
@@ -2420,67 +2441,67 @@ update ab_a1 set b = 3 from ab where ab.a = 1 and ab.a = ab_a1.a;
                                      QUERY PLAN                                      
 -------------------------------------------------------------------------------------
  Update on ab_a1 (actual rows=0 loops=1)
-   Update on ab_a1_b1
-   Update on ab_a1_b2
-   Update on ab_a1_b3
+   Update on ab_a1_b1 ab_a1_1
+   Update on ab_a1_b2 ab_a1_2
+   Update on ab_a1_b3 ab_a1_3
    ->  Nested Loop (actual rows=0 loops=1)
          ->  Append (actual rows=1 loops=1)
-               ->  Bitmap Heap Scan on ab_a1_b1 ab_a1_b1_1 (actual rows=0 loops=1)
+               ->  Bitmap Heap Scan on ab_a1_b1 ab (actual rows=0 loops=1)
                      Recheck Cond: (a = 1)
                      ->  Bitmap Index Scan on ab_a1_b1_a_idx (actual rows=0 loops=1)
                            Index Cond: (a = 1)
-               ->  Bitmap Heap Scan on ab_a1_b2 ab_a1_b2_1 (actual rows=1 loops=1)
+               ->  Bitmap Heap Scan on ab_a1_b2 ab_1 (actual rows=1 loops=1)
                      Recheck Cond: (a = 1)
                      Heap Blocks: exact=1
                      ->  Bitmap Index Scan on ab_a1_b2_a_idx (actual rows=1 loops=1)
                            Index Cond: (a = 1)
-               ->  Bitmap Heap Scan on ab_a1_b3 ab_a1_b3_1 (actual rows=0 loops=1)
+               ->  Bitmap Heap Scan on ab_a1_b3 ab_2 (actual rows=0 loops=1)
                      Recheck Cond: (a = 1)
                      ->  Bitmap Index Scan on ab_a1_b3_a_idx (actual rows=0 loops=1)
                            Index Cond: (a = 1)
          ->  Materialize (actual rows=0 loops=1)
-               ->  Bitmap Heap Scan on ab_a1_b1 (actual rows=0 loops=1)
+               ->  Bitmap Heap Scan on ab_a1_b1 ab_a1_1 (actual rows=0 loops=1)
                      Recheck Cond: (a = 1)
                      ->  Bitmap Index Scan on ab_a1_b1_a_idx (actual rows=0 loops=1)
                            Index Cond: (a = 1)
    ->  Nested Loop (actual rows=1 loops=1)
          ->  Append (actual rows=1 loops=1)
-               ->  Bitmap Heap Scan on ab_a1_b1 ab_a1_b1_1 (actual rows=0 loops=1)
+               ->  Bitmap Heap Scan on ab_a1_b1 ab (actual rows=0 loops=1)
                      Recheck Cond: (a = 1)
                      ->  Bitmap Index Scan on ab_a1_b1_a_idx (actual rows=0 loops=1)
                            Index Cond: (a = 1)
-               ->  Bitmap Heap Scan on ab_a1_b2 ab_a1_b2_1 (actual rows=1 loops=1)
+               ->  Bitmap Heap Scan on ab_a1_b2 ab_1 (actual rows=1 loops=1)
                      Recheck Cond: (a = 1)
                      Heap Blocks: exact=1
                      ->  Bitmap Index Scan on ab_a1_b2_a_idx (actual rows=1 loops=1)
                            Index Cond: (a = 1)
-               ->  Bitmap Heap Scan on ab_a1_b3 ab_a1_b3_1 (actual rows=0 loops=1)
+               ->  Bitmap Heap Scan on ab_a1_b3 ab_2 (actual rows=0 loops=1)
                      Recheck Cond: (a = 1)
                      ->  Bitmap Index Scan on ab_a1_b3_a_idx (actual rows=1 loops=1)
                            Index Cond: (a = 1)
          ->  Materialize (actual rows=1 loops=1)
-               ->  Bitmap Heap Scan on ab_a1_b2 (actual rows=1 loops=1)
+               ->  Bitmap Heap Scan on ab_a1_b2 ab_a1_2 (actual rows=1 loops=1)
                      Recheck Cond: (a = 1)
                      Heap Blocks: exact=1
                      ->  Bitmap Index Scan on ab_a1_b2_a_idx (actual rows=1 loops=1)
                            Index Cond: (a = 1)
    ->  Nested Loop (actual rows=0 loops=1)
          ->  Append (actual rows=1 loops=1)
-               ->  Bitmap Heap Scan on ab_a1_b1 ab_a1_b1_1 (actual rows=0 loops=1)
+               ->  Bitmap Heap Scan on ab_a1_b1 ab (actual rows=0 loops=1)
                      Recheck Cond: (a = 1)
                      ->  Bitmap Index Scan on ab_a1_b1_a_idx (actual rows=0 loops=1)
                            Index Cond: (a = 1)
-               ->  Bitmap Heap Scan on ab_a1_b2 ab_a1_b2_1 (actual rows=1 loops=1)
+               ->  Bitmap Heap Scan on ab_a1_b2 ab_1 (actual rows=1 loops=1)
                      Recheck Cond: (a = 1)
                      Heap Blocks: exact=1
                      ->  Bitmap Index Scan on ab_a1_b2_a_idx (actual rows=1 loops=1)
                            Index Cond: (a = 1)
-               ->  Bitmap Heap Scan on ab_a1_b3 ab_a1_b3_1 (actual rows=0 loops=1)
+               ->  Bitmap Heap Scan on ab_a1_b3 ab_2 (actual rows=0 loops=1)
                      Recheck Cond: (a = 1)
                      ->  Bitmap Index Scan on ab_a1_b3_a_idx (actual rows=1 loops=1)
                            Index Cond: (a = 1)
          ->  Materialize (actual rows=0 loops=1)
-               ->  Bitmap Heap Scan on ab_a1_b3 (actual rows=0 loops=1)
+               ->  Bitmap Heap Scan on ab_a1_b3 ab_a1_3 (actual rows=0 loops=1)
                      Recheck Cond: (a = 1)
                      ->  Bitmap Index Scan on ab_a1_b3_a_idx (actual rows=1 loops=1)
                            Index Cond: (a = 1)
@@ -2497,43 +2518,43 @@ truncate ab;
 insert into ab values (1, 1), (1, 2), (1, 3), (2, 1);
 explain (analyze, costs off, summary off, timing off)
 update ab_a1 set b = 3 from ab_a2 where ab_a2.b = (select 1);
-                              QUERY PLAN                              
-----------------------------------------------------------------------
+                                 QUERY PLAN                                 
+----------------------------------------------------------------------------
  Update on ab_a1 (actual rows=0 loops=1)
-   Update on ab_a1_b1
-   Update on ab_a1_b2
-   Update on ab_a1_b3
+   Update on ab_a1_b1 ab_a1_1
+   Update on ab_a1_b2 ab_a1_2
+   Update on ab_a1_b3 ab_a1_3
    InitPlan 1 (returns $0)
      ->  Result (actual rows=1 loops=1)
    ->  Nested Loop (actual rows=1 loops=1)
-         ->  Seq Scan on ab_a1_b1 (actual rows=1 loops=1)
+         ->  Seq Scan on ab_a1_b1 ab_a1_1 (actual rows=1 loops=1)
          ->  Materialize (actual rows=1 loops=1)
                ->  Append (actual rows=1 loops=1)
-                     ->  Seq Scan on ab_a2_b1 (actual rows=1 loops=1)
+                     ->  Seq Scan on ab_a2_b1 ab_a2 (actual rows=1 loops=1)
                            Filter: (b = $0)
-                     ->  Seq Scan on ab_a2_b2 (never executed)
+                     ->  Seq Scan on ab_a2_b2 ab_a2_1 (never executed)
                            Filter: (b = $0)
-                     ->  Seq Scan on ab_a2_b3 (never executed)
+                     ->  Seq Scan on ab_a2_b3 ab_a2_2 (never executed)
                            Filter: (b = $0)
    ->  Nested Loop (actual rows=1 loops=1)
-         ->  Seq Scan on ab_a1_b2 (actual rows=1 loops=1)
+         ->  Seq Scan on ab_a1_b2 ab_a1_2 (actual rows=1 loops=1)
          ->  Materialize (actual rows=1 loops=1)
                ->  Append (actual rows=1 loops=1)
-                     ->  Seq Scan on ab_a2_b1 (actual rows=1 loops=1)
+                     ->  Seq Scan on ab_a2_b1 ab_a2 (actual rows=1 loops=1)
                            Filter: (b = $0)
-                     ->  Seq Scan on ab_a2_b2 (never executed)
+                     ->  Seq Scan on ab_a2_b2 ab_a2_1 (never executed)
                            Filter: (b = $0)
-                     ->  Seq Scan on ab_a2_b3 (never executed)
+                     ->  Seq Scan on ab_a2_b3 ab_a2_2 (never executed)
                            Filter: (b = $0)
    ->  Nested Loop (actual rows=1 loops=1)
-         ->  Seq Scan on ab_a1_b3 (actual rows=1 loops=1)
+         ->  Seq Scan on ab_a1_b3 ab_a1_3 (actual rows=1 loops=1)
          ->  Materialize (actual rows=1 loops=1)
                ->  Append (actual rows=1 loops=1)
-                     ->  Seq Scan on ab_a2_b1 (actual rows=1 loops=1)
+                     ->  Seq Scan on ab_a2_b1 ab_a2 (actual rows=1 loops=1)
                            Filter: (b = $0)
-                     ->  Seq Scan on ab_a2_b2 (never executed)
+                     ->  Seq Scan on ab_a2_b2 ab_a2_1 (never executed)
                            Filter: (b = $0)
-                     ->  Seq Scan on ab_a2_b3 (never executed)
+                     ->  Seq Scan on ab_a2_b3 ab_a2_2 (never executed)
                            Filter: (b = $0)
 (36 rows)
 
@@ -2569,43 +2590,43 @@ set enable_hashjoin = off;
 set enable_mergejoin = off;
 explain (analyze, costs off, summary off, timing off)
 select * from tbl1 join tprt on tbl1.col1 > tprt.col1;
-                                QUERY PLAN                                
---------------------------------------------------------------------------
+                                   QUERY PLAN                                    
+---------------------------------------------------------------------------------
  Nested Loop (actual rows=6 loops=1)
    ->  Seq Scan on tbl1 (actual rows=2 loops=1)
    ->  Append (actual rows=3 loops=2)
-         ->  Index Scan using tprt1_idx on tprt_1 (actual rows=2 loops=2)
+         ->  Index Scan using tprt1_idx on tprt_1 tprt (actual rows=2 loops=2)
                Index Cond: (col1 < tbl1.col1)
-         ->  Index Scan using tprt2_idx on tprt_2 (actual rows=2 loops=1)
+         ->  Index Scan using tprt2_idx on tprt_2 tprt_1 (actual rows=2 loops=1)
                Index Cond: (col1 < tbl1.col1)
-         ->  Index Scan using tprt3_idx on tprt_3 (never executed)
+         ->  Index Scan using tprt3_idx on tprt_3 tprt_2 (never executed)
                Index Cond: (col1 < tbl1.col1)
-         ->  Index Scan using tprt4_idx on tprt_4 (never executed)
+         ->  Index Scan using tprt4_idx on tprt_4 tprt_3 (never executed)
                Index Cond: (col1 < tbl1.col1)
-         ->  Index Scan using tprt5_idx on tprt_5 (never executed)
+         ->  Index Scan using tprt5_idx on tprt_5 tprt_4 (never executed)
                Index Cond: (col1 < tbl1.col1)
-         ->  Index Scan using tprt6_idx on tprt_6 (never executed)
+         ->  Index Scan using tprt6_idx on tprt_6 tprt_5 (never executed)
                Index Cond: (col1 < tbl1.col1)
 (15 rows)
 
 explain (analyze, costs off, summary off, timing off)
 select * from tbl1 join tprt on tbl1.col1 = tprt.col1;
-                                QUERY PLAN                                
---------------------------------------------------------------------------
+                                   QUERY PLAN                                    
+---------------------------------------------------------------------------------
  Nested Loop (actual rows=2 loops=1)
    ->  Seq Scan on tbl1 (actual rows=2 loops=1)
    ->  Append (actual rows=1 loops=2)
-         ->  Index Scan using tprt1_idx on tprt_1 (never executed)
+         ->  Index Scan using tprt1_idx on tprt_1 tprt (never executed)
                Index Cond: (col1 = tbl1.col1)
-         ->  Index Scan using tprt2_idx on tprt_2 (actual rows=1 loops=2)
+         ->  Index Scan using tprt2_idx on tprt_2 tprt_1 (actual rows=1 loops=2)
                Index Cond: (col1 = tbl1.col1)
-         ->  Index Scan using tprt3_idx on tprt_3 (never executed)
+         ->  Index Scan using tprt3_idx on tprt_3 tprt_2 (never executed)
                Index Cond: (col1 = tbl1.col1)
-         ->  Index Scan using tprt4_idx on tprt_4 (never executed)
+         ->  Index Scan using tprt4_idx on tprt_4 tprt_3 (never executed)
                Index Cond: (col1 = tbl1.col1)
-         ->  Index Scan using tprt5_idx on tprt_5 (never executed)
+         ->  Index Scan using tprt5_idx on tprt_5 tprt_4 (never executed)
                Index Cond: (col1 = tbl1.col1)
-         ->  Index Scan using tprt6_idx on tprt_6 (never executed)
+         ->  Index Scan using tprt6_idx on tprt_6 tprt_5 (never executed)
                Index Cond: (col1 = tbl1.col1)
 (15 rows)
 
@@ -2635,43 +2656,43 @@ order by tbl1.col1, tprt.col1;
 insert into tbl1 values (1001), (1010), (1011);
 explain (analyze, costs off, summary off, timing off)
 select * from tbl1 inner join tprt on tbl1.col1 > tprt.col1;
-                                QUERY PLAN                                
---------------------------------------------------------------------------
+                                   QUERY PLAN                                    
+---------------------------------------------------------------------------------
  Nested Loop (actual rows=23 loops=1)
    ->  Seq Scan on tbl1 (actual rows=5 loops=1)
    ->  Append (actual rows=5 loops=5)
-         ->  Index Scan using tprt1_idx on tprt_1 (actual rows=2 loops=5)
+         ->  Index Scan using tprt1_idx on tprt_1 tprt (actual rows=2 loops=5)
                Index Cond: (col1 < tbl1.col1)
-         ->  Index Scan using tprt2_idx on tprt_2 (actual rows=3 loops=4)
+         ->  Index Scan using tprt2_idx on tprt_2 tprt_1 (actual rows=3 loops=4)
                Index Cond: (col1 < tbl1.col1)
-         ->  Index Scan using tprt3_idx on tprt_3 (actual rows=1 loops=2)
+         ->  Index Scan using tprt3_idx on tprt_3 tprt_2 (actual rows=1 loops=2)
                Index Cond: (col1 < tbl1.col1)
-         ->  Index Scan using tprt4_idx on tprt_4 (never executed)
+         ->  Index Scan using tprt4_idx on tprt_4 tprt_3 (never executed)
                Index Cond: (col1 < tbl1.col1)
-         ->  Index Scan using tprt5_idx on tprt_5 (never executed)
+         ->  Index Scan using tprt5_idx on tprt_5 tprt_4 (never executed)
                Index Cond: (col1 < tbl1.col1)
-         ->  Index Scan using tprt6_idx on tprt_6 (never executed)
+         ->  Index Scan using tprt6_idx on tprt_6 tprt_5 (never executed)
                Index Cond: (col1 < tbl1.col1)
 (15 rows)
 
 explain (analyze, costs off, summary off, timing off)
 select * from tbl1 inner join tprt on tbl1.col1 = tprt.col1;
-                                QUERY PLAN                                
---------------------------------------------------------------------------
+                                   QUERY PLAN                                    
+---------------------------------------------------------------------------------
  Nested Loop (actual rows=3 loops=1)
    ->  Seq Scan on tbl1 (actual rows=5 loops=1)
    ->  Append (actual rows=1 loops=5)
-         ->  Index Scan using tprt1_idx on tprt_1 (never executed)
+         ->  Index Scan using tprt1_idx on tprt_1 tprt (never executed)
                Index Cond: (col1 = tbl1.col1)
-         ->  Index Scan using tprt2_idx on tprt_2 (actual rows=1 loops=2)
+         ->  Index Scan using tprt2_idx on tprt_2 tprt_1 (actual rows=1 loops=2)
                Index Cond: (col1 = tbl1.col1)
-         ->  Index Scan using tprt3_idx on tprt_3 (actual rows=0 loops=3)
+         ->  Index Scan using tprt3_idx on tprt_3 tprt_2 (actual rows=0 loops=3)
                Index Cond: (col1 = tbl1.col1)
-         ->  Index Scan using tprt4_idx on tprt_4 (never executed)
+         ->  Index Scan using tprt4_idx on tprt_4 tprt_3 (never executed)
                Index Cond: (col1 = tbl1.col1)
-         ->  Index Scan using tprt5_idx on tprt_5 (never executed)
+         ->  Index Scan using tprt5_idx on tprt_5 tprt_4 (never executed)
                Index Cond: (col1 = tbl1.col1)
-         ->  Index Scan using tprt6_idx on tprt_6 (never executed)
+         ->  Index Scan using tprt6_idx on tprt_6 tprt_5 (never executed)
                Index Cond: (col1 = tbl1.col1)
 (15 rows)
 
@@ -2720,22 +2741,22 @@ delete from tbl1;
 insert into tbl1 values (4400);
 explain (analyze, costs off, summary off, timing off)
 select * from tbl1 join tprt on tbl1.col1 < tprt.col1;
-                                QUERY PLAN                                
---------------------------------------------------------------------------
+                                   QUERY PLAN                                    
+---------------------------------------------------------------------------------
  Nested Loop (actual rows=1 loops=1)
    ->  Seq Scan on tbl1 (actual rows=1 loops=1)
    ->  Append (actual rows=1 loops=1)
-         ->  Index Scan using tprt1_idx on tprt_1 (never executed)
+         ->  Index Scan using tprt1_idx on tprt_1 tprt (never executed)
                Index Cond: (col1 > tbl1.col1)
-         ->  Index Scan using tprt2_idx on tprt_2 (never executed)
+         ->  Index Scan using tprt2_idx on tprt_2 tprt_1 (never executed)
                Index Cond: (col1 > tbl1.col1)
-         ->  Index Scan using tprt3_idx on tprt_3 (never executed)
+         ->  Index Scan using tprt3_idx on tprt_3 tprt_2 (never executed)
                Index Cond: (col1 > tbl1.col1)
-         ->  Index Scan using tprt4_idx on tprt_4 (never executed)
+         ->  Index Scan using tprt4_idx on tprt_4 tprt_3 (never executed)
                Index Cond: (col1 > tbl1.col1)
-         ->  Index Scan using tprt5_idx on tprt_5 (never executed)
+         ->  Index Scan using tprt5_idx on tprt_5 tprt_4 (never executed)
                Index Cond: (col1 > tbl1.col1)
-         ->  Index Scan using tprt6_idx on tprt_6 (actual rows=1 loops=1)
+         ->  Index Scan using tprt6_idx on tprt_6 tprt_5 (actual rows=1 loops=1)
                Index Cond: (col1 > tbl1.col1)
 (15 rows)
 
@@ -2752,22 +2773,22 @@ delete from tbl1;
 insert into tbl1 values (10000);
 explain (analyze, costs off, summary off, timing off)
 select * from tbl1 join tprt on tbl1.col1 = tprt.col1;
-                            QUERY PLAN                             
--------------------------------------------------------------------
+                                QUERY PLAN                                
+--------------------------------------------------------------------------
  Nested Loop (actual rows=0 loops=1)
    ->  Seq Scan on tbl1 (actual rows=1 loops=1)
    ->  Append (actual rows=0 loops=1)
-         ->  Index Scan using tprt1_idx on tprt_1 (never executed)
+         ->  Index Scan using tprt1_idx on tprt_1 tprt (never executed)
                Index Cond: (col1 = tbl1.col1)
-         ->  Index Scan using tprt2_idx on tprt_2 (never executed)
+         ->  Index Scan using tprt2_idx on tprt_2 tprt_1 (never executed)
                Index Cond: (col1 = tbl1.col1)
-         ->  Index Scan using tprt3_idx on tprt_3 (never executed)
+         ->  Index Scan using tprt3_idx on tprt_3 tprt_2 (never executed)
                Index Cond: (col1 = tbl1.col1)
-         ->  Index Scan using tprt4_idx on tprt_4 (never executed)
+         ->  Index Scan using tprt4_idx on tprt_4 tprt_3 (never executed)
                Index Cond: (col1 = tbl1.col1)
-         ->  Index Scan using tprt5_idx on tprt_5 (never executed)
+         ->  Index Scan using tprt5_idx on tprt_5 tprt_4 (never executed)
                Index Cond: (col1 = tbl1.col1)
-         ->  Index Scan using tprt6_idx on tprt_6 (never executed)
+         ->  Index Scan using tprt6_idx on tprt_6 tprt_5 (never executed)
                Index Cond: (col1 = tbl1.col1)
 (15 rows)
 
@@ -2791,9 +2812,9 @@ prepare part_abc_q1 (int, int, int) as
 select * from part_abc where a = $1 and b = $2 and c = $3;
 -- Single partition should be scanned.
 explain (analyze, costs off, summary off, timing off) execute part_abc_q1 (1, 2, 3);
-                   QUERY PLAN                    
--------------------------------------------------
- Seq Scan on part_abc_p1 (actual rows=0 loops=1)
+                        QUERY PLAN                        
+----------------------------------------------------------
+ Seq Scan on part_abc_p1 part_abc (actual rows=0 loops=1)
    Filter: ((a = $1) AND (b = $2) AND (c = $3))
 (2 rows)
 
@@ -2816,31 +2837,31 @@ select * from listp where b = 1;
 -- which match the given parameter.
 prepare q1 (int,int) as select * from listp where b in ($1,$2);
 explain (analyze, costs off, summary off, timing off)  execute q1 (1,1);
-                     QUERY PLAN                      
------------------------------------------------------
+                        QUERY PLAN                         
+-----------------------------------------------------------
  Append (actual rows=0 loops=1)
    Subplans Removed: 1
-   ->  Seq Scan on listp_1_1 (actual rows=0 loops=1)
+   ->  Seq Scan on listp_1_1 listp (actual rows=0 loops=1)
          Filter: (b = ANY (ARRAY[$1, $2]))
 (4 rows)
 
 explain (analyze, costs off, summary off, timing off)  execute q1 (2,2);
-                     QUERY PLAN                      
------------------------------------------------------
+                        QUERY PLAN                         
+-----------------------------------------------------------
  Append (actual rows=0 loops=1)
    Subplans Removed: 1
-   ->  Seq Scan on listp_2_1 (actual rows=0 loops=1)
+   ->  Seq Scan on listp_2_1 listp (actual rows=0 loops=1)
          Filter: (b = ANY (ARRAY[$1, $2]))
 (4 rows)
 
 -- Try with no matching partitions. One subplan should remain in this case,
 -- but it shouldn't be executed.
 explain (analyze, costs off, summary off, timing off)  execute q1 (0,0);
-                  QUERY PLAN                  
-----------------------------------------------
+                     QUERY PLAN                     
+----------------------------------------------------
  Append (actual rows=0 loops=1)
    Subplans Removed: 1
-   ->  Seq Scan on listp_1_1 (never executed)
+   ->  Seq Scan on listp_1_1 listp (never executed)
          Filter: (b = ANY (ARRAY[$1, $2]))
 (4 rows)
 
@@ -2853,7 +2874,7 @@ explain (analyze, costs off, summary off, timing off)  execute q1 (1,2,2,0);
 -------------------------------------------------------------------------
  Append (actual rows=0 loops=1)
    Subplans Removed: 1
-   ->  Seq Scan on listp_1_1 (actual rows=0 loops=1)
+   ->  Seq Scan on listp_1_1 listp (actual rows=0 loops=1)
          Filter: ((b = ANY (ARRAY[$1, $2])) AND ($3 <> b) AND ($4 <> b))
 (4 rows)
 
@@ -2864,21 +2885,21 @@ explain (analyze, costs off, summary off, timing off)  execute q1 (1,2,2,1);
 -------------------------------------------------------------------------
  Append (actual rows=0 loops=1)
    Subplans Removed: 1
-   ->  Seq Scan on listp_1_1 (never executed)
+   ->  Seq Scan on listp_1_1 listp (never executed)
          Filter: ((b = ANY (ARRAY[$1, $2])) AND ($3 <> b) AND ($4 <> b))
 (4 rows)
 
 -- Ensure Params that evaluate to NULL properly prune away all partitions
 explain (analyze, costs off, summary off, timing off)
 select * from listp where a = (select null::int);
-                  QUERY PLAN                  
-----------------------------------------------
+                      QUERY PLAN                      
+------------------------------------------------------
  Append (actual rows=0 loops=1)
    InitPlan 1 (returns $0)
      ->  Result (actual rows=1 loops=1)
-   ->  Seq Scan on listp_1_1 (never executed)
+   ->  Seq Scan on listp_1_1 listp (never executed)
          Filter: (a = $0)
-   ->  Seq Scan on listp_2_1 (never executed)
+   ->  Seq Scan on listp_2_1 listp_1 (never executed)
          Filter: (a = $0)
 (7 rows)
 
@@ -2896,24 +2917,24 @@ create table stable_qual_pruning3 partition of stable_qual_pruning
 -- comparison against a stable value requires run-time pruning
 explain (analyze, costs off, summary off, timing off)
 select * from stable_qual_pruning where a < localtimestamp;
-                           QUERY PLAN                           
-----------------------------------------------------------------
+                                      QUERY PLAN                                      
+--------------------------------------------------------------------------------------
  Append (actual rows=0 loops=1)
    Subplans Removed: 1
-   ->  Seq Scan on stable_qual_pruning1 (actual rows=0 loops=1)
+   ->  Seq Scan on stable_qual_pruning1 stable_qual_pruning (actual rows=0 loops=1)
          Filter: (a < LOCALTIMESTAMP)
-   ->  Seq Scan on stable_qual_pruning2 (actual rows=0 loops=1)
+   ->  Seq Scan on stable_qual_pruning2 stable_qual_pruning_1 (actual rows=0 loops=1)
          Filter: (a < LOCALTIMESTAMP)
 (6 rows)
 
 -- timestamp < timestamptz comparison is only stable, not immutable
 explain (analyze, costs off, summary off, timing off)
 select * from stable_qual_pruning where a < '2000-02-01'::timestamptz;
-                                   QUERY PLAN                                   
---------------------------------------------------------------------------------
+                                     QUERY PLAN                                     
+------------------------------------------------------------------------------------
  Append (actual rows=0 loops=1)
    Subplans Removed: 2
-   ->  Seq Scan on stable_qual_pruning1 (actual rows=0 loops=1)
+   ->  Seq Scan on stable_qual_pruning1 stable_qual_pruning (actual rows=0 loops=1)
          Filter: (a < 'Tue Feb 01 00:00:00 2000 PST'::timestamp with time zone)
 (4 rows)
 
@@ -2932,7 +2953,7 @@ select * from stable_qual_pruning
   where a = any(array['2000-02-01', '2010-01-01']::timestamp[]);
                                                    QUERY PLAN                                                   
 ----------------------------------------------------------------------------------------------------------------
- Seq Scan on stable_qual_pruning2 (actual rows=0 loops=1)
+ Seq Scan on stable_qual_pruning2 stable_qual_pruning (actual rows=0 loops=1)
    Filter: (a = ANY ('{"Tue Feb 01 00:00:00 2000","Fri Jan 01 00:00:00 2010"}'::timestamp without time zone[]))
 (2 rows)
 
@@ -2943,7 +2964,7 @@ select * from stable_qual_pruning
 ------------------------------------------------------------------------------------------------------------
  Append (actual rows=0 loops=1)
    Subplans Removed: 2
-   ->  Seq Scan on stable_qual_pruning2 (actual rows=0 loops=1)
+   ->  Seq Scan on stable_qual_pruning2 stable_qual_pruning (actual rows=0 loops=1)
          Filter: (a = ANY (ARRAY['Tue Feb 01 00:00:00 2000'::timestamp without time zone, LOCALTIMESTAMP]))
 (4 rows)
 
@@ -2954,7 +2975,7 @@ select * from stable_qual_pruning
 ---------------------------------------------------------------------------------------------------------------------------
  Append (actual rows=0 loops=1)
    Subplans Removed: 2
-   ->  Seq Scan on stable_qual_pruning1 (never executed)
+   ->  Seq Scan on stable_qual_pruning1 stable_qual_pruning (never executed)
          Filter: (a = ANY ('{"Mon Feb 01 00:00:00 2010 PST","Wed Jan 01 00:00:00 2020 PST"}'::timestamp with time zone[]))
 (4 rows)
 
@@ -2965,21 +2986,21 @@ select * from stable_qual_pruning
 ---------------------------------------------------------------------------------------------------------------------------
  Append (actual rows=0 loops=1)
    Subplans Removed: 2
-   ->  Seq Scan on stable_qual_pruning2 (actual rows=0 loops=1)
+   ->  Seq Scan on stable_qual_pruning2 stable_qual_pruning (actual rows=0 loops=1)
          Filter: (a = ANY ('{"Tue Feb 01 00:00:00 2000 PST","Fri Jan 01 00:00:00 2010 PST"}'::timestamp with time zone[]))
 (4 rows)
 
 explain (analyze, costs off, summary off, timing off)
 select * from stable_qual_pruning
   where a = any(null::timestamptz[]);
-                           QUERY PLAN                           
-----------------------------------------------------------------
+                                      QUERY PLAN                                      
+--------------------------------------------------------------------------------------
  Append (actual rows=0 loops=1)
-   ->  Seq Scan on stable_qual_pruning1 (actual rows=0 loops=1)
+   ->  Seq Scan on stable_qual_pruning1 stable_qual_pruning (actual rows=0 loops=1)
          Filter: (a = ANY (NULL::timestamp with time zone[]))
-   ->  Seq Scan on stable_qual_pruning2 (actual rows=0 loops=1)
+   ->  Seq Scan on stable_qual_pruning2 stable_qual_pruning_1 (actual rows=0 loops=1)
          Filter: (a = ANY (NULL::timestamp with time zone[]))
-   ->  Seq Scan on stable_qual_pruning3 (actual rows=0 loops=1)
+   ->  Seq Scan on stable_qual_pruning3 stable_qual_pruning_2 (actual rows=0 loops=1)
          Filter: (a = ANY (NULL::timestamp with time zone[]))
 (7 rows)
 
@@ -2999,14 +3020,14 @@ create table mc3p2 partition of mc3p
 insert into mc3p values (0, 1, 1), (1, 1, 1), (2, 1, 1);
 explain (analyze, costs off, summary off, timing off)
 select * from mc3p where a < 3 and abs(b) = 1;
-                   QUERY PLAN                    
--------------------------------------------------
+                       QUERY PLAN                       
+--------------------------------------------------------
  Append (actual rows=3 loops=1)
-   ->  Seq Scan on mc3p0 (actual rows=1 loops=1)
+   ->  Seq Scan on mc3p0 mc3p (actual rows=1 loops=1)
          Filter: ((a < 3) AND (abs(b) = 1))
-   ->  Seq Scan on mc3p1 (actual rows=1 loops=1)
+   ->  Seq Scan on mc3p1 mc3p_1 (actual rows=1 loops=1)
          Filter: ((a < 3) AND (abs(b) = 1))
-   ->  Seq Scan on mc3p2 (actual rows=1 loops=1)
+   ->  Seq Scan on mc3p2 mc3p_2 (actual rows=1 loops=1)
          Filter: ((a < 3) AND (abs(b) = 1))
 (7 rows)
 
@@ -3019,13 +3040,13 @@ prepare ps1 as
   select * from mc3p where a = $1 and abs(b) < (select 3);
 explain (analyze, costs off, summary off, timing off)
 execute ps1(1);
-                   QUERY PLAN                    
--------------------------------------------------
+                      QUERY PLAN                      
+------------------------------------------------------
  Append (actual rows=1 loops=1)
    InitPlan 1 (returns $0)
      ->  Result (actual rows=1 loops=1)
    Subplans Removed: 2
-   ->  Seq Scan on mc3p1 (actual rows=1 loops=1)
+   ->  Seq Scan on mc3p1 mc3p (actual rows=1 loops=1)
          Filter: ((a = $1) AND (abs(b) < $0))
 (6 rows)
 
@@ -3034,15 +3055,15 @@ prepare ps2 as
   select * from mc3p where a <= $1 and abs(b) < (select 3);
 explain (analyze, costs off, summary off, timing off)
 execute ps2(1);
-                   QUERY PLAN                    
--------------------------------------------------
+                       QUERY PLAN                       
+--------------------------------------------------------
  Append (actual rows=2 loops=1)
    InitPlan 1 (returns $0)
      ->  Result (actual rows=1 loops=1)
    Subplans Removed: 1
-   ->  Seq Scan on mc3p0 (actual rows=1 loops=1)
+   ->  Seq Scan on mc3p0 mc3p (actual rows=1 loops=1)
          Filter: ((a <= $1) AND (abs(b) < $0))
-   ->  Seq Scan on mc3p1 (actual rows=1 loops=1)
+   ->  Seq Scan on mc3p1 mc3p_1 (actual rows=1 loops=1)
          Filter: ((a <= $1) AND (abs(b) < $0))
 (8 rows)
 
@@ -3056,31 +3077,31 @@ create table boolp_t partition of boolp for values in('t');
 create table boolp_f partition of boolp for values in('f');
 explain (analyze, costs off, summary off, timing off)
 select * from boolp where a = (select value from boolvalues where value);
-                       QUERY PLAN                       
---------------------------------------------------------
+                        QUERY PLAN                         
+-----------------------------------------------------------
  Append (actual rows=0 loops=1)
    InitPlan 1 (returns $0)
      ->  Seq Scan on boolvalues (actual rows=1 loops=1)
            Filter: value
            Rows Removed by Filter: 1
-   ->  Seq Scan on boolp_f (never executed)
+   ->  Seq Scan on boolp_f boolp (never executed)
          Filter: (a = $0)
-   ->  Seq Scan on boolp_t (actual rows=0 loops=1)
+   ->  Seq Scan on boolp_t boolp_1 (actual rows=0 loops=1)
          Filter: (a = $0)
 (9 rows)
 
 explain (analyze, costs off, summary off, timing off)
 select * from boolp where a = (select value from boolvalues where not value);
-                       QUERY PLAN                       
---------------------------------------------------------
+                       QUERY PLAN                        
+---------------------------------------------------------
  Append (actual rows=0 loops=1)
    InitPlan 1 (returns $0)
      ->  Seq Scan on boolvalues (actual rows=1 loops=1)
            Filter: (NOT value)
            Rows Removed by Filter: 1
-   ->  Seq Scan on boolp_f (actual rows=0 loops=1)
+   ->  Seq Scan on boolp_f boolp (actual rows=0 loops=1)
          Filter: (a = $0)
-   ->  Seq Scan on boolp_t (never executed)
+   ->  Seq Scan on boolp_t boolp_1 (never executed)
          Filter: (a = $0)
 (9 rows)
 
@@ -3099,15 +3120,15 @@ create index on ma_test (b);
 analyze ma_test;
 prepare mt_q1 (int) as select a from ma_test where a >= $1 and a % 10 = 5 order by b;
 explain (analyze, costs off, summary off, timing off) execute mt_q1(15);
-                                  QUERY PLAN                                   
--------------------------------------------------------------------------------
+                                       QUERY PLAN                                        
+-----------------------------------------------------------------------------------------
  Merge Append (actual rows=2 loops=1)
-   Sort Key: ma_test_p2.b
+   Sort Key: ma_test.b
    Subplans Removed: 1
-   ->  Index Scan using ma_test_p2_b_idx on ma_test_p2 (actual rows=1 loops=1)
+   ->  Index Scan using ma_test_p2_b_idx on ma_test_p2 ma_test (actual rows=1 loops=1)
          Filter: ((a >= $1) AND ((a % 10) = 5))
          Rows Removed by Filter: 9
-   ->  Index Scan using ma_test_p3_b_idx on ma_test_p3 (actual rows=1 loops=1)
+   ->  Index Scan using ma_test_p3_b_idx on ma_test_p3 ma_test_1 (actual rows=1 loops=1)
          Filter: ((a >= $1) AND ((a % 10) = 5))
          Rows Removed by Filter: 9
 (9 rows)
@@ -3120,12 +3141,12 @@ execute mt_q1(15);
 (2 rows)
 
 explain (analyze, costs off, summary off, timing off) execute mt_q1(25);
-                                  QUERY PLAN                                   
--------------------------------------------------------------------------------
+                                      QUERY PLAN                                       
+---------------------------------------------------------------------------------------
  Merge Append (actual rows=1 loops=1)
-   Sort Key: ma_test_p3.b
+   Sort Key: ma_test.b
    Subplans Removed: 2
-   ->  Index Scan using ma_test_p3_b_idx on ma_test_p3 (actual rows=1 loops=1)
+   ->  Index Scan using ma_test_p3_b_idx on ma_test_p3 ma_test (actual rows=1 loops=1)
          Filter: ((a >= $1) AND ((a % 10) = 5))
          Rows Removed by Filter: 9
 (6 rows)
@@ -3138,12 +3159,12 @@ execute mt_q1(25);
 
 -- Ensure MergeAppend behaves correctly when no subplans match
 explain (analyze, costs off, summary off, timing off) execute mt_q1(35);
-                               QUERY PLAN                               
-------------------------------------------------------------------------
+                                   QUERY PLAN                                   
+--------------------------------------------------------------------------------
  Merge Append (actual rows=0 loops=1)
-   Sort Key: ma_test_p1.b
+   Sort Key: ma_test.b
    Subplans Removed: 2
-   ->  Index Scan using ma_test_p1_b_idx on ma_test_p1 (never executed)
+   ->  Index Scan using ma_test_p1_b_idx on ma_test_p1 ma_test (never executed)
          Filter: ((a >= $1) AND ((a % 10) = 5))
 (5 rows)
 
@@ -3155,21 +3176,21 @@ execute mt_q1(35);
 deallocate mt_q1;
 -- ensure initplan params properly prune partitions
 explain (analyze, costs off, summary off, timing off) select * from ma_test where a >= (select min(b) from ma_test_p2) order by b;
-                                                 QUERY PLAN                                                 
-------------------------------------------------------------------------------------------------------------
+                                          QUERY PLAN                                           
+-----------------------------------------------------------------------------------------------
  Merge Append (actual rows=20 loops=1)
-   Sort Key: ma_test_p1.b
+   Sort Key: ma_test.b
    InitPlan 2 (returns $1)
      ->  Result (actual rows=1 loops=1)
            InitPlan 1 (returns $0)
              ->  Limit (actual rows=1 loops=1)
-                   ->  Index Scan using ma_test_p2_b_idx on ma_test_p2 ma_test_p2_1 (actual rows=1 loops=1)
+                   ->  Index Scan using ma_test_p2_b_idx on ma_test_p2 (actual rows=1 loops=1)
                          Index Cond: (b IS NOT NULL)
-   ->  Index Scan using ma_test_p1_b_idx on ma_test_p1 (never executed)
+   ->  Index Scan using ma_test_p1_b_idx on ma_test_p1 ma_test (never executed)
          Filter: (a >= $1)
-   ->  Index Scan using ma_test_p2_b_idx on ma_test_p2 (actual rows=10 loops=1)
+   ->  Index Scan using ma_test_p2_b_idx on ma_test_p2 ma_test_1 (actual rows=10 loops=1)
          Filter: (a >= $1)
-   ->  Index Scan using ma_test_p3_b_idx on ma_test_p3 (actual rows=10 loops=1)
+   ->  Index Scan using ma_test_p3_b_idx on ma_test_p3 ma_test_2 (actual rows=10 loops=1)
          Filter: (a >= $1)
 (14 rows)
 
@@ -3186,9 +3207,9 @@ create table pp_arrpart (a int[]) partition by list (a);
 create table pp_arrpart1 partition of pp_arrpart for values in ('{1}');
 create table pp_arrpart2 partition of pp_arrpart for values in ('{2, 3}', '{4, 5}');
 explain (costs off) select * from pp_arrpart where a = '{1}';
-            QUERY PLAN            
-----------------------------------
- Seq Scan on pp_arrpart1
+             QUERY PLAN             
+------------------------------------
+ Seq Scan on pp_arrpart1 pp_arrpart
    Filter: (a = '{1}'::integer[])
 (2 rows)
 
@@ -3203,27 +3224,27 @@ explain (costs off) select * from pp_arrpart where a in ('{4, 5}', '{1}');
                               QUERY PLAN                              
 ----------------------------------------------------------------------
  Append
-   ->  Seq Scan on pp_arrpart1
+   ->  Seq Scan on pp_arrpart1 pp_arrpart
          Filter: ((a = '{4,5}'::integer[]) OR (a = '{1}'::integer[]))
-   ->  Seq Scan on pp_arrpart2
+   ->  Seq Scan on pp_arrpart2 pp_arrpart_1
          Filter: ((a = '{4,5}'::integer[]) OR (a = '{1}'::integer[]))
 (5 rows)
 
 explain (costs off) update pp_arrpart set a = a where a = '{1}';
-               QUERY PLAN               
-----------------------------------------
+                 QUERY PLAN                 
+--------------------------------------------
  Update on pp_arrpart
-   Update on pp_arrpart1
-   ->  Seq Scan on pp_arrpart1
+   Update on pp_arrpart1 pp_arrpart_1
+   ->  Seq Scan on pp_arrpart1 pp_arrpart_1
          Filter: (a = '{1}'::integer[])
 (4 rows)
 
 explain (costs off) delete from pp_arrpart where a = '{1}';
-               QUERY PLAN               
-----------------------------------------
+                 QUERY PLAN                 
+--------------------------------------------
  Delete on pp_arrpart
-   Delete on pp_arrpart1
-   ->  Seq Scan on pp_arrpart1
+   Delete on pp_arrpart1 pp_arrpart_1
+   ->  Seq Scan on pp_arrpart1 pp_arrpart_1
          Filter: (a = '{1}'::integer[])
 (4 rows)
 
@@ -3242,16 +3263,16 @@ select tableoid::regclass, * from pph_arrpart order by 1;
 (3 rows)
 
 explain (costs off) select * from pph_arrpart where a = '{1}';
-            QUERY PLAN            
-----------------------------------
- Seq Scan on pph_arrpart2
+              QUERY PLAN              
+--------------------------------------
+ Seq Scan on pph_arrpart2 pph_arrpart
    Filter: (a = '{1}'::integer[])
 (2 rows)
 
 explain (costs off) select * from pph_arrpart where a = '{1, 2}';
-             QUERY PLAN             
-------------------------------------
- Seq Scan on pph_arrpart1
+              QUERY PLAN              
+--------------------------------------
+ Seq Scan on pph_arrpart1 pph_arrpart
    Filter: (a = '{1,2}'::integer[])
 (2 rows)
 
@@ -3259,9 +3280,9 @@ explain (costs off) select * from pph_arrpart where a in ('{4, 5}', '{1}');
                               QUERY PLAN                              
 ----------------------------------------------------------------------
  Append
-   ->  Seq Scan on pph_arrpart1
+   ->  Seq Scan on pph_arrpart1 pph_arrpart
          Filter: ((a = '{4,5}'::integer[]) OR (a = '{1}'::integer[]))
-   ->  Seq Scan on pph_arrpart2
+   ->  Seq Scan on pph_arrpart2 pph_arrpart_1
          Filter: ((a = '{4,5}'::integer[]) OR (a = '{1}'::integer[]))
 (5 rows)
 
@@ -3272,9 +3293,9 @@ create table pp_enumpart (a pp_colors) partition by list (a);
 create table pp_enumpart_green partition of pp_enumpart for values in ('green');
 create table pp_enumpart_blue partition of pp_enumpart for values in ('blue');
 explain (costs off) select * from pp_enumpart where a = 'blue';
-            QUERY PLAN             
------------------------------------
- Seq Scan on pp_enumpart_blue
+                QUERY PLAN                
+------------------------------------------
+ Seq Scan on pp_enumpart_blue pp_enumpart
    Filter: (a = 'blue'::pp_colors)
 (2 rows)
 
@@ -3293,9 +3314,9 @@ create table pp_recpart (a pp_rectype) partition by list (a);
 create table pp_recpart_11 partition of pp_recpart for values in ('(1,1)');
 create table pp_recpart_23 partition of pp_recpart for values in ('(2,3)');
 explain (costs off) select * from pp_recpart where a = '(1,1)'::pp_rectype;
-             QUERY PLAN              
--------------------------------------
- Seq Scan on pp_recpart_11
+              QUERY PLAN              
+--------------------------------------
+ Seq Scan on pp_recpart_11 pp_recpart
    Filter: (a = '(1,1)'::pp_rectype)
 (2 rows)
 
@@ -3313,9 +3334,9 @@ create table pp_intrangepart (a int4range) partition by list (a);
 create table pp_intrangepart12 partition of pp_intrangepart for values in ('[1,2]');
 create table pp_intrangepart2inf partition of pp_intrangepart for values in ('[2,)');
 explain (costs off) select * from pp_intrangepart where a = '[1,2]'::int4range;
-             QUERY PLAN             
-------------------------------------
- Seq Scan on pp_intrangepart12
+                  QUERY PLAN                   
+-----------------------------------------------
+ Seq Scan on pp_intrangepart12 pp_intrangepart
    Filter: (a = '[1,3)'::int4range)
 (2 rows)
 
@@ -3334,98 +3355,98 @@ create table pp_lp (a int, value int) partition by list (a);
 create table pp_lp1 partition of pp_lp for values in(1);
 create table pp_lp2 partition of pp_lp for values in(2);
 explain (costs off) select * from pp_lp where a = 1;
-     QUERY PLAN     
---------------------
- Seq Scan on pp_lp1
+        QUERY PLAN        
+--------------------------
+ Seq Scan on pp_lp1 pp_lp
    Filter: (a = 1)
 (2 rows)
 
 explain (costs off) update pp_lp set value = 10 where a = 1;
-        QUERY PLAN        
---------------------------
+            QUERY PLAN            
+----------------------------------
  Update on pp_lp
-   Update on pp_lp1
-   ->  Seq Scan on pp_lp1
+   Update on pp_lp1 pp_lp_1
+   ->  Seq Scan on pp_lp1 pp_lp_1
          Filter: (a = 1)
 (4 rows)
 
 explain (costs off) delete from pp_lp where a = 1;
-        QUERY PLAN        
---------------------------
+            QUERY PLAN            
+----------------------------------
  Delete on pp_lp
-   Delete on pp_lp1
-   ->  Seq Scan on pp_lp1
+   Delete on pp_lp1 pp_lp_1
+   ->  Seq Scan on pp_lp1 pp_lp_1
          Filter: (a = 1)
 (4 rows)
 
 set enable_partition_pruning = off;
 set constraint_exclusion = 'partition'; -- this should not affect the result.
 explain (costs off) select * from pp_lp where a = 1;
-        QUERY PLAN        
---------------------------
+            QUERY PLAN            
+----------------------------------
  Append
-   ->  Seq Scan on pp_lp1
+   ->  Seq Scan on pp_lp1 pp_lp
          Filter: (a = 1)
-   ->  Seq Scan on pp_lp2
+   ->  Seq Scan on pp_lp2 pp_lp_1
          Filter: (a = 1)
 (5 rows)
 
 explain (costs off) update pp_lp set value = 10 where a = 1;
-        QUERY PLAN        
---------------------------
+            QUERY PLAN            
+----------------------------------
  Update on pp_lp
-   Update on pp_lp1
-   Update on pp_lp2
-   ->  Seq Scan on pp_lp1
+   Update on pp_lp1 pp_lp_1
+   Update on pp_lp2 pp_lp_2
+   ->  Seq Scan on pp_lp1 pp_lp_1
          Filter: (a = 1)
-   ->  Seq Scan on pp_lp2
+   ->  Seq Scan on pp_lp2 pp_lp_2
          Filter: (a = 1)
 (7 rows)
 
 explain (costs off) delete from pp_lp where a = 1;
-        QUERY PLAN        
---------------------------
+            QUERY PLAN            
+----------------------------------
  Delete on pp_lp
-   Delete on pp_lp1
-   Delete on pp_lp2
-   ->  Seq Scan on pp_lp1
+   Delete on pp_lp1 pp_lp_1
+   Delete on pp_lp2 pp_lp_2
+   ->  Seq Scan on pp_lp1 pp_lp_1
          Filter: (a = 1)
-   ->  Seq Scan on pp_lp2
+   ->  Seq Scan on pp_lp2 pp_lp_2
          Filter: (a = 1)
 (7 rows)
 
 set constraint_exclusion = 'off'; -- this should not affect the result.
 explain (costs off) select * from pp_lp where a = 1;
-        QUERY PLAN        
---------------------------
+            QUERY PLAN            
+----------------------------------
  Append
-   ->  Seq Scan on pp_lp1
+   ->  Seq Scan on pp_lp1 pp_lp
          Filter: (a = 1)
-   ->  Seq Scan on pp_lp2
+   ->  Seq Scan on pp_lp2 pp_lp_1
          Filter: (a = 1)
 (5 rows)
 
 explain (costs off) update pp_lp set value = 10 where a = 1;
-        QUERY PLAN        
---------------------------
+            QUERY PLAN            
+----------------------------------
  Update on pp_lp
-   Update on pp_lp1
-   Update on pp_lp2
-   ->  Seq Scan on pp_lp1
+   Update on pp_lp1 pp_lp_1
+   Update on pp_lp2 pp_lp_2
+   ->  Seq Scan on pp_lp1 pp_lp_1
          Filter: (a = 1)
-   ->  Seq Scan on pp_lp2
+   ->  Seq Scan on pp_lp2 pp_lp_2
          Filter: (a = 1)
 (7 rows)
 
 explain (costs off) delete from pp_lp where a = 1;
-        QUERY PLAN        
---------------------------
+            QUERY PLAN            
+----------------------------------
  Delete on pp_lp
-   Delete on pp_lp1
-   Delete on pp_lp2
-   ->  Seq Scan on pp_lp1
+   Delete on pp_lp1 pp_lp_1
+   Delete on pp_lp2 pp_lp_2
+   ->  Seq Scan on pp_lp1 pp_lp_1
          Filter: (a = 1)
-   ->  Seq Scan on pp_lp2
+   ->  Seq Scan on pp_lp2 pp_lp_2
          Filter: (a = 1)
 (7 rows)
 
@@ -3441,36 +3462,36 @@ NOTICE:  merging column "value" with inherited definition
 set constraint_exclusion = 'partition';
 -- inh_lp2 should be removed in the following 3 cases.
 explain (costs off) select * from inh_lp where a = 1;
-        QUERY PLAN         
----------------------------
+             QUERY PLAN             
+------------------------------------
  Append
    ->  Seq Scan on inh_lp
          Filter: (a = 1)
-   ->  Seq Scan on inh_lp1
+   ->  Seq Scan on inh_lp1 inh_lp_1
          Filter: (a = 1)
 (5 rows)
 
 explain (costs off) update inh_lp set value = 10 where a = 1;
-        QUERY PLAN         
----------------------------
+             QUERY PLAN             
+------------------------------------
  Update on inh_lp
    Update on inh_lp
-   Update on inh_lp1
+   Update on inh_lp1 inh_lp_1
    ->  Seq Scan on inh_lp
          Filter: (a = 1)
-   ->  Seq Scan on inh_lp1
+   ->  Seq Scan on inh_lp1 inh_lp_1
          Filter: (a = 1)
 (7 rows)
 
 explain (costs off) delete from inh_lp where a = 1;
-        QUERY PLAN         
----------------------------
+             QUERY PLAN             
+------------------------------------
  Delete on inh_lp
    Delete on inh_lp
-   Delete on inh_lp1
+   Delete on inh_lp1 inh_lp_1
    ->  Seq Scan on inh_lp
          Filter: (a = 1)
-   ->  Seq Scan on inh_lp1
+   ->  Seq Scan on inh_lp1 inh_lp_1
          Filter: (a = 1)
 (7 rows)
 
@@ -3495,17 +3516,17 @@ create temp table pp_temp_parent (a int) partition by list (a);
 create temp table pp_temp_part_1 partition of pp_temp_parent for values in (1);
 create temp table pp_temp_part_def partition of pp_temp_parent default;
 explain (costs off) select * from pp_temp_parent where true;
-             QUERY PLAN             
-------------------------------------
+                     QUERY PLAN                      
+-----------------------------------------------------
  Append
-   ->  Seq Scan on pp_temp_part_1
-   ->  Seq Scan on pp_temp_part_def
+   ->  Seq Scan on pp_temp_part_1 pp_temp_parent
+   ->  Seq Scan on pp_temp_part_def pp_temp_parent_1
 (3 rows)
 
 explain (costs off) select * from pp_temp_parent where a = 2;
-          QUERY PLAN          
-------------------------------
- Seq Scan on pp_temp_part_def
+                 QUERY PLAN                  
+---------------------------------------------
+ Seq Scan on pp_temp_part_def pp_temp_parent
    Filter: (a = 2)
 (2 rows)
 
@@ -3537,9 +3558,9 @@ where s.a = 1 and s.b = 1 and s.c = (select 1);
  Append
    InitPlan 1 (returns $0)
      ->  Result
-   ->  Seq Scan on p1
+   ->  Seq Scan on p1 p
          Filter: ((a = 1) AND (b = 1) AND (c = $0))
-   ->  Seq Scan on q111
+   ->  Seq Scan on q111 q1
          Filter: ((a = 1) AND (b = 1) AND (c = $0))
    ->  Result
          One-Time Filter: (1 = $0)
@@ -3576,9 +3597,9 @@ explain (costs off) execute q (1, 1);
    InitPlan 1 (returns $0)
      ->  Result
    Subplans Removed: 1
-   ->  Seq Scan on p1
+   ->  Seq Scan on p1 p
          Filter: ((a = $1) AND (b = $2) AND (c = $0))
-   ->  Seq Scan on q111
+   ->  Seq Scan on q111 q1
          Filter: ((a = $1) AND (b = $2) AND (c = $0))
    ->  Result
          One-Time Filter: ((1 = $1) AND (1 = $2) AND (1 = $0))
@@ -3599,9 +3620,9 @@ create table listp2 partition of listp for values in(2) partition by list(b);
 create table listp2_10 partition of listp2 for values in (10);
 explain (analyze, costs off, summary off, timing off)
 select * from listp where a = (select 2) and b <> 10;
-                 QUERY PLAN                 
---------------------------------------------
- Seq Scan on listp1 (actual rows=0 loops=1)
+                    QUERY PLAN                    
+--------------------------------------------------
+ Seq Scan on listp1 listp (actual rows=0 loops=1)
    Filter: ((b <> 10) AND (a = $0))
    InitPlan 1 (returns $0)
      ->  Result (never executed)
diff --git a/src/test/regress/expected/rowsecurity.out b/src/test/regress/expected/rowsecurity.out
index d01769299e4f..d2b846c88443 100644
--- a/src/test/regress/expected/rowsecurity.out
+++ b/src/test/regress/expected/rowsecurity.out
@@ -664,9 +664,9 @@ EXPLAIN (COSTS OFF) SELECT * FROM t1;
  Append
    ->  Seq Scan on t1
          Filter: ((a % 2) = 0)
-   ->  Seq Scan on t2
+   ->  Seq Scan on t2 t1_1
          Filter: ((a % 2) = 0)
-   ->  Seq Scan on t3
+   ->  Seq Scan on t3 t1_2
          Filter: ((a % 2) = 0)
 (7 rows)
 
@@ -691,9 +691,9 @@ EXPLAIN (COSTS OFF) SELECT * FROM t1 WHERE f_leak(b);
  Append
    ->  Seq Scan on t1
          Filter: (((a % 2) = 0) AND f_leak(b))
-   ->  Seq Scan on t2
+   ->  Seq Scan on t2 t1_1
          Filter: (((a % 2) = 0) AND f_leak(b))
-   ->  Seq Scan on t3
+   ->  Seq Scan on t3 t1_2
          Filter: (((a % 2) = 0) AND f_leak(b))
 (7 rows)
 
@@ -714,9 +714,9 @@ EXPLAIN (COSTS OFF) SELECT *, t1 FROM t1;
  Append
    ->  Seq Scan on t1
          Filter: ((a % 2) = 0)
-   ->  Seq Scan on t2
+   ->  Seq Scan on t2 t1_1
          Filter: ((a % 2) = 0)
-   ->  Seq Scan on t3
+   ->  Seq Scan on t3 t1_2
          Filter: ((a % 2) = 0)
 (7 rows)
 
@@ -737,9 +737,9 @@ EXPLAIN (COSTS OFF) SELECT *, t1 FROM t1;
  Append
    ->  Seq Scan on t1
          Filter: ((a % 2) = 0)
-   ->  Seq Scan on t2
+   ->  Seq Scan on t2 t1_1
          Filter: ((a % 2) = 0)
-   ->  Seq Scan on t3
+   ->  Seq Scan on t3 t1_2
          Filter: ((a % 2) = 0)
 (7 rows)
 
@@ -761,9 +761,9 @@ EXPLAIN (COSTS OFF) SELECT * FROM t1 FOR SHARE;
    ->  Append
          ->  Seq Scan on t1
                Filter: ((a % 2) = 0)
-         ->  Seq Scan on t2
+         ->  Seq Scan on t2 t1_1
                Filter: ((a % 2) = 0)
-         ->  Seq Scan on t3
+         ->  Seq Scan on t3 t1_2
                Filter: ((a % 2) = 0)
 (8 rows)
 
@@ -789,9 +789,9 @@ EXPLAIN (COSTS OFF) SELECT * FROM t1 WHERE f_leak(b) FOR SHARE;
    ->  Append
          ->  Seq Scan on t1
                Filter: (((a % 2) = 0) AND f_leak(b))
-         ->  Seq Scan on t2
+         ->  Seq Scan on t2 t1_1
                Filter: (((a % 2) = 0) AND f_leak(b))
-         ->  Seq Scan on t3
+         ->  Seq Scan on t3 t1_2
                Filter: (((a % 2) = 0) AND f_leak(b))
 (8 rows)
 
@@ -851,9 +851,9 @@ EXPLAIN (COSTS OFF) SELECT * FROM t1 WHERE f_leak(b);
  Append
    ->  Seq Scan on t1
          Filter: f_leak(b)
-   ->  Seq Scan on t2
+   ->  Seq Scan on t2 t1_1
          Filter: f_leak(b)
-   ->  Seq Scan on t3
+   ->  Seq Scan on t3 t1_2
          Filter: f_leak(b)
 (7 rows)
 
@@ -893,9 +893,9 @@ EXPLAIN (COSTS OFF) SELECT * FROM t1 WHERE f_leak(b);
  Append
    ->  Seq Scan on t1
          Filter: f_leak(b)
-   ->  Seq Scan on t2
+   ->  Seq Scan on t2 t1_1
          Filter: f_leak(b)
-   ->  Seq Scan on t3
+   ->  Seq Scan on t3 t1_2
          Filter: f_leak(b)
 (7 rows)
 
@@ -985,17 +985,17 @@ NOTICE:  f_leak => my first satire
 (4 rows)
 
 EXPLAIN (COSTS OFF) SELECT * FROM part_document WHERE f_leak(dtitle);
-                     QUERY PLAN                      
------------------------------------------------------
+                         QUERY PLAN                         
+------------------------------------------------------------
  Append
    InitPlan 1 (returns $0)
      ->  Index Scan using uaccount_pkey on uaccount
            Index Cond: (pguser = CURRENT_USER)
-   ->  Seq Scan on part_document_fiction
+   ->  Seq Scan on part_document_fiction part_document
          Filter: ((dlevel <= $0) AND f_leak(dtitle))
-   ->  Seq Scan on part_document_satire
+   ->  Seq Scan on part_document_satire part_document_1
          Filter: ((dlevel <= $0) AND f_leak(dtitle))
-   ->  Seq Scan on part_document_nonfiction
+   ->  Seq Scan on part_document_nonfiction part_document_2
          Filter: ((dlevel <= $0) AND f_leak(dtitle))
 (10 rows)
 
@@ -1027,17 +1027,17 @@ NOTICE:  f_leak => awesome technology book
 (10 rows)
 
 EXPLAIN (COSTS OFF) SELECT * FROM part_document WHERE f_leak(dtitle);
-                     QUERY PLAN                      
------------------------------------------------------
+                         QUERY PLAN                         
+------------------------------------------------------------
  Append
    InitPlan 1 (returns $0)
      ->  Index Scan using uaccount_pkey on uaccount
            Index Cond: (pguser = CURRENT_USER)
-   ->  Seq Scan on part_document_fiction
+   ->  Seq Scan on part_document_fiction part_document
          Filter: ((dlevel <= $0) AND f_leak(dtitle))
-   ->  Seq Scan on part_document_satire
+   ->  Seq Scan on part_document_satire part_document_1
          Filter: ((dlevel <= $0) AND f_leak(dtitle))
-   ->  Seq Scan on part_document_nonfiction
+   ->  Seq Scan on part_document_nonfiction part_document_2
          Filter: ((dlevel <= $0) AND f_leak(dtitle))
 (10 rows)
 
@@ -1059,7 +1059,7 @@ NOTICE:  f_leak => awesome science fiction
 EXPLAIN (COSTS OFF) SELECT * FROM part_document WHERE f_leak(dtitle);
                           QUERY PLAN                          
 --------------------------------------------------------------
- Seq Scan on part_document_fiction
+ Seq Scan on part_document_fiction part_document
    Filter: ((cid < 55) AND (dlevel <= $0) AND f_leak(dtitle))
    InitPlan 1 (returns $0)
      ->  Index Scan using uaccount_pkey on uaccount
@@ -1137,7 +1137,7 @@ NOTICE:  f_leak => awesome science fiction
 EXPLAIN (COSTS OFF) SELECT * FROM part_document WHERE f_leak(dtitle);
                           QUERY PLAN                          
 --------------------------------------------------------------
- Seq Scan on part_document_fiction
+ Seq Scan on part_document_fiction part_document
    Filter: ((cid < 55) AND (dlevel <= $0) AND f_leak(dtitle))
    InitPlan 1 (returns $0)
      ->  Index Scan using uaccount_pkey on uaccount
@@ -1174,17 +1174,17 @@ NOTICE:  f_leak => awesome technology book
 (11 rows)
 
 EXPLAIN (COSTS OFF) SELECT * FROM part_document WHERE f_leak(dtitle);
-                     QUERY PLAN                      
------------------------------------------------------
+                         QUERY PLAN                         
+------------------------------------------------------------
  Append
    InitPlan 1 (returns $0)
      ->  Index Scan using uaccount_pkey on uaccount
            Index Cond: (pguser = CURRENT_USER)
-   ->  Seq Scan on part_document_fiction
+   ->  Seq Scan on part_document_fiction part_document
          Filter: ((dlevel <= $0) AND f_leak(dtitle))
-   ->  Seq Scan on part_document_satire
+   ->  Seq Scan on part_document_satire part_document_1
          Filter: ((dlevel <= $0) AND f_leak(dtitle))
-   ->  Seq Scan on part_document_nonfiction
+   ->  Seq Scan on part_document_nonfiction part_document_2
          Filter: ((dlevel <= $0) AND f_leak(dtitle))
 (10 rows)
 
@@ -1229,11 +1229,11 @@ EXPLAIN (COSTS OFF) SELECT * FROM part_document WHERE f_leak(dtitle);
                           QUERY PLAN                           
 ---------------------------------------------------------------
  Append
-   ->  Seq Scan on part_document_fiction
+   ->  Seq Scan on part_document_fiction part_document
          Filter: ((dauthor = CURRENT_USER) AND f_leak(dtitle))
-   ->  Seq Scan on part_document_satire
+   ->  Seq Scan on part_document_satire part_document_1
          Filter: ((dauthor = CURRENT_USER) AND f_leak(dtitle))
-   ->  Seq Scan on part_document_nonfiction
+   ->  Seq Scan on part_document_nonfiction part_document_2
          Filter: ((dauthor = CURRENT_USER) AND f_leak(dtitle))
 (7 rows)
 
@@ -1511,9 +1511,9 @@ EXPLAIN (COSTS OFF) EXECUTE p1(2);
  Append
    ->  Seq Scan on t1
          Filter: ((a <= 2) AND ((a % 2) = 0))
-   ->  Seq Scan on t2
+   ->  Seq Scan on t2 t1_1
          Filter: ((a <= 2) AND ((a % 2) = 0))
-   ->  Seq Scan on t3
+   ->  Seq Scan on t3 t1_2
          Filter: ((a <= 2) AND ((a % 2) = 0))
 (7 rows)
 
@@ -1553,9 +1553,9 @@ EXPLAIN (COSTS OFF) SELECT * FROM t1 WHERE f_leak(b);
  Append
    ->  Seq Scan on t1
          Filter: f_leak(b)
-   ->  Seq Scan on t2
+   ->  Seq Scan on t2 t1_1
          Filter: f_leak(b)
-   ->  Seq Scan on t3
+   ->  Seq Scan on t3 t1_2
          Filter: f_leak(b)
 (7 rows)
 
@@ -1572,14 +1572,14 @@ EXECUTE p1(2);
 (6 rows)
 
 EXPLAIN (COSTS OFF) EXECUTE p1(2);
-        QUERY PLAN        
---------------------------
+        QUERY PLAN         
+---------------------------
  Append
    ->  Seq Scan on t1
          Filter: (a <= 2)
-   ->  Seq Scan on t2
+   ->  Seq Scan on t2 t1_1
          Filter: (a <= 2)
-   ->  Seq Scan on t3
+   ->  Seq Scan on t3 t1_2
          Filter: (a <= 2)
 (7 rows)
 
@@ -1593,14 +1593,14 @@ EXECUTE p2(2);
 (3 rows)
 
 EXPLAIN (COSTS OFF) EXECUTE p2(2);
-       QUERY PLAN        
--------------------------
+        QUERY PLAN         
+---------------------------
  Append
    ->  Seq Scan on t1
          Filter: (a = 2)
-   ->  Seq Scan on t2
+   ->  Seq Scan on t2 t1_1
          Filter: (a = 2)
-   ->  Seq Scan on t3
+   ->  Seq Scan on t3 t1_2
          Filter: (a = 2)
 (7 rows)
 
@@ -1621,9 +1621,9 @@ EXPLAIN (COSTS OFF) EXECUTE p2(2);
  Append
    ->  Seq Scan on t1
          Filter: ((a = 2) AND ((a % 2) = 0))
-   ->  Seq Scan on t2
+   ->  Seq Scan on t2 t1_1
          Filter: ((a = 2) AND ((a % 2) = 0))
-   ->  Seq Scan on t3
+   ->  Seq Scan on t3 t1_2
          Filter: ((a = 2) AND ((a % 2) = 0))
 (7 rows)
 
@@ -1636,13 +1636,13 @@ EXPLAIN (COSTS OFF) UPDATE t1 SET b = b || b WHERE f_leak(b);
 -----------------------------------------------
  Update on t1
    Update on t1
-   Update on t2
-   Update on t3
+   Update on t2 t1_1
+   Update on t3 t1_2
    ->  Seq Scan on t1
          Filter: (((a % 2) = 0) AND f_leak(b))
-   ->  Seq Scan on t2
+   ->  Seq Scan on t2 t1_1
          Filter: (((a % 2) = 0) AND f_leak(b))
-   ->  Seq Scan on t3
+   ->  Seq Scan on t3 t1_2
          Filter: (((a % 2) = 0) AND f_leak(b))
 (10 rows)
 
@@ -1726,20 +1726,20 @@ WHERE t1.a = 3 and t2.a = 3 AND f_leak(t1.b) AND f_leak(t2.b);
 -----------------------------------------------------------------
  Update on t1
    Update on t1
-   Update on t2 t2_1
-   Update on t3
+   Update on t2 t1_1
+   Update on t3 t1_2
    ->  Nested Loop
          ->  Seq Scan on t1
                Filter: ((a = 3) AND ((a % 2) = 0) AND f_leak(b))
          ->  Seq Scan on t2
                Filter: ((a = 3) AND ((a % 2) = 1) AND f_leak(b))
    ->  Nested Loop
-         ->  Seq Scan on t2 t2_1
+         ->  Seq Scan on t2 t1_1
                Filter: ((a = 3) AND ((a % 2) = 0) AND f_leak(b))
          ->  Seq Scan on t2
                Filter: ((a = 3) AND ((a % 2) = 1) AND f_leak(b))
    ->  Nested Loop
-         ->  Seq Scan on t3
+         ->  Seq Scan on t3 t1_2
                Filter: ((a = 3) AND ((a % 2) = 0) AND f_leak(b))
          ->  Seq Scan on t2
                Filter: ((a = 3) AND ((a % 2) = 1) AND f_leak(b))
@@ -1758,9 +1758,9 @@ WHERE t1.a = 3 and t2.a = 3 AND f_leak(t1.b) AND f_leak(t2.b);
          ->  Append
                ->  Seq Scan on t1
                      Filter: ((a = 3) AND ((a % 2) = 0) AND f_leak(b))
-               ->  Seq Scan on t2 t2_1
+               ->  Seq Scan on t2 t1_1
                      Filter: ((a = 3) AND ((a % 2) = 0) AND f_leak(b))
-               ->  Seq Scan on t3
+               ->  Seq Scan on t3 t1_2
                      Filter: ((a = 3) AND ((a % 2) = 0) AND f_leak(b))
 (11 rows)
 
@@ -1884,13 +1884,13 @@ EXPLAIN (COSTS OFF) DELETE FROM t1 WHERE f_leak(b);
 -----------------------------------------------
  Delete on t1
    Delete on t1
-   Delete on t2
-   Delete on t3
+   Delete on t2 t1_1
+   Delete on t3 t1_2
    ->  Seq Scan on t1
          Filter: (((a % 2) = 0) AND f_leak(b))
-   ->  Seq Scan on t2
+   ->  Seq Scan on t2 t1_1
          Filter: (((a % 2) = 0) AND f_leak(b))
-   ->  Seq Scan on t3
+   ->  Seq Scan on t3 t1_2
          Filter: (((a % 2) = 0) AND f_leak(b))
 (10 rows)
 
diff --git a/src/test/regress/expected/select_parallel.out b/src/test/regress/expected/select_parallel.out
index 191ffe7e2380..4d08abc0b8d0 100644
--- a/src/test/regress/expected/select_parallel.out
+++ b/src/test/regress/expected/select_parallel.out
@@ -14,18 +14,18 @@ set max_parallel_workers_per_gather=4;
 -- Parallel Append with partial-subplans
 explain (costs off)
   select round(avg(aa)), sum(aa) from a_star;
-                     QUERY PLAN                      
------------------------------------------------------
+                          QUERY PLAN                          
+--------------------------------------------------------------
  Finalize Aggregate
    ->  Gather
          Workers Planned: 3
          ->  Partial Aggregate
                ->  Parallel Append
-                     ->  Parallel Seq Scan on d_star
-                     ->  Parallel Seq Scan on f_star
-                     ->  Parallel Seq Scan on e_star
-                     ->  Parallel Seq Scan on b_star
-                     ->  Parallel Seq Scan on c_star
+                     ->  Parallel Seq Scan on d_star a_star_3
+                     ->  Parallel Seq Scan on f_star a_star_5
+                     ->  Parallel Seq Scan on e_star a_star_4
+                     ->  Parallel Seq Scan on b_star a_star_1
+                     ->  Parallel Seq Scan on c_star a_star_2
                      ->  Parallel Seq Scan on a_star
 (11 rows)
 
@@ -40,18 +40,18 @@ alter table c_star set (parallel_workers = 0);
 alter table d_star set (parallel_workers = 0);
 explain (costs off)
   select round(avg(aa)), sum(aa) from a_star;
-                     QUERY PLAN                      
------------------------------------------------------
+                          QUERY PLAN                          
+--------------------------------------------------------------
  Finalize Aggregate
    ->  Gather
          Workers Planned: 3
          ->  Partial Aggregate
                ->  Parallel Append
-                     ->  Seq Scan on d_star
-                     ->  Seq Scan on c_star
-                     ->  Parallel Seq Scan on f_star
-                     ->  Parallel Seq Scan on e_star
-                     ->  Parallel Seq Scan on b_star
+                     ->  Seq Scan on d_star a_star_3
+                     ->  Seq Scan on c_star a_star_2
+                     ->  Parallel Seq Scan on f_star a_star_5
+                     ->  Parallel Seq Scan on e_star a_star_4
+                     ->  Parallel Seq Scan on b_star a_star_1
                      ->  Parallel Seq Scan on a_star
 (11 rows)
 
@@ -68,18 +68,18 @@ alter table e_star set (parallel_workers = 0);
 alter table f_star set (parallel_workers = 0);
 explain (costs off)
   select round(avg(aa)), sum(aa) from a_star;
-                 QUERY PLAN                 
---------------------------------------------
+                     QUERY PLAN                      
+-----------------------------------------------------
  Finalize Aggregate
    ->  Gather
          Workers Planned: 3
          ->  Partial Aggregate
                ->  Parallel Append
-                     ->  Seq Scan on d_star
-                     ->  Seq Scan on f_star
-                     ->  Seq Scan on e_star
-                     ->  Seq Scan on b_star
-                     ->  Seq Scan on c_star
+                     ->  Seq Scan on d_star a_star_3
+                     ->  Seq Scan on f_star a_star_5
+                     ->  Seq Scan on e_star a_star_4
+                     ->  Seq Scan on b_star a_star_1
+                     ->  Seq Scan on c_star a_star_2
                      ->  Seq Scan on a_star
 (11 rows)
 
@@ -99,19 +99,19 @@ alter table f_star reset (parallel_workers);
 set enable_parallel_append to off;
 explain (costs off)
   select round(avg(aa)), sum(aa) from a_star;
-                     QUERY PLAN                      
------------------------------------------------------
+                          QUERY PLAN                          
+--------------------------------------------------------------
  Finalize Aggregate
    ->  Gather
          Workers Planned: 1
          ->  Partial Aggregate
                ->  Append
                      ->  Parallel Seq Scan on a_star
-                     ->  Parallel Seq Scan on b_star
-                     ->  Parallel Seq Scan on c_star
-                     ->  Parallel Seq Scan on d_star
-                     ->  Parallel Seq Scan on e_star
-                     ->  Parallel Seq Scan on f_star
+                     ->  Parallel Seq Scan on b_star a_star_1
+                     ->  Parallel Seq Scan on c_star a_star_2
+                     ->  Parallel Seq Scan on d_star a_star_3
+                     ->  Parallel Seq Scan on e_star a_star_4
+                     ->  Parallel Seq Scan on f_star a_star_5
 (11 rows)
 
 select round(avg(aa)), sum(aa) from a_star a4;
diff --git a/src/test/regress/expected/tablesample.out b/src/test/regress/expected/tablesample.out
index d3794140fbfa..a324220820ab 100644
--- a/src/test/regress/expected/tablesample.out
+++ b/src/test/regress/expected/tablesample.out
@@ -200,11 +200,11 @@ explain (costs off)
    ->  Append
          ->  Sample Scan on person
                Sampling: bernoulli ('100'::real)
-         ->  Sample Scan on emp
+         ->  Sample Scan on emp person_1
                Sampling: bernoulli ('100'::real)
-         ->  Sample Scan on student
+         ->  Sample Scan on student person_2
                Sampling: bernoulli ('100'::real)
-         ->  Sample Scan on stud_emp
+         ->  Sample Scan on stud_emp person_3
                Sampling: bernoulli ('100'::real)
 (10 rows)
 
@@ -319,12 +319,12 @@ create table parted_sample_1 partition of parted_sample for values in (1);
 create table parted_sample_2 partition of parted_sample for values in (2);
 explain (costs off)
   select * from parted_sample tablesample bernoulli (100);
-                QUERY PLAN                 
--------------------------------------------
+                      QUERY PLAN                      
+------------------------------------------------------
  Append
-   ->  Sample Scan on parted_sample_1
+   ->  Sample Scan on parted_sample_1 parted_sample
          Sampling: bernoulli ('100'::real)
-   ->  Sample Scan on parted_sample_2
+   ->  Sample Scan on parted_sample_2 parted_sample_1
          Sampling: bernoulli ('100'::real)
 (5 rows)
 
diff --git a/src/test/regress/expected/union.out b/src/test/regress/expected/union.out
index 7189f5bd3d2d..6e72e92d801a 100644
--- a/src/test/regress/expected/union.out
+++ b/src/test/regress/expected/union.out
@@ -751,15 +751,15 @@ explain (costs off)
    UNION ALL
    SELECT ab FROM t2) t
   ORDER BY 1 LIMIT 8;
-                   QUERY PLAN                   
-------------------------------------------------
+                     QUERY PLAN                      
+-----------------------------------------------------
  Limit
    ->  Merge Append
          Sort Key: ((t1.a || t1.b))
          ->  Index Scan using t1_ab_idx on t1
-         ->  Index Scan using t1c_ab_idx on t1c
+         ->  Index Scan using t1c_ab_idx on t1c t1_1
          ->  Index Scan using t2_pkey on t2
-         ->  Index Scan using t2c_pkey on t2c
+         ->  Index Scan using t2c_pkey on t2c t2_1
 (7 rows)
 
   SELECT * FROM
@@ -798,8 +798,8 @@ select event_id
    Sort Key: events.event_id
    ->  Index Scan using events_pkey on events
    ->  Sort
-         Sort Key: events_child.event_id
-         ->  Seq Scan on events_child
+         Sort Key: events_1.event_id
+         ->  Seq Scan on events_child events_1
    ->  Index Scan using other_events_pkey on other_events
 (7 rows)
 
diff --git a/src/test/regress/expected/updatable_views.out b/src/test/regress/expected/updatable_views.out
index 8443c24f18b7..9e1dae60dec1 100644
--- a/src/test/regress/expected/updatable_views.out
+++ b/src/test/regress/expected/updatable_views.out
@@ -1548,28 +1548,28 @@ INSERT INTO other_tbl_parent VALUES (7),(200);
 INSERT INTO other_tbl_child VALUES (8),(100);
 EXPLAIN (costs off)
 UPDATE rw_view1 SET a = a + 1000 FROM other_tbl_parent WHERE a = id;
-                          QUERY PLAN                          
---------------------------------------------------------------
+                               QUERY PLAN                               
+------------------------------------------------------------------------
  Update on base_tbl_parent
    Update on base_tbl_parent
-   Update on base_tbl_child
+   Update on base_tbl_child base_tbl_parent_1
    ->  Hash Join
          Hash Cond: (other_tbl_parent.id = base_tbl_parent.a)
          ->  Append
                ->  Seq Scan on other_tbl_parent
-               ->  Seq Scan on other_tbl_child
+               ->  Seq Scan on other_tbl_child other_tbl_parent_1
          ->  Hash
                ->  Seq Scan on base_tbl_parent
    ->  Merge Join
-         Merge Cond: (base_tbl_child.a = other_tbl_parent.id)
+         Merge Cond: (base_tbl_parent_1.a = other_tbl_parent.id)
          ->  Sort
-               Sort Key: base_tbl_child.a
-               ->  Seq Scan on base_tbl_child
+               Sort Key: base_tbl_parent_1.a
+               ->  Seq Scan on base_tbl_child base_tbl_parent_1
          ->  Sort
                Sort Key: other_tbl_parent.id
                ->  Append
                      ->  Seq Scan on other_tbl_parent
-                     ->  Seq Scan on other_tbl_child
+                     ->  Seq Scan on other_tbl_child other_tbl_parent_1
 (20 rows)
 
 UPDATE rw_view1 SET a = a + 1000 FROM other_tbl_parent WHERE a = id;
@@ -2284,37 +2284,37 @@ UPDATE v1 SET a=100 WHERE snoop(a) AND leakproof(a) AND a < 7 AND a != 6;
 ---------------------------------------------------------------------------------------------------------------------------
  Update on public.t1
    Update on public.t1
-   Update on public.t11
-   Update on public.t12
-   Update on public.t111
+   Update on public.t11 t1_1
+   Update on public.t12 t1_2
+   Update on public.t111 t1_3
    ->  Index Scan using t1_a_idx on public.t1
          Output: 100, t1.b, t1.c, t1.ctid
          Index Cond: ((t1.a > 5) AND (t1.a < 7))
          Filter: ((t1.a <> 6) AND (alternatives: SubPlan 1 or hashed SubPlan 2) AND snoop(t1.a) AND leakproof(t1.a))
          SubPlan 1
            ->  Append
-                 ->  Seq Scan on public.t12 t12_1
+                 ->  Seq Scan on public.t12
+                       Filter: (t12.a = t1.a)
+                 ->  Seq Scan on public.t111 t12_1
                        Filter: (t12_1.a = t1.a)
-                 ->  Seq Scan on public.t111 t111_1
-                       Filter: (t111_1.a = t1.a)
          SubPlan 2
            ->  Append
                  ->  Seq Scan on public.t12 t12_2
                        Output: t12_2.a
-                 ->  Seq Scan on public.t111 t111_2
-                       Output: t111_2.a
-   ->  Index Scan using t11_a_idx on public.t11
-         Output: 100, t11.b, t11.c, t11.d, t11.ctid
-         Index Cond: ((t11.a > 5) AND (t11.a < 7))
-         Filter: ((t11.a <> 6) AND (alternatives: SubPlan 1 or hashed SubPlan 2) AND snoop(t11.a) AND leakproof(t11.a))
-   ->  Index Scan using t12_a_idx on public.t12
-         Output: 100, t12.b, t12.c, t12.e, t12.ctid
-         Index Cond: ((t12.a > 5) AND (t12.a < 7))
-         Filter: ((t12.a <> 6) AND (alternatives: SubPlan 1 or hashed SubPlan 2) AND snoop(t12.a) AND leakproof(t12.a))
-   ->  Index Scan using t111_a_idx on public.t111
-         Output: 100, t111.b, t111.c, t111.d, t111.e, t111.ctid
-         Index Cond: ((t111.a > 5) AND (t111.a < 7))
-         Filter: ((t111.a <> 6) AND (alternatives: SubPlan 1 or hashed SubPlan 2) AND snoop(t111.a) AND leakproof(t111.a))
+                 ->  Seq Scan on public.t111 t12_3
+                       Output: t12_3.a
+   ->  Index Scan using t11_a_idx on public.t11 t1_1
+         Output: 100, t1_1.b, t1_1.c, t1_1.d, t1_1.ctid
+         Index Cond: ((t1_1.a > 5) AND (t1_1.a < 7))
+         Filter: ((t1_1.a <> 6) AND (alternatives: SubPlan 1 or hashed SubPlan 2) AND snoop(t1_1.a) AND leakproof(t1_1.a))
+   ->  Index Scan using t12_a_idx on public.t12 t1_2
+         Output: 100, t1_2.b, t1_2.c, t1_2.e, t1_2.ctid
+         Index Cond: ((t1_2.a > 5) AND (t1_2.a < 7))
+         Filter: ((t1_2.a <> 6) AND (alternatives: SubPlan 1 or hashed SubPlan 2) AND snoop(t1_2.a) AND leakproof(t1_2.a))
+   ->  Index Scan using t111_a_idx on public.t111 t1_3
+         Output: 100, t1_3.b, t1_3.c, t1_3.d, t1_3.e, t1_3.ctid
+         Index Cond: ((t1_3.a > 5) AND (t1_3.a < 7))
+         Filter: ((t1_3.a <> 6) AND (alternatives: SubPlan 1 or hashed SubPlan 2) AND snoop(t1_3.a) AND leakproof(t1_3.a))
 (33 rows)
 
 UPDATE v1 SET a=100 WHERE snoop(a) AND leakproof(a) AND a < 7 AND a != 6;
@@ -2334,37 +2334,37 @@ UPDATE v1 SET a=a+1 WHERE snoop(a) AND leakproof(a) AND a = 8;
 ---------------------------------------------------------------------------------------------------------
  Update on public.t1
    Update on public.t1
-   Update on public.t11
-   Update on public.t12
-   Update on public.t111
+   Update on public.t11 t1_1
+   Update on public.t12 t1_2
+   Update on public.t111 t1_3
    ->  Index Scan using t1_a_idx on public.t1
          Output: (t1.a + 1), t1.b, t1.c, t1.ctid
          Index Cond: ((t1.a > 5) AND (t1.a = 8))
          Filter: ((alternatives: SubPlan 1 or hashed SubPlan 2) AND snoop(t1.a) AND leakproof(t1.a))
          SubPlan 1
            ->  Append
-                 ->  Seq Scan on public.t12 t12_1
+                 ->  Seq Scan on public.t12
+                       Filter: (t12.a = t1.a)
+                 ->  Seq Scan on public.t111 t12_1
                        Filter: (t12_1.a = t1.a)
-                 ->  Seq Scan on public.t111 t111_1
-                       Filter: (t111_1.a = t1.a)
          SubPlan 2
            ->  Append
                  ->  Seq Scan on public.t12 t12_2
                        Output: t12_2.a
-                 ->  Seq Scan on public.t111 t111_2
-                       Output: t111_2.a
-   ->  Index Scan using t11_a_idx on public.t11
-         Output: (t11.a + 1), t11.b, t11.c, t11.d, t11.ctid
-         Index Cond: ((t11.a > 5) AND (t11.a = 8))
-         Filter: ((alternatives: SubPlan 1 or hashed SubPlan 2) AND snoop(t11.a) AND leakproof(t11.a))
-   ->  Index Scan using t12_a_idx on public.t12
-         Output: (t12.a + 1), t12.b, t12.c, t12.e, t12.ctid
-         Index Cond: ((t12.a > 5) AND (t12.a = 8))
-         Filter: ((alternatives: SubPlan 1 or hashed SubPlan 2) AND snoop(t12.a) AND leakproof(t12.a))
-   ->  Index Scan using t111_a_idx on public.t111
-         Output: (t111.a + 1), t111.b, t111.c, t111.d, t111.e, t111.ctid
-         Index Cond: ((t111.a > 5) AND (t111.a = 8))
-         Filter: ((alternatives: SubPlan 1 or hashed SubPlan 2) AND snoop(t111.a) AND leakproof(t111.a))
+                 ->  Seq Scan on public.t111 t12_3
+                       Output: t12_3.a
+   ->  Index Scan using t11_a_idx on public.t11 t1_1
+         Output: (t1_1.a + 1), t1_1.b, t1_1.c, t1_1.d, t1_1.ctid
+         Index Cond: ((t1_1.a > 5) AND (t1_1.a = 8))
+         Filter: ((alternatives: SubPlan 1 or hashed SubPlan 2) AND snoop(t1_1.a) AND leakproof(t1_1.a))
+   ->  Index Scan using t12_a_idx on public.t12 t1_2
+         Output: (t1_2.a + 1), t1_2.b, t1_2.c, t1_2.e, t1_2.ctid
+         Index Cond: ((t1_2.a > 5) AND (t1_2.a = 8))
+         Filter: ((alternatives: SubPlan 1 or hashed SubPlan 2) AND snoop(t1_2.a) AND leakproof(t1_2.a))
+   ->  Index Scan using t111_a_idx on public.t111 t1_3
+         Output: (t1_3.a + 1), t1_3.b, t1_3.c, t1_3.d, t1_3.e, t1_3.ctid
+         Index Cond: ((t1_3.a > 5) AND (t1_3.a = 8))
+         Filter: ((alternatives: SubPlan 1 or hashed SubPlan 2) AND snoop(t1_3.a) AND leakproof(t1_3.a))
 (33 rows)
 
 UPDATE v1 SET a=a+1 WHERE snoop(a) AND leakproof(a) AND a = 8;
diff --git a/src/test/regress/expected/update.out b/src/test/regress/expected/update.out
index a24ecd61df8f..b7f90de52b13 100644
--- a/src/test/regress/expected/update.out
+++ b/src/test/regress/expected/update.out
@@ -310,29 +310,29 @@ ALTER TABLE part_b_10_b_20 ATTACH PARTITION part_c_1_100 FOR VALUES FROM (1) TO
 
 -- The order of subplans should be in bound order
 EXPLAIN (costs off) UPDATE range_parted set c = c - 50 WHERE c > 97;
-             QUERY PLAN              
--------------------------------------
+                   QUERY PLAN                    
+-------------------------------------------------
  Update on range_parted
-   Update on part_a_1_a_10
-   Update on part_a_10_a_20
-   Update on part_b_1_b_10
-   Update on part_c_1_100
-   Update on part_d_1_15
-   Update on part_d_15_20
-   Update on part_b_20_b_30
-   ->  Seq Scan on part_a_1_a_10
+   Update on part_a_1_a_10 range_parted_1
+   Update on part_a_10_a_20 range_parted_2
+   Update on part_b_1_b_10 range_parted_3
+   Update on part_c_1_100 range_parted_4
+   Update on part_d_1_15 range_parted_5
+   Update on part_d_15_20 range_parted_6
+   Update on part_b_20_b_30 range_parted_7
+   ->  Seq Scan on part_a_1_a_10 range_parted_1
          Filter: (c > '97'::numeric)
-   ->  Seq Scan on part_a_10_a_20
+   ->  Seq Scan on part_a_10_a_20 range_parted_2
          Filter: (c > '97'::numeric)
-   ->  Seq Scan on part_b_1_b_10
+   ->  Seq Scan on part_b_1_b_10 range_parted_3
          Filter: (c > '97'::numeric)
-   ->  Seq Scan on part_c_1_100
+   ->  Seq Scan on part_c_1_100 range_parted_4
          Filter: (c > '97'::numeric)
-   ->  Seq Scan on part_d_1_15
+   ->  Seq Scan on part_d_1_15 range_parted_5
          Filter: (c > '97'::numeric)
-   ->  Seq Scan on part_d_15_20
+   ->  Seq Scan on part_d_15_20 range_parted_6
          Filter: (c > '97'::numeric)
-   ->  Seq Scan on part_b_20_b_30
+   ->  Seq Scan on part_b_20_b_30 range_parted_7
          Filter: (c > '97'::numeric)
 (22 rows)
 
diff --git a/src/test/regress/expected/with.out b/src/test/regress/expected/with.out
index 2a2085556bb2..67eaeb4f3ed4 100644
--- a/src/test/regress/expected/with.out
+++ b/src/test/regress/expected/with.out
@@ -2185,9 +2185,9 @@ DELETE FROM a USING wcte WHERE aa = q2;
 ----------------------------------------------------
  Delete on public.a
    Delete on public.a
-   Delete on public.b
-   Delete on public.c
-   Delete on public.d
+   Delete on public.b a_1
+   Delete on public.c a_2
+   Delete on public.d a_3
    CTE wcte
      ->  Insert on public.int8_tbl
            Output: int8_tbl.q2
@@ -2201,24 +2201,24 @@ DELETE FROM a USING wcte WHERE aa = q2;
          ->  CTE Scan on wcte
                Output: wcte.*, wcte.q2
    ->  Nested Loop
-         Output: b.ctid, wcte.*
-         Join Filter: (b.aa = wcte.q2)
-         ->  Seq Scan on public.b
-               Output: b.ctid, b.aa
+         Output: a_1.ctid, wcte.*
+         Join Filter: (a_1.aa = wcte.q2)
+         ->  Seq Scan on public.b a_1
+               Output: a_1.ctid, a_1.aa
          ->  CTE Scan on wcte
                Output: wcte.*, wcte.q2
    ->  Nested Loop
-         Output: c.ctid, wcte.*
-         Join Filter: (c.aa = wcte.q2)
-         ->  Seq Scan on public.c
-               Output: c.ctid, c.aa
+         Output: a_2.ctid, wcte.*
+         Join Filter: (a_2.aa = wcte.q2)
+         ->  Seq Scan on public.c a_2
+               Output: a_2.ctid, a_2.aa
          ->  CTE Scan on wcte
                Output: wcte.*, wcte.q2
    ->  Nested Loop
-         Output: d.ctid, wcte.*
-         Join Filter: (d.aa = wcte.q2)
-         ->  Seq Scan on public.d
-               Output: d.ctid, d.aa
+         Output: a_3.ctid, wcte.*
+         Join Filter: (a_3.aa = wcte.q2)
+         ->  Seq Scan on public.d a_3
+               Output: a_3.ctid, a_3.aa
          ->  CTE Scan on wcte
                Output: wcte.*, wcte.q2
 (38 rows)
diff --git a/src/test/regress/sql/partition_prune.sql b/src/test/regress/sql/partition_prune.sql
index a5900e559c95..41f0b6f11027 100644
--- a/src/test/regress/sql/partition_prune.sql
+++ b/src/test/regress/sql/partition_prune.sql
@@ -202,8 +202,13 @@ CREATE TABLE part (a INT, b INT) PARTITION BY LIST (a);
 CREATE TABLE part_p1 PARTITION OF part FOR VALUES IN (-2,-1,0,1,2);
 CREATE TABLE part_p2 PARTITION OF part DEFAULT PARTITION BY RANGE(a);
 CREATE TABLE part_p2_p1 PARTITION OF part_p2 DEFAULT;
+CREATE TABLE part_rev (b INT, c INT, a INT);
+ALTER TABLE part ATTACH PARTITION part_rev FOR VALUES IN (3);  -- fail
+ALTER TABLE part_rev DROP COLUMN c;
+ALTER TABLE part ATTACH PARTITION part_rev FOR VALUES IN (3);  -- now it's ok
 INSERT INTO part VALUES (-1,-1), (1,1), (2,NULL), (NULL,-2),(NULL,NULL);
 EXPLAIN (COSTS OFF) SELECT tableoid::regclass as part, a, b FROM part WHERE a IS NULL ORDER BY 1, 2, 3;
+EXPLAIN (VERBOSE, COSTS OFF) SELECT * FROM part p(x) ORDER BY x;
 
 --
 -- some more cases
