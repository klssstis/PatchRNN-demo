From 148266fa354a47543f6c0325cd1ea900ead4aac6 Mon Sep 17 00:00:00 2001
From: Michael Paquier <michael@paquier.xyz>
Date: Fri, 19 Apr 2019 16:57:40 +0900
Subject: [PATCH] Fix collection of typos and grammar mistakes in docs and
 comments

Author: Justin Pryzby
Discussion: https://postgr.es/m/20190330224333.GQ5815@telsasoft.com
---
 doc/src/sgml/ecpg.sgml                  | 2 +-
 doc/src/sgml/ref/create_index.sgml      | 2 +-
 src/backend/jit/llvm/llvmjit_inline.cpp | 2 +-
 src/backend/optimizer/plan/planner.c    | 2 +-
 src/backend/utils/hash/dynahash.c       | 2 +-
 src/interfaces/libpq/fe-auth.c          | 2 +-
 6 files changed, 6 insertions(+), 6 deletions(-)

diff --git a/doc/src/sgml/ecpg.sgml b/doc/src/sgml/ecpg.sgml
index 1bd7cf4ebd6a..6641eee440c6 100644
--- a/doc/src/sgml/ecpg.sgml
+++ b/doc/src/sgml/ecpg.sgml
@@ -662,7 +662,7 @@ EXEC SQL DEALLOCATE PREPARE <replaceable>name</replaceable>;
    not really useful in real applications.  This section explains in
    detail how you can pass data between your C program and the
    embedded SQL statements using a simple mechanism called
-   <firstterm>host variables</firstterm>. In an embedded SQL program  we
+   <firstterm>host variables</firstterm>. In an embedded SQL program we
    consider the SQL statements to be <firstterm>guests</firstterm> in the C
    program code which is the <firstterm>host language</firstterm>. Therefore
    the variables of the C program are called <firstterm>host
diff --git a/doc/src/sgml/ref/create_index.sgml b/doc/src/sgml/ref/create_index.sgml
index 521e32b197c1..30bb38bf62ec 100644
--- a/doc/src/sgml/ref/create_index.sgml
+++ b/doc/src/sgml/ref/create_index.sgml
@@ -181,7 +181,7 @@ CREATE [ UNIQUE ] INDEX [ CONCURRENTLY ] [ [ IF NOT EXISTS ] <replaceable class=
        </para>
 
        <para>
-        Currently, the B-tree and the GiST index access methods supports this
+        Currently, the B-tree and the GiST index access methods support this
         feature.  In B-tree and the GiST indexes, the values of columns listed
         in the <literal>INCLUDE</literal> clause are included in leaf tuples
         which correspond to heap tuples, but are not included in upper-level
diff --git a/src/backend/jit/llvm/llvmjit_inline.cpp b/src/backend/jit/llvm/llvmjit_inline.cpp
index 96fc68a3561a..07b5fc7b38ed 100644
--- a/src/backend/jit/llvm/llvmjit_inline.cpp
+++ b/src/backend/jit/llvm/llvmjit_inline.cpp
@@ -9,7 +9,7 @@
  * for an external function is found - not guaranteed! - the index will then
  * be used to judge their instruction count / inline worthiness. After doing
  * so for all external functions, all the referenced functions (and
- * prerequisites) will be imorted.
+ * prerequisites) will be imported.
  *
  * Copyright (c) 2016-2019, PostgreSQL Global Development Group
  *
diff --git a/src/backend/optimizer/plan/planner.c b/src/backend/optimizer/plan/planner.c
index 5ed691c2e32d..0a6710c73b92 100644
--- a/src/backend/optimizer/plan/planner.c
+++ b/src/backend/optimizer/plan/planner.c
@@ -118,7 +118,7 @@ typedef struct
 
 /*
  * Temporary structure for use during WindowClause reordering in order to be
- * be able to sort WindowClauses on partitioning/ordering prefix.
+ * able to sort WindowClauses on partitioning/ordering prefix.
  */
 typedef struct
 {
diff --git a/src/backend/utils/hash/dynahash.c b/src/backend/utils/hash/dynahash.c
index 9dc2a551c0f0..0dfbec8e3ecf 100644
--- a/src/backend/utils/hash/dynahash.c
+++ b/src/backend/utils/hash/dynahash.c
@@ -817,7 +817,7 @@ hash_destroy(HTAB *hashp)
 	{
 		/* allocation method must be one we know how to free, too */
 		Assert(hashp->alloc == DynaHashAlloc);
-		/* so this hashtable must have it's own context */
+		/* so this hashtable must have its own context */
 		Assert(hashp->hcxt != NULL);
 
 		hash_stats("destroy", hashp);
diff --git a/src/interfaces/libpq/fe-auth.c b/src/interfaces/libpq/fe-auth.c
index 624e02bcaae0..bb04e27e2fed 100644
--- a/src/interfaces/libpq/fe-auth.c
+++ b/src/interfaces/libpq/fe-auth.c
@@ -879,7 +879,7 @@ pg_fe_sendauth(AuthRequest areq, int payloadlen, PGconn *conn)
 		case AUTH_REQ_SSPI:
 
 			/*
-			 * SSPI has it's own startup message so libpq can decide which
+			 * SSPI has its own startup message so libpq can decide which
 			 * method to use. Indicate to pg_SSPI_startup that we want SSPI
 			 * negotiation instead of Kerberos.
 			 */
