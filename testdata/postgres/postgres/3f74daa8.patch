From 3f74daa8dfc634132ff7270212c57da5e316b001 Mon Sep 17 00:00:00 2001
From: Alexander Korotkov <akorotkov@postgresql.org>
Date: Mon, 14 Feb 2022 03:26:55 +0300
Subject: [PATCH] Fix memory leak in IndexScan node with reordering

Fix ExecReScanIndexScan() to free the referenced tuples while emptying the
priority queue.  Backpatch to all supported versions.

Discussion: https://postgr.es/m/CAHqSB9gECMENBQmpbv5rvmT3HTaORmMK3Ukg73DsX5H7EJV7jw%40mail.gmail.com
Author: Aliaksandr Kalenik
Reviewed-by: Tom Lane, Alexander Korotkov
Backpatch-through: 10
---
 src/backend/executor/nodeIndexscan.c       |  6 ++++-
 src/test/regress/expected/create_index.out | 27 ++++++++++++++++++++++
 src/test/regress/sql/create_index.sql      |  4 ++++
 3 files changed, 36 insertions(+), 1 deletion(-)

diff --git a/src/backend/executor/nodeIndexscan.c b/src/backend/executor/nodeIndexscan.c
index a91f135be7a9..90b2699a96be 100644
--- a/src/backend/executor/nodeIndexscan.c
+++ b/src/backend/executor/nodeIndexscan.c
@@ -574,8 +574,12 @@ ExecReScanIndexScan(IndexScanState *node)
 	/* flush the reorder queue */
 	if (node->iss_ReorderQueue)
 	{
+		HeapTuple	tuple;
 		while (!pairingheap_is_empty(node->iss_ReorderQueue))
-			reorderqueue_pop(node);
+		{
+			tuple = reorderqueue_pop(node);
+			heap_freetuple(tuple);
+		}
 	}
 
 	/* reset index scan */
diff --git a/src/test/regress/expected/create_index.out b/src/test/regress/expected/create_index.out
index 1cc475abb064..d55aec3a1d0f 100644
--- a/src/test/regress/expected/create_index.out
+++ b/src/test/regress/expected/create_index.out
@@ -588,6 +588,33 @@ SELECT circle_center(f1), round(radius(f1)) as radius FROM gcircle_tbl ORDER BY
  (751.5,2655)   |     20
 (10 rows)
 
+EXPLAIN (COSTS OFF)
+SELECT point(x,x), (SELECT f1 FROM gpolygon_tbl ORDER BY f1 <-> point(x,x) LIMIT 1) as c FROM generate_series(0,10,1) x;
+                                         QUERY PLAN                                         
+--------------------------------------------------------------------------------------------
+ Function Scan on generate_series x
+   SubPlan 1
+     ->  Limit
+           ->  Index Scan using ggpolygonind on gpolygon_tbl
+                 Order By: (f1 <-> point((x.x)::double precision, (x.x)::double precision))
+(5 rows)
+
+SELECT point(x,x), (SELECT f1 FROM gpolygon_tbl ORDER BY f1 <-> point(x,x) LIMIT 1) as c FROM generate_series(0,10,1) x;
+  point  |                     c                     
+---------+-------------------------------------------
+ (0,0)   | ((240,359),(240,455),(337,455),(337,359))
+ (1,1)   | ((240,359),(240,455),(337,455),(337,359))
+ (2,2)   | ((240,359),(240,455),(337,455),(337,359))
+ (3,3)   | ((240,359),(240,455),(337,455),(337,359))
+ (4,4)   | ((240,359),(240,455),(337,455),(337,359))
+ (5,5)   | ((240,359),(240,455),(337,455),(337,359))
+ (6,6)   | ((240,359),(240,455),(337,455),(337,359))
+ (7,7)   | ((240,359),(240,455),(337,455),(337,359))
+ (8,8)   | ((240,359),(240,455),(337,455),(337,359))
+ (9,9)   | ((240,359),(240,455),(337,455),(337,359))
+ (10,10) | ((240,359),(240,455),(337,455),(337,359))
+(11 rows)
+
 -- Now check the results from bitmap indexscan
 SET enable_seqscan = OFF;
 SET enable_indexscan = OFF;
diff --git a/src/test/regress/sql/create_index.sql b/src/test/regress/sql/create_index.sql
index a06c98074b88..d8fded3d930a 100644
--- a/src/test/regress/sql/create_index.sql
+++ b/src/test/regress/sql/create_index.sql
@@ -239,6 +239,10 @@ EXPLAIN (COSTS OFF)
 SELECT circle_center(f1), round(radius(f1)) as radius FROM gcircle_tbl ORDER BY f1 <-> '(200,300)'::point LIMIT 10;
 SELECT circle_center(f1), round(radius(f1)) as radius FROM gcircle_tbl ORDER BY f1 <-> '(200,300)'::point LIMIT 10;
 
+EXPLAIN (COSTS OFF)
+SELECT point(x,x), (SELECT f1 FROM gpolygon_tbl ORDER BY f1 <-> point(x,x) LIMIT 1) as c FROM generate_series(0,10,1) x;
+SELECT point(x,x), (SELECT f1 FROM gpolygon_tbl ORDER BY f1 <-> point(x,x) LIMIT 1) as c FROM generate_series(0,10,1) x;
+
 -- Now check the results from bitmap indexscan
 SET enable_seqscan = OFF;
 SET enable_indexscan = OFF;
