From 8ea7963fc741b6f403a544d56ad0ecf78e5237b1 Mon Sep 17 00:00:00 2001
From: Andres Freund <andres@anarazel.de>
Date: Wed, 6 Apr 2022 14:09:18 -0700
Subject: [PATCH] pgstat: add pgstat_copy_relation_stats().

Until now index_concurrently_swap() directly modified pgstat internal
datastructures. That will break with the introduction of shared memory
statistics and seems off architecturally.

This is done separately from the - quite large - shared memory statistics
patch to make review easier.

Author: Andres Freund <andres@anarazel.de>
Author: Kyotaro Horiguchi <horikyota.ntt@gmail.com>
Reviewed-By: Kyotaro Horiguchi <horikyota.ntt@gmail.com>
Discussion: https://postgr.es/m/20220303021600.hs34ghqcw6zcokdh@alap3.anarazel.de
---
 src/backend/catalog/index.c                  | 26 ++--------------
 src/backend/utils/activity/pgstat_relation.c | 32 ++++++++++++++++++++
 src/include/pgstat.h                         |  2 ++
 3 files changed, 36 insertions(+), 24 deletions(-)

diff --git a/src/backend/catalog/index.c b/src/backend/catalog/index.c
index 55800c947867..fd389c28d836 100644
--- a/src/backend/catalog/index.c
+++ b/src/backend/catalog/index.c
@@ -1734,30 +1734,8 @@ index_concurrently_swap(Oid newIndexId, Oid oldIndexId, const char *oldName)
 	changeDependenciesOf(RelationRelationId, oldIndexId, newIndexId);
 	changeDependenciesOn(RelationRelationId, oldIndexId, newIndexId);
 
-	/*
-	 * Copy over statistics from old to new index
-	 */
-	{
-		PgStat_StatTabEntry *tabentry;
-
-		tabentry = pgstat_fetch_stat_tabentry(oldIndexId);
-		if (tabentry)
-		{
-			if (pgstat_relation_should_count(newClassRel))
-			{
-				newClassRel->pgstat_info->t_counts.t_numscans = tabentry->numscans;
-				newClassRel->pgstat_info->t_counts.t_tuples_returned = tabentry->tuples_returned;
-				newClassRel->pgstat_info->t_counts.t_tuples_fetched = tabentry->tuples_fetched;
-				newClassRel->pgstat_info->t_counts.t_blocks_fetched = tabentry->blocks_fetched;
-				newClassRel->pgstat_info->t_counts.t_blocks_hit = tabentry->blocks_hit;
-
-				/*
-				 * The data will be sent by the next pgstat_report_stat()
-				 * call.
-				 */
-			}
-		}
-	}
+	/* copy over statistics from old to new index */
+	pgstat_copy_relation_stats(newClassRel, oldClassRel);
 
 	/* Copy data of pg_statistic from the old index to the new one */
 	CopyStatistics(oldIndexId, newIndexId);
diff --git a/src/backend/utils/activity/pgstat_relation.c b/src/backend/utils/activity/pgstat_relation.c
index a78b8d2450f7..4f97d2f1d9c4 100644
--- a/src/backend/utils/activity/pgstat_relation.c
+++ b/src/backend/utils/activity/pgstat_relation.c
@@ -95,6 +95,38 @@ bool		have_relation_stats;
 static HTAB *pgStatTabHash = NULL;
 
 
+/*
+ * Copy stats between relations. This is used for things like REINDEX
+ * CONCURRENTLY.
+ */
+void
+pgstat_copy_relation_stats(Relation dst, Relation src)
+{
+	PgStat_StatTabEntry *srcstats;
+
+	srcstats = pgstat_fetch_stat_tabentry(RelationGetRelid(src));
+
+	if (!srcstats)
+		return;
+
+	if (pgstat_relation_should_count(dst))
+	{
+		/*
+		 * XXX: temporarily this does not actually quite do what the name
+		 * says, and just copy index related fields. A subsequent commit will
+		 * do more.
+		 */
+
+		dst->pgstat_info->t_counts.t_numscans = srcstats->numscans;
+		dst->pgstat_info->t_counts.t_tuples_returned = srcstats->tuples_returned;
+		dst->pgstat_info->t_counts.t_tuples_fetched = srcstats->tuples_fetched;
+		dst->pgstat_info->t_counts.t_blocks_fetched = srcstats->blocks_fetched;
+		dst->pgstat_info->t_counts.t_blocks_hit = srcstats->blocks_hit;
+
+		/* the data will be sent by the next pgstat_report_stat() call */
+	}
+}
+
 /*
  * Initialize a relcache entry to count access statistics.
  * Called whenever a relation is opened.
diff --git a/src/include/pgstat.h b/src/include/pgstat.h
index aaab2f973b3e..ed141f2d2fd7 100644
--- a/src/include/pgstat.h
+++ b/src/include/pgstat.h
@@ -1053,6 +1053,8 @@ extern PgStat_BackendFunctionEntry *find_funcstat_entry(Oid func_id);
  * Functions in pgstat_relation.c
  */
 
+extern void pgstat_copy_relation_stats(Relation dstrel, Relation srcrel);
+
 extern void pgstat_relation_init(Relation rel);
 
 extern void pgstat_report_vacuum(Oid tableoid, bool shared,
