From 4483b2cf29bfe8091b721756928ccbe31c5c8e14 Mon Sep 17 00:00:00 2001
From: Tom Lane <tgl@sss.pgh.pa.us>
Date: Sat, 15 Jan 2022 15:54:10 -0500
Subject: [PATCH] Remove standby_schedule and associated test files.

Since this test schedule is not run by default, it's next door to
unused.  Moreover, its test coverage is very thin, and what there is
is just about entirely superseded by the src/test/recovery tests.
Let's drop it instead of carrying obsolete tests.

Discussion: https://postgr.es/m/3911012.1641246643@sss.pgh.pa.us
---
 doc/src/sgml/regress.sgml                     |  46 ----
 src/test/regress/GNUmakefile                  |   3 -
 .../regress/expected/hs_standby_allowed.out   | 218 ------------------
 .../regress/expected/hs_standby_check.out     |  20 --
 .../expected/hs_standby_disallowed.out        | 133 -----------
 .../regress/expected/hs_standby_functions.out |  40 ----
 src/test/regress/sql/hs_primary_extremes.sql  |  73 ------
 src/test/regress/sql/hs_primary_setup.sql     |  25 --
 src/test/regress/sql/hs_standby_allowed.sql   | 125 ----------
 src/test/regress/sql/hs_standby_check.sql     |  16 --
 .../regress/sql/hs_standby_disallowed.sql     | 103 ---------
 src/test/regress/sql/hs_standby_functions.sql |  24 --
 src/test/regress/standby_schedule             |  21 --
 13 files changed, 847 deletions(-)
 delete mode 100644 src/test/regress/expected/hs_standby_allowed.out
 delete mode 100644 src/test/regress/expected/hs_standby_check.out
 delete mode 100644 src/test/regress/expected/hs_standby_disallowed.out
 delete mode 100644 src/test/regress/expected/hs_standby_functions.out
 delete mode 100644 src/test/regress/sql/hs_primary_extremes.sql
 delete mode 100644 src/test/regress/sql/hs_primary_setup.sql
 delete mode 100644 src/test/regress/sql/hs_standby_allowed.sql
 delete mode 100644 src/test/regress/sql/hs_standby_check.sql
 delete mode 100644 src/test/regress/sql/hs_standby_disallowed.sql
 delete mode 100644 src/test/regress/sql/hs_standby_functions.sql
 delete mode 100644 src/test/regress/standby_schedule

diff --git a/doc/src/sgml/regress.sgml b/doc/src/sgml/regress.sgml
index 724ef566e76d..8cf10085d358 100644
--- a/doc/src/sgml/regress.sgml
+++ b/doc/src/sgml/regress.sgml
@@ -391,52 +391,6 @@ make check EXTRA_TESTS=numeric_big
 </screen>
    </para>
   </sect2>
-
-  <sect2>
-   <title>Testing Hot Standby</title>
-
-  <para>
-   The source distribution also contains regression tests for the static
-   behavior of Hot Standby. These tests require a running primary server
-   and a running standby server that is accepting new WAL changes from the
-   primary (using either file-based log shipping or streaming replication).
-   Those servers are not automatically created for you, nor is replication
-   setup documented here. Please check the various sections of the
-   documentation devoted to the required commands and related issues.
-  </para>
-
-  <para>
-   To run the Hot Standby tests, first create a database
-   called <literal>regression</literal> on the primary:
-<screen>
-psql -h primary -c "CREATE DATABASE regression"
-</screen>
-   Next, run the preparatory script
-   <filename>src/test/regress/sql/hs_primary_setup.sql</filename>
-   on the primary in the regression database, for example:
-<screen>
-psql -h primary -f src/test/regress/sql/hs_primary_setup.sql regression
-</screen>
-   Allow these changes to propagate to the standby.
-  </para>
-
-  <para>
-   Now arrange for the default database connection to be to the standby
-   server under test (for example, by setting the <envar>PGHOST</envar> and
-   <envar>PGPORT</envar> environment variables).
-   Finally, run <literal>make standbycheck</literal> in the regression directory:
-<screen>
-cd src/test/regress
-make standbycheck
-</screen>
-  </para>
-
-  <para>
-   Some extreme behaviors can also be generated on the primary using the
-   script <filename>src/test/regress/sql/hs_primary_extremes.sql</filename>
-   to allow the behavior of the standby to be tested.
-  </para>
-  </sect2>
   </sect1>
 
   <sect1 id="regress-evaluation">
diff --git a/src/test/regress/GNUmakefile b/src/test/regress/GNUmakefile
index 0d91dd31578c..b40361c84c30 100644
--- a/src/test/regress/GNUmakefile
+++ b/src/test/regress/GNUmakefile
@@ -130,9 +130,6 @@ installcheck-parallel: all
 installcheck-tests: all
 	$(pg_regress_installcheck) $(REGRESS_OPTS) $(TESTS) $(EXTRA_TESTS)
 
-standbycheck: all
-	$(pg_regress_installcheck) $(REGRESS_OPTS) --schedule=$(srcdir)/standby_schedule --use-existing
-
 # old interfaces follow...
 
 runcheck: check
diff --git a/src/test/regress/expected/hs_standby_allowed.out b/src/test/regress/expected/hs_standby_allowed.out
deleted file mode 100644
index 00b8faf9eb66..000000000000
--- a/src/test/regress/expected/hs_standby_allowed.out
+++ /dev/null
@@ -1,218 +0,0 @@
---
--- Hot Standby tests
---
--- hs_standby_allowed.sql
---
--- SELECT
-select count(*) as should_be_1 from hs1;
- should_be_1 
--------------
-           1
-(1 row)
-
-select count(*) as should_be_2 from hs2;
- should_be_2 
--------------
-           2
-(1 row)
-
-select count(*) as should_be_3 from hs3;
- should_be_3 
--------------
-           3
-(1 row)
-
-COPY hs1 TO '/tmp/copy_test';
-\! cat /tmp/copy_test
-1
--- Access sequence directly
-select is_called from hsseq;
- is_called 
------------
- f
-(1 row)
-
--- Transactions
-begin;
-select count(*)  as should_be_1 from hs1;
- should_be_1 
--------------
-           1
-(1 row)
-
-end;
-begin transaction read only;
-select count(*)  as should_be_1 from hs1;
- should_be_1 
--------------
-           1
-(1 row)
-
-end;
-begin transaction isolation level repeatable read;
-select count(*) as should_be_1 from hs1;
- should_be_1 
--------------
-           1
-(1 row)
-
-select count(*) as should_be_1 from hs1;
- should_be_1 
--------------
-           1
-(1 row)
-
-select count(*) as should_be_1 from hs1;
- should_be_1 
--------------
-           1
-(1 row)
-
-commit;
-begin;
-select count(*) as should_be_1 from hs1;
- should_be_1 
--------------
-           1
-(1 row)
-
-commit;
-begin;
-select count(*) as should_be_1 from hs1;
- should_be_1 
--------------
-           1
-(1 row)
-
-abort;
-start transaction;
-select count(*) as should_be_1 from hs1;
- should_be_1 
--------------
-           1
-(1 row)
-
-commit;
-begin;
-select count(*) as should_be_1 from hs1;
- should_be_1 
--------------
-           1
-(1 row)
-
-rollback;
-begin;
-select count(*) as should_be_1 from hs1;
- should_be_1 
--------------
-           1
-(1 row)
-
-savepoint s;
-select count(*) as should_be_2 from hs2;
- should_be_2 
--------------
-           2
-(1 row)
-
-commit;
-begin;
-select count(*) as should_be_1 from hs1;
- should_be_1 
--------------
-           1
-(1 row)
-
-savepoint s;
-select count(*) as should_be_2 from hs2;
- should_be_2 
--------------
-           2
-(1 row)
-
-release savepoint s;
-select count(*) as should_be_2 from hs2;
- should_be_2 
--------------
-           2
-(1 row)
-
-savepoint s;
-select count(*) as should_be_3 from hs3;
- should_be_3 
--------------
-           3
-(1 row)
-
-rollback to savepoint s;
-select count(*) as should_be_2 from hs2;
- should_be_2 
--------------
-           2
-(1 row)
-
-commit;
--- SET parameters
--- has no effect on read only transactions, but we can still set it
-set synchronous_commit = on;
-show synchronous_commit;
- synchronous_commit 
---------------------
- on
-(1 row)
-
-reset synchronous_commit;
-discard temp;
-discard all;
--- CURSOR commands
-BEGIN;
-DECLARE hsc CURSOR FOR select * from hs3;
-FETCH next from hsc;
- col1 
-------
-  113
-(1 row)
-
-fetch first from hsc;
- col1 
-------
-  113
-(1 row)
-
-fetch last from hsc;
- col1 
-------
-  115
-(1 row)
-
-fetch 1 from hsc;
- col1 
-------
-(0 rows)
-
-CLOSE hsc;
-COMMIT;
--- Prepared plans
-PREPARE hsp AS select count(*) from hs1;
-PREPARE hsp_noexec (integer) AS insert into hs1 values ($1);
-EXECUTE hsp;
- count 
--------
-     1
-(1 row)
-
-DEALLOCATE hsp;
--- LOCK
-BEGIN;
-LOCK hs1 IN ACCESS SHARE MODE;
-LOCK hs1 IN ROW SHARE MODE;
-LOCK hs1 IN ROW EXCLUSIVE MODE;
-COMMIT;
--- UNLISTEN
-UNLISTEN a;
-UNLISTEN *;
--- LOAD
--- should work, easier if there is no test for that...
--- ALLOWED COMMANDS
-CHECKPOINT;
-discard all;
diff --git a/src/test/regress/expected/hs_standby_check.out b/src/test/regress/expected/hs_standby_check.out
deleted file mode 100644
index df885ea9e070..000000000000
--- a/src/test/regress/expected/hs_standby_check.out
+++ /dev/null
@@ -1,20 +0,0 @@
---
--- Hot Standby tests
---
--- hs_standby_check.sql
---
---
--- If the query below returns false then all other tests will fail after it.
---
-select case pg_is_in_recovery() when false then
-	'These tests are intended only for execution on a standby server that is reading ' ||
-	'WAL from a server upon which the regression database is already created and into ' ||
-	'which src/test/regress/sql/hs_primary_setup.sql has been run'
-else
-	'Tests are running on a standby server during recovery'
-end;
-                         case                          
--------------------------------------------------------
- Tests are running on a standby server during recovery
-(1 row)
-
diff --git a/src/test/regress/expected/hs_standby_disallowed.out b/src/test/regress/expected/hs_standby_disallowed.out
deleted file mode 100644
index 8d3cafa5cecb..000000000000
--- a/src/test/regress/expected/hs_standby_disallowed.out
+++ /dev/null
@@ -1,133 +0,0 @@
---
--- Hot Standby tests
---
--- hs_standby_disallowed.sql
---
-SET transaction_read_only = off;
-ERROR:  cannot set transaction read-write mode during recovery
-begin transaction read write;
-ERROR:  cannot set transaction read-write mode during recovery
-commit;
-WARNING:  there is no transaction in progress
--- SELECT
-select * from hs1 FOR SHARE;
-ERROR:  cannot execute SELECT FOR SHARE in a read-only transaction
-select * from hs1 FOR UPDATE;
-ERROR:  cannot execute SELECT FOR UPDATE in a read-only transaction
--- DML
-BEGIN;
-insert into hs1 values (37);
-ERROR:  cannot execute INSERT in a read-only transaction
-ROLLBACK;
-BEGIN;
-delete from hs1 where col1 = 1;
-ERROR:  cannot execute DELETE in a read-only transaction
-ROLLBACK;
-BEGIN;
-update hs1 set col1 = NULL where col1 > 0;
-ERROR:  cannot execute UPDATE in a read-only transaction
-ROLLBACK;
-BEGIN;
-truncate hs3;
-ERROR:  cannot execute TRUNCATE TABLE in a read-only transaction
-ROLLBACK;
--- DDL
-create temporary table hstemp1 (col1 integer);
-ERROR:  cannot execute CREATE TABLE in a read-only transaction
-BEGIN;
-drop table hs2;
-ERROR:  cannot execute DROP TABLE in a read-only transaction
-ROLLBACK;
-BEGIN;
-create table hs4 (col1 integer);
-ERROR:  cannot execute CREATE TABLE in a read-only transaction
-ROLLBACK;
--- Sequences
-SELECT nextval('hsseq');
-ERROR:  cannot execute nextval() in a read-only transaction
--- Two-phase commit transaction stuff
-BEGIN;
-SELECT count(*) FROM hs1;
- count 
--------
-     1
-(1 row)
-
-PREPARE TRANSACTION 'foobar';
-ERROR:  cannot execute PREPARE TRANSACTION during recovery
-ROLLBACK;
-BEGIN;
-SELECT count(*) FROM hs1;
- count 
--------
-     1
-(1 row)
-
-COMMIT PREPARED 'foobar';
-ERROR:  cannot execute COMMIT PREPARED during recovery
-ROLLBACK;
-BEGIN;
-SELECT count(*) FROM hs1;
- count 
--------
-     1
-(1 row)
-
-PREPARE TRANSACTION 'foobar';
-ERROR:  cannot execute PREPARE TRANSACTION during recovery
-ROLLBACK PREPARED 'foobar';
-ERROR:  current transaction is aborted, commands ignored until end of transaction block
-ROLLBACK;
-BEGIN;
-SELECT count(*) FROM hs1;
- count 
--------
-     1
-(1 row)
-
-ROLLBACK PREPARED 'foobar';
-ERROR:  cannot execute ROLLBACK PREPARED during recovery
-ROLLBACK;
--- Locks
-BEGIN;
-LOCK hs1;
-ERROR:  cannot execute LOCK TABLE during recovery
-COMMIT;
-BEGIN;
-LOCK hs1 IN SHARE UPDATE EXCLUSIVE MODE;
-ERROR:  cannot execute LOCK TABLE during recovery
-COMMIT;
-BEGIN;
-LOCK hs1 IN SHARE MODE;
-ERROR:  cannot execute LOCK TABLE during recovery
-COMMIT;
-BEGIN;
-LOCK hs1 IN SHARE ROW EXCLUSIVE MODE;
-ERROR:  cannot execute LOCK TABLE during recovery
-COMMIT;
-BEGIN;
-LOCK hs1 IN EXCLUSIVE MODE;
-ERROR:  cannot execute LOCK TABLE during recovery
-COMMIT;
-BEGIN;
-LOCK hs1 IN ACCESS EXCLUSIVE MODE;
-ERROR:  cannot execute LOCK TABLE during recovery
-COMMIT;
--- Listen
-listen a;
-ERROR:  cannot execute LISTEN during recovery
-notify a;
-ERROR:  cannot execute NOTIFY during recovery
--- disallowed commands
-ANALYZE hs1;
-ERROR:  cannot execute ANALYZE during recovery
-VACUUM hs2;
-ERROR:  cannot execute VACUUM during recovery
-CLUSTER hs2 using hs1_pkey;
-ERROR:  cannot execute CLUSTER during recovery
-REINDEX TABLE hs2;
-ERROR:  cannot execute REINDEX during recovery
-REVOKE SELECT ON hs1 FROM PUBLIC;
-ERROR:  cannot execute REVOKE in a read-only transaction
-GRANT SELECT ON hs1 TO PUBLIC;
-ERROR:  cannot execute GRANT in a read-only transaction
diff --git a/src/test/regress/expected/hs_standby_functions.out b/src/test/regress/expected/hs_standby_functions.out
deleted file mode 100644
index ce846b758bf8..000000000000
--- a/src/test/regress/expected/hs_standby_functions.out
+++ /dev/null
@@ -1,40 +0,0 @@
---
--- Hot Standby tests
---
--- hs_standby_functions.sql
---
--- should fail
-select pg_current_xact_id();
-ERROR:  cannot execute pg_current_xact_id() during recovery
-select length(pg_current_snapshot()::text) >= 4;
- ?column? 
-----------
- t
-(1 row)
-
-select pg_start_backup('should fail');
-ERROR:  recovery is in progress
-HINT:  WAL control functions cannot be executed during recovery.
-select pg_switch_wal();
-ERROR:  recovery is in progress
-HINT:  WAL control functions cannot be executed during recovery.
-select pg_stop_backup();
-ERROR:  recovery is in progress
-HINT:  WAL control functions cannot be executed during recovery.
--- should return no rows
-select * from pg_prepared_xacts;
- transaction | gid | prepared | owner | database 
--------------+-----+----------+-------+----------
-(0 rows)
-
--- just the startup process
-select locktype, virtualxid, virtualtransaction, mode, granted
-from pg_locks where virtualxid = '1/1';
-  locktype  | virtualxid | virtualtransaction |     mode      | granted 
-------------+------------+--------------------+---------------+---------
- virtualxid | 1/1        | 1/0                | ExclusiveLock | t
-(1 row)
-
--- suicide is painless
-select pg_cancel_backend(pg_backend_pid());
-ERROR:  canceling statement due to user request
diff --git a/src/test/regress/sql/hs_primary_extremes.sql b/src/test/regress/sql/hs_primary_extremes.sql
deleted file mode 100644
index 2051e2e5cf25..000000000000
--- a/src/test/regress/sql/hs_primary_extremes.sql
+++ /dev/null
@@ -1,73 +0,0 @@
---
--- Hot Standby tests
---
--- hs_primary_extremes.sql
---
-
-drop table if exists hs_extreme;
-create table hs_extreme (col1 integer);
-
-CREATE OR REPLACE FUNCTION hs_subxids (n integer)
-RETURNS void
-LANGUAGE plpgsql
-AS $$
-    BEGIN
-      IF n <= 0 THEN RETURN; END IF;
-      INSERT INTO hs_extreme VALUES (n);
-      PERFORM hs_subxids(n - 1);
-      RETURN;
-    EXCEPTION WHEN raise_exception THEN NULL; END;
-$$;
-
-BEGIN;
-SELECT hs_subxids(257);
-ROLLBACK;
-BEGIN;
-SELECT hs_subxids(257);
-COMMIT;
-
-set client_min_messages = 'warning';
-
-CREATE OR REPLACE FUNCTION hs_locks_create (n integer)
-RETURNS void
-LANGUAGE plpgsql
-AS $$
-    BEGIN
-      IF n <= 0 THEN
-		CHECKPOINT;
-		RETURN;
-	  END IF;
-      EXECUTE 'CREATE TABLE hs_locks_' || n::text || ' ()';
-      PERFORM hs_locks_create(n - 1);
-      RETURN;
-    EXCEPTION WHEN raise_exception THEN NULL; END;
-$$;
-
-CREATE OR REPLACE FUNCTION hs_locks_drop (n integer)
-RETURNS void
-LANGUAGE plpgsql
-AS $$
-    BEGIN
-      IF n <= 0 THEN
-		CHECKPOINT;
-		RETURN;
-	  END IF;
-	  EXECUTE 'DROP TABLE IF EXISTS hs_locks_' || n::text;
-      PERFORM hs_locks_drop(n - 1);
-      RETURN;
-    EXCEPTION WHEN raise_exception THEN NULL; END;
-$$;
-
-BEGIN;
-SELECT hs_locks_drop(257);
-SELECT hs_locks_create(257);
-SELECT count(*) > 257 FROM pg_locks;
-ROLLBACK;
-BEGIN;
-SELECT hs_locks_drop(257);
-SELECT hs_locks_create(257);
-SELECT count(*) > 257 FROM pg_locks;
-COMMIT;
-SELECT hs_locks_drop(257);
-
-SELECT pg_switch_wal();
diff --git a/src/test/regress/sql/hs_primary_setup.sql b/src/test/regress/sql/hs_primary_setup.sql
deleted file mode 100644
index eeb4421307fa..000000000000
--- a/src/test/regress/sql/hs_primary_setup.sql
+++ /dev/null
@@ -1,25 +0,0 @@
---
--- Hot Standby tests
---
--- hs_primary_setup.sql
---
-
-drop table if exists hs1;
-create table hs1 (col1 integer primary key);
-insert into hs1 values (1);
-
-drop table if exists hs2;
-create table hs2 (col1 integer primary key);
-insert into hs2 values (12);
-insert into hs2 values (13);
-
-drop table if exists hs3;
-create table hs3 (col1 integer primary key);
-insert into hs3 values (113);
-insert into hs3 values (114);
-insert into hs3 values (115);
-
-DROP sequence if exists hsseq;
-create sequence hsseq;
-
-SELECT pg_switch_wal();
diff --git a/src/test/regress/sql/hs_standby_allowed.sql b/src/test/regress/sql/hs_standby_allowed.sql
deleted file mode 100644
index 6debddc5e999..000000000000
--- a/src/test/regress/sql/hs_standby_allowed.sql
+++ /dev/null
@@ -1,125 +0,0 @@
---
--- Hot Standby tests
---
--- hs_standby_allowed.sql
---
-
--- SELECT
-
-select count(*) as should_be_1 from hs1;
-
-select count(*) as should_be_2 from hs2;
-
-select count(*) as should_be_3 from hs3;
-
-COPY hs1 TO '/tmp/copy_test';
-\! cat /tmp/copy_test
-
--- Access sequence directly
-select is_called from hsseq;
-
--- Transactions
-
-begin;
-select count(*)  as should_be_1 from hs1;
-end;
-
-begin transaction read only;
-select count(*)  as should_be_1 from hs1;
-end;
-
-begin transaction isolation level repeatable read;
-select count(*) as should_be_1 from hs1;
-select count(*) as should_be_1 from hs1;
-select count(*) as should_be_1 from hs1;
-commit;
-
-begin;
-select count(*) as should_be_1 from hs1;
-commit;
-
-begin;
-select count(*) as should_be_1 from hs1;
-abort;
-
-start transaction;
-select count(*) as should_be_1 from hs1;
-commit;
-
-begin;
-select count(*) as should_be_1 from hs1;
-rollback;
-
-begin;
-select count(*) as should_be_1 from hs1;
-savepoint s;
-select count(*) as should_be_2 from hs2;
-commit;
-
-begin;
-select count(*) as should_be_1 from hs1;
-savepoint s;
-select count(*) as should_be_2 from hs2;
-release savepoint s;
-select count(*) as should_be_2 from hs2;
-savepoint s;
-select count(*) as should_be_3 from hs3;
-rollback to savepoint s;
-select count(*) as should_be_2 from hs2;
-commit;
-
--- SET parameters
-
--- has no effect on read only transactions, but we can still set it
-set synchronous_commit = on;
-show synchronous_commit;
-reset synchronous_commit;
-
-discard temp;
-discard all;
-
--- CURSOR commands
-
-BEGIN;
-
-DECLARE hsc CURSOR FOR select * from hs3;
-
-FETCH next from hsc;
-fetch first from hsc;
-fetch last from hsc;
-fetch 1 from hsc;
-
-CLOSE hsc;
-
-COMMIT;
-
--- Prepared plans
-
-PREPARE hsp AS select count(*) from hs1;
-PREPARE hsp_noexec (integer) AS insert into hs1 values ($1);
-
-EXECUTE hsp;
-
-DEALLOCATE hsp;
-
--- LOCK
-
-BEGIN;
-LOCK hs1 IN ACCESS SHARE MODE;
-LOCK hs1 IN ROW SHARE MODE;
-LOCK hs1 IN ROW EXCLUSIVE MODE;
-COMMIT;
-
--- UNLISTEN
-UNLISTEN a;
-UNLISTEN *;
-
--- LOAD
--- should work, easier if there is no test for that...
-
-
--- ALLOWED COMMANDS
-
-CHECKPOINT;
-
-discard all;
diff --git a/src/test/regress/sql/hs_standby_check.sql b/src/test/regress/sql/hs_standby_check.sql
deleted file mode 100644
index 3fe8a02720ba..000000000000
--- a/src/test/regress/sql/hs_standby_check.sql
+++ /dev/null
@@ -1,16 +0,0 @@
---
--- Hot Standby tests
---
--- hs_standby_check.sql
---
-
---
--- If the query below returns false then all other tests will fail after it.
---
-select case pg_is_in_recovery() when false then
-	'These tests are intended only for execution on a standby server that is reading ' ||
-	'WAL from a server upon which the regression database is already created and into ' ||
-	'which src/test/regress/sql/hs_primary_setup.sql has been run'
-else
-	'Tests are running on a standby server during recovery'
-end;
diff --git a/src/test/regress/sql/hs_standby_disallowed.sql b/src/test/regress/sql/hs_standby_disallowed.sql
deleted file mode 100644
index a470600eec88..000000000000
--- a/src/test/regress/sql/hs_standby_disallowed.sql
+++ /dev/null
@@ -1,103 +0,0 @@
---
--- Hot Standby tests
---
--- hs_standby_disallowed.sql
---
-
-SET transaction_read_only = off;
-
-begin transaction read write;
-commit;
-
--- SELECT
-
-select * from hs1 FOR SHARE;
-select * from hs1 FOR UPDATE;
-
--- DML
-BEGIN;
-insert into hs1 values (37);
-ROLLBACK;
-BEGIN;
-delete from hs1 where col1 = 1;
-ROLLBACK;
-BEGIN;
-update hs1 set col1 = NULL where col1 > 0;
-ROLLBACK;
-BEGIN;
-truncate hs3;
-ROLLBACK;
-
--- DDL
-
-create temporary table hstemp1 (col1 integer);
-BEGIN;
-drop table hs2;
-ROLLBACK;
-BEGIN;
-create table hs4 (col1 integer);
-ROLLBACK;
-
--- Sequences
-
-SELECT nextval('hsseq');
-
--- Two-phase commit transaction stuff
-
-BEGIN;
-SELECT count(*) FROM hs1;
-PREPARE TRANSACTION 'foobar';
-ROLLBACK;
-BEGIN;
-SELECT count(*) FROM hs1;
-COMMIT PREPARED 'foobar';
-ROLLBACK;
-
-BEGIN;
-SELECT count(*) FROM hs1;
-PREPARE TRANSACTION 'foobar';
-ROLLBACK PREPARED 'foobar';
-ROLLBACK;
-
-BEGIN;
-SELECT count(*) FROM hs1;
-ROLLBACK PREPARED 'foobar';
-ROLLBACK;
-
-
--- Locks
-BEGIN;
-LOCK hs1;
-COMMIT;
-BEGIN;
-LOCK hs1 IN SHARE UPDATE EXCLUSIVE MODE;
-COMMIT;
-BEGIN;
-LOCK hs1 IN SHARE MODE;
-COMMIT;
-BEGIN;
-LOCK hs1 IN SHARE ROW EXCLUSIVE MODE;
-COMMIT;
-BEGIN;
-LOCK hs1 IN EXCLUSIVE MODE;
-COMMIT;
-BEGIN;
-LOCK hs1 IN ACCESS EXCLUSIVE MODE;
-COMMIT;
-
--- Listen
-listen a;
-notify a;
-
--- disallowed commands
-
-ANALYZE hs1;
-
-VACUUM hs2;
-
-CLUSTER hs2 using hs1_pkey;
-
-REINDEX TABLE hs2;
-
-REVOKE SELECT ON hs1 FROM PUBLIC;
-GRANT SELECT ON hs1 TO PUBLIC;
diff --git a/src/test/regress/sql/hs_standby_functions.sql b/src/test/regress/sql/hs_standby_functions.sql
deleted file mode 100644
index b57f67ff8b5e..000000000000
--- a/src/test/regress/sql/hs_standby_functions.sql
+++ /dev/null
@@ -1,24 +0,0 @@
---
--- Hot Standby tests
---
--- hs_standby_functions.sql
---
-
--- should fail
-select pg_current_xact_id();
-
-select length(pg_current_snapshot()::text) >= 4;
-
-select pg_start_backup('should fail');
-select pg_switch_wal();
-select pg_stop_backup();
-
--- should return no rows
-select * from pg_prepared_xacts;
-
--- just the startup process
-select locktype, virtualxid, virtualtransaction, mode, granted
-from pg_locks where virtualxid = '1/1';
-
--- suicide is painless
-select pg_cancel_backend(pg_backend_pid());
diff --git a/src/test/regress/standby_schedule b/src/test/regress/standby_schedule
deleted file mode 100644
index 3ddb961c88c5..000000000000
--- a/src/test/regress/standby_schedule
+++ /dev/null
@@ -1,21 +0,0 @@
-# src/test/regress/standby_schedule
-#
-# Test schedule for Hot Standby
-#
-# First test checks we are on a standby server.
-# Subsequent tests rely upon a setup script having already
-# been executed in the appropriate database on the primary server
-# which is feeding WAL files to target standby.
-#
-# psql -f src/test/regress/sql/hs_primary_setup.sql regression
-#
-test: hs_standby_check
-#
-# These tests will pass on both primary and standby servers
-#
-test: hs_standby_allowed
-#
-# These tests will fail on a non-standby server
-#
-test: hs_standby_disallowed
-test: hs_standby_functions
