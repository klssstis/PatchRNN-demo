From 290acac92b1d7bebb4ec68fe8b7a5cb442333eda Mon Sep 17 00:00:00 2001
From: Amit Kapila <akapila@postgresql.org>
Date: Thu, 28 Nov 2019 08:28:17 +0530
Subject: [PATCH] Move pump_until to TestLib.pm.
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

The subroutine pump_until provides the functionality to poll until the
given string is matched, or a timeout occurs.  This can be used from other
places as well, so moving it to TestLib.pm.  The immediate need is for an
upcoming regression test patch for dropdb utility.

Author: Vignesh C
Reviewed-by: Amit Kapila
Discussion: https://postgr.es/m/CAP_rwwmLJJbn70vLOZFpxGw3XD7nLB_7+NKz46H5EOO2k5H7OQ@mail.gmail.com
---
 src/test/perl/TestLib.pm                 | 37 ++++++++++++++
 src/test/recovery/t/013_crash_restart.pl | 63 +++++++++---------------
 2 files changed, 60 insertions(+), 40 deletions(-)

diff --git a/src/test/perl/TestLib.pm b/src/test/perl/TestLib.pm
index 458b80137961..c0e636cfa1dc 100644
--- a/src/test/perl/TestLib.pm
+++ b/src/test/perl/TestLib.pm
@@ -860,6 +860,43 @@ sub command_checks_all
 
 =pod
 
+=item pump_until(proc, timeout, stream, untl)
+
+# Pump until string is matched, or timeout occurs
+
+=cut
+
+sub pump_until
+{
+	my ($proc, $timeout, $stream, $untl) = @_;
+	$proc->pump_nb();
+	while (1)
+	{
+		last if $$stream =~ /$untl/;
+		if ($timeout->is_expired)
+		{
+			diag("aborting wait: program timed out");
+			diag("stream contents: >>", $$stream, "<<");
+			diag("pattern searched for: ", $untl);
+
+			return 0;
+		}
+		if (not $proc->pumpable())
+		{
+			diag("aborting wait: program died");
+			diag("stream contents: >>", $$stream, "<<");
+			diag("pattern searched for: ", $untl);
+
+			return 0;
+		}
+		$proc->pump();
+	}
+	return 1;
+
+}
+
+=pod
+
 =back
 
 =cut
diff --git a/src/test/recovery/t/013_crash_restart.pl b/src/test/recovery/t/013_crash_restart.pl
index 2c477978e7da..595761949c92 100644
--- a/src/test/recovery/t/013_crash_restart.pl
+++ b/src/test/recovery/t/013_crash_restart.pl
@@ -72,7 +72,9 @@
 INSERT INTO alive VALUES($$committed-before-sigquit$$);
 SELECT pg_backend_pid();
 ];
-ok(pump_until($killme, \$killme_stdout, qr/[[:digit:]]+[\r\n]$/m),
+ok(TestLib::pump_until(
+		$killme, $psql_timeout, \$killme_stdout,
+		qr/[[:digit:]]+[\r\n]$/m),
 	'acquired pid for SIGQUIT');
 my $pid = $killme_stdout;
 chomp($pid);
@@ -84,7 +86,9 @@
 BEGIN;
 INSERT INTO alive VALUES($$in-progress-before-sigquit$$) RETURNING status;
 ];
-ok(pump_until($killme, \$killme_stdout, qr/in-progress-before-sigquit/m),
+ok(TestLib::pump_until(
+		$killme, $psql_timeout, \$killme_stdout,
+		qr/in-progress-before-sigquit/m),
 	'inserted in-progress-before-sigquit');
 $killme_stdout = '';
 $killme_stderr = '';
@@ -97,7 +101,8 @@
 SELECT $$psql-connected$$;
 SELECT pg_sleep(3600);
 ];
-ok(pump_until($monitor, \$monitor_stdout, qr/psql-connected/m),
+ok(TestLib::pump_until(
+		$monitor, $psql_timeout, \$monitor_stdout, qr/psql-connected/m),
 	'monitor connected');
 $monitor_stdout = '';
 $monitor_stderr = '';
@@ -112,8 +117,9 @@
 $killme_stdin .= q[
 SELECT 1;
 ];
-ok( pump_until(
+ok( TestLib::pump_until(
 		$killme,
+		$psql_timeout,
 		\$killme_stderr,
 		qr/WARNING:  terminating connection because of crash of another server process|server closed the connection unexpectedly|connection to server was lost/m
 	),
@@ -125,8 +131,9 @@
 # Wait till server restarts - we should get the WARNING here, but
 # sometimes the server is unable to send that, if interrupted while
 # sending.
-ok( pump_until(
+ok( TestLib::pump_until(
 		$monitor,
+		$psql_timeout,
 		\$monitor_stderr,
 		qr/WARNING:  terminating connection because of crash of another server process|server closed the connection unexpectedly|connection to server was lost/m
 	),
@@ -153,7 +160,8 @@
 $killme_stdin .= q[
 SELECT pg_backend_pid();
 ];
-ok(pump_until($killme, \$killme_stdout, qr/[[:digit:]]+[\r\n]$/m),
+ok(TestLib::pump_until(
+		$killme, $psql_timeout, \$killme_stdout, qr/[[:digit:]]+[\r\n]$/m),
 	"acquired pid for SIGKILL");
 $pid = $killme_stdout;
 chomp($pid);
@@ -166,7 +174,9 @@
 BEGIN;
 INSERT INTO alive VALUES($$in-progress-before-sigkill$$) RETURNING status;
 ];
-ok(pump_until($killme, \$killme_stdout, qr/in-progress-before-sigkill/m),
+ok(TestLib::pump_until(
+		$killme, $psql_timeout, \$killme_stdout,
+		qr/in-progress-before-sigkill/m),
 	'inserted in-progress-before-sigkill');
 $killme_stdout = '';
 $killme_stderr = '';
@@ -178,7 +188,8 @@
 SELECT $$psql-connected$$;
 SELECT pg_sleep(3600);
 ];
-ok(pump_until($monitor, \$monitor_stdout, qr/psql-connected/m),
+ok(TestLib::pump_until(
+		$monitor, $psql_timeout, \$monitor_stdout, qr/psql-connected/m),
 	'monitor connected');
 $monitor_stdout = '';
 $monitor_stderr = '';
@@ -194,8 +205,9 @@
 $killme_stdin .= q[
 SELECT 1;
 ];
-ok( pump_until(
+ok( TestLib::pump_until(
 		$killme,
+		$psql_timeout,
 		\$killme_stderr,
 		qr/server closed the connection unexpectedly|connection to server was lost/m
 	),
@@ -205,8 +217,9 @@
 # Wait till server restarts - we should get the WARNING here, but
 # sometimes the server is unable to send that, if interrupted while
 # sending.
-ok( pump_until(
+ok( TestLib::pump_until(
 		$monitor,
+		$psql_timeout,
 		\$monitor_stderr,
 		qr/WARNING:  terminating connection because of crash of another server process|server closed the connection unexpectedly|connection to server was lost/m
 	),
@@ -244,33 +257,3 @@
 	'can still write after orderly restart');
 
 $node->stop();
-
-# Pump until string is matched, or timeout occurs
-sub pump_until
-{
-	my ($proc, $stream, $untl) = @_;
-	$proc->pump_nb();
-	while (1)
-	{
-		last if $$stream =~ /$untl/;
-		if ($psql_timeout->is_expired)
-		{
-			diag("aborting wait: program timed out");
-			diag("stream contents: >>", $$stream, "<<");
-			diag("pattern searched for: ", $untl);
-
-			return 0;
-		}
-		if (not $proc->pumpable())
-		{
-			diag("aborting wait: program died");
-			diag("stream contents: >>", $$stream, "<<");
-			diag("pattern searched for: ", $untl);
-
-			return 0;
-		}
-		$proc->pump();
-	}
-	return 1;
-
-}
