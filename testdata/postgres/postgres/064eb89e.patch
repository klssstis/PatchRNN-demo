From 064eb89e83ea0f59426c92906329f1e6c423dfa4 Mon Sep 17 00:00:00 2001
From: Tom Lane <tgl@sss.pgh.pa.us>
Date: Sat, 15 Apr 2023 12:01:39 -0400
Subject: [PATCH] Fix assignment to array of domain over composite, redux.

Commit 3e310d837 taught isAssignmentIndirectionExpr() to look through
CoerceToDomain nodes.  That's not sufficient, because since commit
04fe805a1 it's been possible for the planner to simplify
CoerceToDomain to RelabelType when the domain has no constraints
to enforce.  So we need to look through RelabelType too.

Per bug #17897 from Alexander Lakhin.  Although 3e310d837 was
back-patched to v11, it seems sufficient to apply this change
to v12 and later, since 04fe805a1 came in in v12.

Dmitry Dolgov

Discussion: https://postgr.es/m/17897-4216c546c3874044@postgresql.org
---
 src/backend/executor/execExpr.c      | 10 ++++++++--
 src/test/regress/expected/domain.out |  9 +++++++++
 src/test/regress/sql/domain.sql      |  4 ++++
 3 files changed, 21 insertions(+), 2 deletions(-)

diff --git a/src/backend/executor/execExpr.c b/src/backend/executor/execExpr.c
index 4c6700de0455..dcf56446c747 100644
--- a/src/backend/executor/execExpr.c
+++ b/src/backend/executor/execExpr.c
@@ -3225,8 +3225,8 @@ ExecInitSubscriptingRef(ExprEvalStep *scratch, SubscriptingRef *sbsref,
  * trees in which each level of assignment has its own CaseTestExpr, and the
  * recursive structure appears within the newvals or refassgnexpr field.
  * There is an exception, though: if the array is an array-of-domain, we will
- * have a CoerceToDomain as the refassgnexpr, and we need to be able to look
- * through that.
+ * have a CoerceToDomain or RelabelType as the refassgnexpr, and we need to
+ * be able to look through that.
  */
 static bool
 isAssignmentIndirectionExpr(Expr *expr)
@@ -3253,6 +3253,12 @@ isAssignmentIndirectionExpr(Expr *expr)
 
 		return isAssignmentIndirectionExpr(cd->arg);
 	}
+	else if (IsA(expr, RelabelType))
+	{
+		RelabelType *r = (RelabelType *) expr;
+
+		return isAssignmentIndirectionExpr(r->arg);
+	}
 	return false;
 }
 
diff --git a/src/test/regress/expected/domain.out b/src/test/regress/expected/domain.out
index b7937fb3bc6c..6d94e84414a6 100644
--- a/src/test/regress/expected/domain.out
+++ b/src/test/regress/expected/domain.out
@@ -606,6 +606,15 @@ table dcomptable;
  {"(1,5)"}
 (1 row)
 
+-- if there's no constraints, a different code path is taken:
+alter domain dcomptype drop constraint dcomptype_check;
+update dcomptable set f1[1].cf1 = -1;  -- now ok
+table dcomptable;
+     f1     
+------------
+ {"(-1,5)"}
+(1 row)
+
 drop table dcomptable;
 drop type comptype cascade;
 NOTICE:  drop cascades to type dcomptype
diff --git a/src/test/regress/sql/domain.sql b/src/test/regress/sql/domain.sql
index a9a56f5277ca..745f5d5fd2b1 100644
--- a/src/test/regress/sql/domain.sql
+++ b/src/test/regress/sql/domain.sql
@@ -307,6 +307,10 @@ table dcomptable;
 update dcomptable set f1[1].cf1 = -1;  -- fail
 update dcomptable set f1[1].cf1 = 1;
 table dcomptable;
+-- if there's no constraints, a different code path is taken:
+alter domain dcomptype drop constraint dcomptype_check;
+update dcomptable set f1[1].cf1 = -1;  -- now ok
+table dcomptable;
 
 drop table dcomptable;
 drop type comptype cascade;
